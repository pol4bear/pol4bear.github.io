<!doctype html><html lang=ko dir=ltr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>알아둬도 쓸데없는 신비한 ESNI | Pol4bear's blog</title>
<meta name=keywords content="네트워크 보안,ESNI,유해사이트 차단"><meta name=description content="ESNI에 대해 알아보자"><meta name=author content="Pol4bear"><link rel=canonical href=https://pol4.dev/posts/what-is-esni/><meta name=google-site-verification content="G-73Y2WPXWJK"><link crossorigin=anonymous href=/assets/css/stylesheet.5c25c975546c048d1a5600aadb48425ae1bc921a9a18fe67d6955c9535260811.css integrity="sha256-XCXJdVRsBI0aVgCq20hCWuG8khqaGP5n1pVclTUmCBE=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js integrity="sha256-rLVP0yu8GYJCi4hQMX5F0Ha5UBJzClk2Zn5rwhd3aSo=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://pol4.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://pol4.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://pol4.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://pol4.dev/apple-touch-icon.png><link rel=mask-icon href=https://pol4.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-73Y2WPXWJK"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-73Y2WPXWJK",{anonymize_ip:!1})}</script><meta property="og:title" content="알아둬도 쓸데없는 신비한 ESNI"><meta property="og:description" content="ESNI에 대해 알아보자"><meta property="og:type" content="article"><meta property="og:url" content="https://pol4.dev/posts/what-is-esni/"><meta property="og:image" content="https://pol4.dev/posts/what-is-esni/esni.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-03-03T16:11:28+09:00"><meta property="article:modified_time" content="2020-03-03T16:11:28+09:00"><meta property="og:site_name" content="Pol4bear's blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://pol4.dev/posts/what-is-esni/esni.png"><meta name=twitter:title content="알아둬도 쓸데없는 신비한 ESNI"><meta name=twitter:description content="ESNI에 대해 알아보자"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://pol4.dev/posts/"},{"@type":"ListItem","position":3,"name":"알아둬도 쓸데없는 신비한 ESNI","item":"https://pol4.dev/posts/what-is-esni/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"알아둬도 쓸데없는 신비한 ESNI","name":"알아둬도 쓸데없는 신비한 ESNI","description":"ESNI에 대해 알아보자","keywords":["네트워크 보안","ESNI","유해사이트 차단"],"articleBody":"서론 2019년 3월 우리나라에서 SNI 기반의 유해사이트 방식이 적용되고나서 GoodbyeDPI, 스나이퍼, 유니콘 등과 더불어 ESNI가 새로운 유해사이트 차단 우회 방식으로 사용되고 있다. 아무리 ESNI가 개인정보 침해를 막아준다고 하지만 인터넷 검열을 하지 않는 나라들은 필요로 하지 않을 것이고, 검열을 하는 나라들은 우리나라와는 비교하지 못할 만큼 더 세게 검열하기 때문에 우리나라를 제외한 다른 나라들에서는 그다지 매력있는 기술이 아닌 것 같다.\nESNI는 프라이버시적으로 정말 좋은 기술인 것 같다. 또한 SNI 차단 장비들이 업데이트되어 우회할 수 있는 방법이 ESNI와 VPN이나 프록시밖에 남지 않는다면 특히 우리나라 사람들에게는 사랑받는 기술이 될 것이다. ESNI가 표준으로 발전하고 공식적으로 사용되기 시작한다면 암호화된 내용을 복호화해볼 수 없는 우리나라에서는 유해사이트를 차단하기 어려울(불가능하다고는 하지 않겠다) 것이다. 아마 조만간 빈번하게 사용될 ESNI란 기술에 대해서 한번 알아보자.\nSNI란? ESNI에 대해 알아보기 전에 SNI를 먼저 알아야 한다. HTTPS가 통신에서 클라이언트는 서버와 통신 전에 어떤 방식으로 암호화할지, 어떤 방식으로 키를 교환할지, 어떤 SSL/TLS 버전을 사용할지 정하기 위해 Handshake 통신을 진행한다.\nHandshake 과정에서 클라이언트는 서버의 인증서를 전송받게 되는데 그 인증서로 자신이 맞는 서버로 접속하는 것인지 검증하게 된다. 서버는 클라이언트에게 적절한 인증서를 전송해줘야 한다. 예를 들어 하나의 서버에서 페이스북과 트위터 두 개의 서비스를 제공한다고 생각해보자. 클라이언트가 연결할 때 어디에 접속하는지 표시를 해두지 않는다면 서버는 페이스북, 트위터 둘 중 어떤 인증서를 전송할 지 경정할 수 없을 것이다. 이 문제를 해결하기 위해 TLS extension인 SNI(Server Name Indication)가 RFC 3546에서 등장했다.\n“server_name” extension “server_name” extension의 Type은 00 00이다. 첫 4바이트 Type과 전체 길이는 모든 TLS extension이 공통적으로 가진 필드다.\nESNI란? SNI가 사용되기 시작하면서 서버 뿐만이 아니라 제 3자도 클라이언트가 어디에 접속하려는지 쉽게 알아낼 수 있다는 단점이 생겼다. 통신되는 내용 자체는 암호화되어 알 수 없다고 하더라도 “어떤 IP 주소를 가진 사람이 어떤 사이트에 빈번하게 접속하더라” 이런 식으로 클라이언트가 어디에 접속하는가만 수집하더라도 충분히 개인정보 침해가 될 수 있다. 실제로 우리나라는 2019년 3월경 HTTP Host 필드를 보고 유해사이트를 차단해서 HTTPS는 차단할 수 없었던 상황에서 SNI 를 적극적으로 이용한 SNI 차단방식을 사용하여 HTTPS 통신 또한 차단하고 있다. 외국에서도 이런 개인정보 침해 관련해서 문제가 있었는지 이 SNI 정보를 암호화할 수 있는 ESNI Extension이 등장했다.\nEncrypted Server Name Indication 즉, ESNI는 아직 TLS 1.3의 표준이 아닌 draft인 상태다. 대부분의 SSL/TLS 라이브러리가 아직 ESNI를 지원하고 있지 않지만, Mozilla의 Firefox 브라우저를 이용하면 ESNI를 사용할 수 있다. 서버의 경우 Cloudflare의 프록시를 사용하면 적용이 가능하다.\nESNI의 핵심적인 내용은 TLS 통신이 이루어지기 전 어떻게 키를 교환할 것인지다. 결국 SNI를 암호화하려면 암호화 키가 필요한데 ESNI는 이 키 관련 문제를 TLS 통신 전 DNS 서버에서 받아오는 방식으로 이 문제를 해결했다. ESNI의 동작 방식은 다음과 같다.\nESNI의 동작 방식 1. 서버 - ESNI 레코드 DNS 서버에 보관하기 ESNI를 제공할 서버는 ESNI 레코드 생성에 앞서 SNI 암호화 키 생성에 사용될 자신의 키 쌍을 생성한다. 그리고, 앞서 생성한 자신의 키 쌍 중 공개 키와 ESNI 버전, Cipher Suite, 유효기간 등 SNI를 암호화할 때 필요한 정보들이 포함된 ESNI 레코드를 생성한 후 Base 64로 인코딩해서 DNS 서버에 보관한다. 단, ESNI 레코드는 _esni.[호스트 이름]에 TXT 레코드로 보관해야 한다.\n_esni.pol4.dev. IN TXT /wEvzh0pACQAHQAgMU5QtkenanuH/Oq2R5sZGt1O8zzZWhUBqala5sduaUIAAhMBAQQAAAAAXlkO0AAAAABeYPfQAAA= 2. 클라이언트 - DNS 서버에서 ESNI 레코드 가져오기 클라이언트는 SNI 암호화에 앞서 DNS 서버에 보관되어 있는 ESNI 레코드를 가져와야 한다. 서버의 IP를 얻어오는 DNS질의와는 별개로 TXT 레코드로 저장되어 있는 ESNI 레코드를 가져와서 ESNI 버전과 ESNI 레코드가 만료되지는 않았는지 확인하고, SNI 암호화 키 생성에 사용되는 서버의 공개 키를 얻어낸다.\n3. 클라이언트 - ESNI를 포함한 Client Hello 전송하기 클라이언트는 DNS 서버에서 가져온 ESNI 레코드의 서버 공개 키와 공유 비밀을 사용하기 위한 임시 키 쌍을 생성한다. 생성한 임시 키와 서버 공개 키를 이용해 생성한 공유 비밀로 SNI 암호화 키를 생성해서 SNI를 암호화한다. 암호화된 SNI는 Client Hello의 “encrypted_server_name” extension에 포함시켜 서버에 전송한다.\n4. 서버 - 암호화된 SNI 복호화하고 Server Hello 전송하기 서버는 Client Hello의 “encrypted_server_name” extension에 있는 클라이언트 임시 공개 키와 ESNI 개인 키(ESNI 레코드의 서버 공개 키와 쌍)를 이용하여 SNI 암호화 키를 생성한다. 생성한 암호화 키를 사용하여 암호화된 SNI를 복호화한 뒤 그에 맞는 Server Hello를 클라이언트에게 전송한다.\n“encrypted_server_name” extension 위와 같은 과정을 거치면 Client Hello에 “encrypted_server_name” extension을 사용할 수 있게 된다. ESNI 초안 5. The “encrypted_server_name” extension에 따르면 TLS extension Type ff ce인 “encrypted_server_name” extension의 구조는 다음과 같다.\nstruct { CipherSuite suite; KeyShareEntry key_share; opaque record_digest\u003c0..2^16-1\u003e; opaque encrypted_sni\u003c0..2^16-1\u003e; } ClientEncryptedSNI; CipherSuite suite: 암호화에 사용된 Cipher Suite KeyShareEntry key_share: SNI 암호화 키 생성에 사용된 Key Share opaque record_digest: SNI 키 생성에 사용한 ESNIKeys의 해쉬값 해쉬 알고리즘은 Cipher Suite에 포함되어 있다. opaque encrypted_sni: 암호화된 SNI 실제 ESNI를 사용했을 때 “encrypted_server_name” extension은 다음과 같다.\nESNI 자세히 알아보기 ESNI 레코드 ESNI 초안 4.1 암호화된 SNI 레코드에 따르면 ESNI 레코드의 구조는 다음과 같다.\n// Copied from TLS 1.3 struct { NamedGroup group; opaque key_exchange\u003c1..2^16-1\u003e; } KeyShareEntry; struct { uint16 version; opaque public_name\u003c1..2^16-1\u003e; KeyShareEntry keys\u003c4..2^16-1\u003e; CipherSuite cipher_suites\u003c2..2^16-2\u003e; uint16 padded_length; Extension extensions\u003c0..2^16-1\u003e; } ESNIKeys; struct { ESNIKeys esni_keys; Extension dns_extensions\u003c0..2^16-1\u003e; } ESNIRecord; KeyShareEntry 구조 ESNIKeys 구조체 SNI를 암호화하는데 실제 사용되는 키와 일부 메타데이터를 포함한다.\nuint16 version: 접속에 사용해야하는 ESNI 버전\nopaque public_name: 암호화 키를 갱신하기 위해 사용되는 신뢰할 수 있는 개체의 이름\n잘못된 설정을 되돌릴 때 쓰인다. KeyShareEntry keys: ESNI 연결에 사용할 수 있는 서버 공개 키 목록\n각 키들은 다른 그룹을 가지고 있어야한다. CipherSuite cipher_suites: SNI 암호화에 사용할 수 있는 Cipher Suite 목록\nuint16 padded_length: SNI를 암호화하기 전 패딩한 서버 이름 목록의 크기\n서버가 지원할 것으로 예상되는 가장 큰 서버 이름 목록을 16의 배수와 가깝게 반올림한 크기와 같게 설정해야한다. 만약 서버가 임의의 와일드카드 서버 이름들을 지원한다면 260으로 설정해야한다. 클라이언트는 padded_length가 260보다 클 경우 ESNIKeys를 무시해야한다. 패딩을 하여 서버 이름 목록의 길이를 고정시키는 이유는 공격자가 암호화된 서버 이름 목록의 길이로 서버 이름을 예측할 수 없게 만들기 위해서다. Extension extensions: 클라이언트가 Client Hello를 만드는데 사용할 수 있는 TLS extension의 목록\n향후 추가적인 기능을 제공하기 위한 공간으로 사용한다. extension은 Type의 MSB를 1로 설정함으로써 Client Hello 필수적으로 포함시키게 할 수 있다. 클라이언트는 필수 extension으로 설정된 extension 중 extension이 있으면 해당 ESNIKeys를 무시해야한다. ESNIRecord 구조체 ESNIKeys esni_keys: SNI를 암호화하는데 실제 사용되는 키와 그 키와 관계된 여러 메타데이터들 Extension extensions: 클라이언트가 서버의 DNS 이름을 질의할때 참고할 수 있는 TLS extension의 목록 향후 추가적인 기능을 제공하기 위한 공간으로 사용한다. extension은 Type의 MSB를 1로 설정함으로써 Client Hello 필수적으로 포함시키게 할 수 있다. 클라이언트는 필수 extension으로 설정된 extension 중 extension이 있으면 해당 ESNI 레코드를 무시해야한다. 추가 정보 서버는 여러개의 ESNI 레코드를 제공함으로써 여러 버전의 ESNI를 제공할 수 있다. ESNI 레코드들 중 클라이언트가 모르는 ESNI 버전을 가진 ESNI 레코드가 있다면 클라이언트는 그 레코드를 무시해야한다. 하지만 대부분의 서버가 하나의 ESNI 레코드만 전송해주는 상태다.\nESNI 초안 05 버전에서 ESNIKeys는 ESNIConfig로 용어가 변경되었다. 또한, DNS를 이용하는 방법은 HTTPSSVC라는 DNS를 이용해서 추가적인 정보를 제공하는 QUIC, ESNI 등 기술들을 위한 기술을 사용하는 것으로 변경되었다. 하지만 아직까진 01 버전 등 이전 버전의 초안으로 구현되어 운용되고 있다. ESNI도 그렇고 HTTPSSVC도 그렇고 아직 초안인 만큼 어떻게 변경될지는 아무도 모른다.\nESNI 레코드에서 정보 취득하기 ESNI 레코드 가져오기 데이터를 파싱할 ENSI 레코드는 다음 명령어로 가져올 수 있다. 아래 명령어로 가져온 ESNI 레코드는 Base 64로 인코딩되어있는 상태다.\nnslookup -type=txt _esni.cloudflare.com ESNI 레코드 디코딩하기 ESNI 레코드를 처음 가져오면 Base 64로 인코딩되어있다. 가져온 ESNI 레코드를 디코딩해서 실제 ESNI 레코드 값을 얻어낼 수 있다. 버프 슈트의 Decoder를 사용하면 쉽게 디코딩할 수 있다.\nESNI 레코드에서 정보 취득하기 ESNI 레코드 디코딩하기를 통해 얻은 ESNI 레코드는 다음과 같다.\nff 01 13 0f a6 4a 00 24 00 1d 00 20 3f 3e c9 d5 c4 62 f9 4e 1b 81 a3 cd f2 ca 4d bb 98 fa 78 2c cc 88 8b ce 82 98 1c 33 f6 12 c7 5f 00 02 13 01 01 04 00 00 00 00 5e 5a 1a 00 00 00 00 00 5e 62 03 00 00 00 DNS에 올라가있는 ESNI 레코드는 ESNIKeys 구조체와 다르게 체크섬과 길이 필드들이 추가되어있다. ESNI 레코드의 모든 숫자 형식 데이터의 바이트 오더는 빅 엔디언으로 되어있다. ESNI 레코드는 아래 테이블과 같은 구조를 취하고 있다.\nESNI 레코드에서 정보를 취득할 때 필드 별로 확인할 것은 다음과 같다.\nESNIKeys의 체크섬을 0으로 채운 뒤 SHA 256으로 해쉬한 해쉬값의 최상위 4바이트와 기존 체크섬이 다르다면 변조된 데이터다. Keys는 복수의 KeyShareEntry로 이루어져 있다. Not Before, Not After은 Unix time으로 되어있다. 위 구조를 따라 ESNI 레코드에서 취득한 정보는 다음과 같다.\nSNI 암호화 키 생성 SNI를 암호화하기에 앞서 암호화 키를 생성해야한다. 서버라면 Client Hello로, 클라이언트라면 DNS에서 받아온 ESNIKeys로 상대방의 공개키를 가지고 있을 것이다. SNI 암호화 키를 생성을 위해 자신의 개인키와 상대방의 공개키로 공유 비밀인 키를 유도해낸다. OpenSSL을 사용할 경우 int EVP_PKEY_derive(EVP_PKEY_CTX *ctx, unsigned char *key, size_t *keylen)를 사용하면 되고, 이때 유도된 키인 공유 비밀을 Z라고 한다. 그 후 Z로부터 HKDF을 이용하여 SNI 암호화 키를 아래와 같이 생성할 수 있다.\nZx = HKDF-Extract(0, Z) key = HKDF-Expand-Label(Zx, KeyLabel, Hash(ESNIContents), key_length) iv = HKDF-Expand-Label(Zx, IVLabel, Hash(ESNIContents), iv_length) 첫 Client Hello에는 KeyLabel을 “esni key\"로, IVLabel을 “esni iv\"로 설정한다. 클아이언트의 두 번째 Client Hello 즉, 첫 번째 Client Hello에 문제가 있어서 Hello Retry Request를 보낸/받은 뒤에는 KeyLabel을 “hrr esni key\"로, IVLabel을 “hrr esni iv\"로 설정한다.\nSNI 암호화하기 SNI 암호화 키 생성 후 암호화에 필요한 것은 다음과 같다.\nRecord Digest: 암호화할 때 사용한 ESNIKeys의 해쉬값 ESNI Key Share: SNI 암호화 키를 생성할 때 사용된 자신의 공개키 TLS Key Share: Client Hello “key_share” extension에 있는 자신의 공개키 cut-and-paste 공격을 방지하기 위해서 AAD로 사용한다. 랜덤: Client Hello의 랜덤 위 요소가 준비되었다면 클라이언트는 암호화할 서버 이름에 패딩을 적용하고 CientESNIInner 객체를 만들어야 한다. 패딩을 한 후 길이가 ESNIKeys의 padded_length와 같아야 한다.\nstruct { opaque dns_name\u003c1..2^16-1\u003e; opaque zeros[ESNIKeys.padded_length - length(dns_name)]; } PaddedServerNameList; struct { uint8 nonce[16]; PaddedServerNameList realSNI; } ClientESNIInner; nonce: 서버로부터 되돌려 보내질 랜덤한 16 바이트 값 dns_name: server_name extension에 들어가는 서버 이름 목록 zeros: 0으로 된 패딩. 패딩의 크기는 ESNIKeys의 padded_length에 의해 결정된다. ClientESNIInner가 준비되었다면 이 값을 AEAD-Encrypt로 암호화하면 된다.\n자세한 내용은 ESNI 초안 5.1.1 암호화된 SNI 보내기 참고\nGitHub sftcd/openssl 리포지토리에 ESNI 암호화/복호화 함수가 구현되어 있다.\n암호화된 SNI를 복호화하기 SNI 암호화하기에서 암호화에 사용된 모든 데이터는 Client Hello에 들어있다. SNI 암호화 키 생성 이후 Client Hello에 있는 “encrypted_server_name” extension과 Random, “key_share” extension을 가져와서 AEAD-Decrypt 하면 복호화가 가능하다.\nESNI를 사용하면 유해사이트 차단이 어려운 이유 우리나라에서는 유해사이트 차단을 하고 있고, 여러 회사에서도 비업무사이트를 막기 위해 노력하고 있다. 하지만, ESNI가 본격적으로 적용되면 지금까지 적용하고 있던 차단 방법들은 사용하기 어려울 것이다. 일단 우리나라의 경우 차단 방식으로 정공법이 아닌 꼼수를 이용한 차단을 하진 못할 것이다. 꼼수로 차단을 진행한다면 언제든지 패치될 가능성이 있기 때문에 결국 고려할 수 있는 방법은 정공법인 ESNI MITM인데 보면 알겠지만 국가 단위로 특히 우리나라에서 적용하긴 어려운 기술이다.\n회사들의 경우 SSL 가시성을 확보하는 형태로 비업무사이트를 차단하고 있을 것인데, 결국 HTTPS 통신에 문제가 없게 하기 위해서 루트 인증서를 설치해두더라도 SSL 가시성 확보 장비에서 SNI를 확인하는 형태로 따로 접속하는 사이트에 대한 인증서를 배포하고 있을 것이다. 하지만, 인증서를 배포하기위해 참고하고 있던 SNI가 암호화되어버리니 SSL 가시성 장비에서 ESNI MITM 기능을 제공해야할 것이다.\nESNI가 사용된 통신을 차단하는 방법 DoH를 차단하는 방법 현재까지 ESNI를 공식적으로 지원하는 브라우저는 Firefox밖에 없다. Firefox는 DoH를 사용하지 않으면 ESNI를 사용할 수 없게 되어있기 때문에 DoH만 차단해도 쉽게 ESNI를 차단할 수 있다. 물론, 정공법이 아닌 꼼수인데다 다른 브라우저들이 ESNI를 지원하고 그 브라우저들 중 DoH가 필수 옵션이 아닌 브라우저가 있다면 효과가 없을 것이다.\nESNI를 MITM하는 방법 일단, 클라이언트가 ESNI 레코드를 DNS 서버에 요청했을 때 내가 만든 ESNI 레코드를 응답해야 한다. 요청 패킷은 내가 무조건 DNS 서버보다 먼저 응답해줄 수 있다면 나둬도 되지만 아니라면 드랍하도록 한다. 나머지는 널리 알려진 TLS MITM과 비슷한 방식으로 동작한다. 클라이언트가 SNI를 암호화했더라도 내가 응답해준 ESNI 레코드(키)를 사용해서 암호화했기 때문에 중간에서 복호화할 수 있다. 하지만, 그렇다고 그 Client Hello 패킷을 그대로 서버에게 보내주면 서버는 SNI를 복호화할 수 없기 때문에 프록시 느낌으로 서버로 별도로 요청하고 응답을 받아와야한다. 그 후 서버로부터 받은 응답을 그대로 클라이언트에게 전달해주면 된다. 별도로 서버로 요청할 때는 굳이 ESNI를 사용하지 않아도 된다. ESNI MITM이 정상적으로 동작하기 위해선 어떤 클라이언트(IP, Port)가 어디로 접속했는지를 모두 분석해서 기억하고 있어야 한다.\nESNI MITM은 정공법이기 때문에 ESNI를 사용하는한 우회할 수 없다. 하지만, 소규모 네트워크에는 적용하기 쉽지만, 대규모 네트워크에는 컴퓨터 자원 문제, 모든 네트워크 트래픽을 분석해야 된다는 문제 때문에 적용하기 어렵다. 물론 ISP는 마음만 먹으면 모든 네트워크 트래픽을 확인할 수 있지만, 무엇보다 MITM은 엄연히 해킹이기 때문에 법적으로도 유해사이트 차단 방법으로는 사용할 수 없을 것이다. 모든 것을 감수하더라도 QoS 때문에 ISP에서는 절대 문제가 생길 수 있는 In-Path 방식의 솔루션은 적용하지 못할 것이다.\nTLS 인증서를 이용하는 방법 HTTPS 통신을 차단하는 방법은 SNI를 이용하는 방법 외에도 인증서에 있는 Issued To의 CN 필드를 이용하는 방법도 있다. 하지만, ESNI가 사용가능한 TLS 1.3 부터는 인증서도 암호화해서 전송하기 때문에 일반적인 방법으로는 사용이 불가능하다. 현재는 패치되어 사용할 수 없는 방법이지만 원리는 다음과 같다.\nTLS 인증서를 평문으로 받아보기 위해선 TLS의 버전을 다운그레이드해야 한다. TLS 통신 중 Client Hello 패킷을 보면 supported_versions extension이 포함되어 있는데, 이 데이터로 실제 TLS 통신의 버전이 결정된다. supported_versions extension에 있는 버전 목록에서 TLS 1.3을 제거한 후 Client Hello 패킷을 ESNI 서버에 보낸다면, ESNI 서버는 암호화된 SNI를 복호화해서 SNI를 얻어낸 후 사용할 수 있는 버전 중 가장 높은 TLS 1.2로 통신을 진행한다. TLS 1.2는 인증서를 암호화하지 않기 때문에 앞서 말한 Issued To의 정보를 이용해서 차단이 가능하다.\n직접 ESNI 패킷을 발생시키지 않고도 가능한데, encrypted_sni extension이 포함된 패킷에서 TLS 1.3을 제거한 후 그대로 전송해도 암호화되지 않은 인증서를 받아볼 수 있다. 편법이기 때문에 패치되었지만, 패치되지 않았다면 HTTPS 차단 방법으로도 이용이 가능했을 것이다.\n","wordCount":"2057","inLanguage":"ko","datePublished":"2020-03-03T16:11:28+09:00","dateModified":"2020-03-03T16:11:28+09:00","author":{"@type":"Person","name":"Pol4bear"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://pol4.dev/posts/what-is-esni/"},"publisher":{"@type":"Organization","name":"Pol4bear's blog","logo":{"@type":"ImageObject","url":"https://pol4.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://pol4.dev accesskey=h title="Pol4bear's blog (Alt + H)"><img src=https://pol4.dev/apple-touch-icon.png alt aria-label=logo height=35>Pol4bear's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://pol4.dev/categories/ title=📄카테고리><span>📄카테고리</span></a></li><li><a href=https://pol4.dev/tags/ title=🔖태그><span>🔖태그</span></a></li><li><a href=https://pol4.dev/search/ title="🔍검색 (Alt + /)" accesskey=/><span>🔍검색</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://pol4.dev>홈</a>&nbsp;»&nbsp;<a href=https://pol4.dev/posts/>Posts</a></div><h1 class=post-title>알아둬도 쓸데없는 신비한 ESNI</h1><div class=post-description>ESNI에 대해 알아보자</div><div class=post-meta><span title='2020-03-03 16:11:28 +0900 KST'>2020년 3월 3일</span>&nbsp;·&nbsp;10 분&nbsp;·&nbsp;2057 단어&nbsp;·&nbsp;Pol4bear&nbsp;|&nbsp;<a href=https://github.com/pol4bear/pol4bear.github.io/issues rel="noopener noreferrer" target=_blank>오류 제보</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>목차</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#서론>서론</a></li><li><a href=#sni란>SNI란?</a><ul><li><a href=#server_name-extension>&ldquo;server_name&rdquo; extension</a></li></ul></li><li><a href=#esni란>ESNI란?</a><ul><li><a href=#esni의-동작-방식>ESNI의 동작 방식</a></li><li><a href=#encrypted_server_name-extension>&ldquo;encrypted_server_name&rdquo; extension</a></li></ul></li><li><a href=#esni-자세히-알아보기>ESNI 자세히 알아보기</a><ul><li><a href=#esni-레코드>ESNI 레코드</a></li><li><a href=#esni-레코드에서-정보-취득하기>ESNI 레코드에서 정보 취득하기</a></li><li><a href=#sni-암호화-키-생성>SNI 암호화 키 생성</a></li><li><a href=#sni-암호화하기>SNI 암호화하기</a></li><li><a href=#암호화된-sni를-복호화하기>암호화된 SNI를 복호화하기</a></li></ul></li><li><a href=#esni를-사용하면-유해사이트-차단이-어려운-이유>ESNI를 사용하면 유해사이트 차단이 어려운 이유</a></li><li><a href=#esni가-사용된-통신을-차단하는-방법>ESNI가 사용된 통신을 차단하는 방법</a><ul><li><a href=#doh를-차단하는-방법>DoH를 차단하는 방법</a></li><li><a href=#esni를-mitm하는-방법>ESNI를 MITM하는 방법</a></li><li><a href=#tls-인증서를-이용하는-방법>TLS 인증서를 이용하는 방법</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=서론>서론<a hidden class=anchor aria-hidden=true href=#서론>#</a></h2><p>2019년 3월 우리나라에서 SNI 기반의 유해사이트 방식이 적용되고나서 GoodbyeDPI, 스나이퍼, 유니콘 등과 더불어 ESNI가 새로운 유해사이트 차단 우회 방식으로 사용되고 있다. 아무리 ESNI가 개인정보 침해를 막아준다고 하지만 인터넷 검열을 하지 않는 나라들은 필요로 하지 않을 것이고, 검열을 하는 나라들은 우리나라와는 비교하지 못할 만큼 더 세게 검열하기 때문에 우리나라를 제외한 다른 나라들에서는 그다지 매력있는 기술이 아닌 것 같다.</p><p>ESNI는 프라이버시적으로 정말 좋은 기술인 것 같다. 또한 SNI 차단 장비들이 업데이트되어 우회할 수 있는 방법이 ESNI와 VPN이나 프록시밖에 남지 않는다면 특히 우리나라 사람들에게는 사랑받는 기술이 될 것이다. ESNI가 표준으로 발전하고 공식적으로 사용되기 시작한다면 암호화된 내용을 복호화해볼 수 없는 우리나라에서는 유해사이트를 차단하기 어려울(불가능하다고는 하지 않겠다) 것이다. 아마 조만간 빈번하게 사용될 ESNI란 기술에 대해서 한번 알아보자.</p><h2 id=sni란>SNI란?<a hidden class=anchor aria-hidden=true href=#sni란>#</a></h2><p>ESNI에 대해 알아보기 전에 SNI를 먼저 알아야 한다. HTTPS가 통신에서 클라이언트는 서버와 통신 전에 어떤 방식으로 암호화할지, 어떤 방식으로 키를 교환할지, 어떤 SSL/TLS 버전을 사용할지 정하기 위해 Handshake 통신을 진행한다.</p><p><img loading=lazy src=tls-handshake.png alt title="TLS Handshake"></p><p>Handshake 과정에서 클라이언트는 서버의 인증서를 전송받게 되는데 그 인증서로 자신이 맞는 서버로 접속하는 것인지 검증하게 된다. 서버는 클라이언트에게 적절한 인증서를 전송해줘야 한다. 예를 들어 하나의 서버에서 페이스북과 트위터 두 개의 서비스를 제공한다고 생각해보자. 클라이언트가 연결할 때 어디에 접속하는지 표시를 해두지 않는다면 서버는 페이스북, 트위터 둘 중 어떤 인증서를 전송할 지 경정할 수 없을 것이다. 이 문제를 해결하기 위해 TLS extension인 <a href=https://tools.ietf.org/html/rfc3546#section-3.1>SNI(Server Name Indication)</a>가 RFC 3546에서 등장했다.</p><h3 id=server_name-extension>&ldquo;server_name&rdquo; extension<a hidden class=anchor aria-hidden=true href=#server_name-extension>#</a></h3><p>&ldquo;server_name&rdquo; extension의 Type은 00 00이다. 첫 4바이트 Type과 전체 길이는 모든 TLS extension이 공통적으로 가진 필드다.</p><p><img loading=lazy src=sni-example.png alt title="SNI example"></p><h2 id=esni란>ESNI란?<a hidden class=anchor aria-hidden=true href=#esni란>#</a></h2><p>SNI가 사용되기 시작하면서 서버 뿐만이 아니라 제 3자도 클라이언트가 어디에 접속하려는지 쉽게 알아낼 수 있다는 단점이 생겼다. 통신되는 내용 자체는 암호화되어 알 수 없다고 하더라도 &ldquo;어떤 IP 주소를 가진 사람이 어떤 사이트에 빈번하게 접속하더라&rdquo; 이런 식으로 클라이언트가 어디에 접속하는가만 수집하더라도 충분히 개인정보 침해가 될 수 있다. 실제로 우리나라는 2019년 3월경 HTTP Host 필드를 보고 유해사이트를 차단해서 HTTPS는 차단할 수 없었던 상황에서 SNI 를 적극적으로 이용한 SNI 차단방식을 사용하여 HTTPS 통신 또한 차단하고 있다. 외국에서도 이런 개인정보 침해 관련해서 문제가 있었는지 이 SNI 정보를 암호화할 수 있는 <a href=https://tools.ietf.org/html/draft-ietf-tls-esni>ESNI Extension</a>이 등장했다.</p><p>Encrypted Server Name Indication 즉, ESNI는 아직 TLS 1.3의 표준이 아닌 draft인 상태다. 대부분의 SSL/TLS 라이브러리가 아직 ESNI를 지원하고 있지 않지만, Mozilla의 <a href=https://www.mozilla.org/ko/firefox/new/>Firefox 브라우저</a>를 이용하면 ESNI를 사용할 수 있다. 서버의 경우 <a href=https://www.cloudflare.com/>Cloudflare</a>의 프록시를 사용하면 적용이 가능하다.</p><p>ESNI의 핵심적인 내용은 TLS 통신이 이루어지기 전 어떻게 키를 교환할 것인지다. 결국 SNI를 암호화하려면 암호화 키가 필요한데 ESNI는 이 키 관련 문제를 TLS 통신 전 DNS 서버에서 받아오는 방식으로 이 문제를 해결했다. ESNI의 동작 방식은 다음과 같다.</p><h3 id=esni의-동작-방식>ESNI의 동작 방식<a hidden class=anchor aria-hidden=true href=#esni의-동작-방식>#</a></h3><p><img loading=lazy src=esni.png alt title=ESNI></p><h4 id=1-서버---esni-레코드esni-레코드-dns-서버에-보관하기>1. 서버 - <a href=#esni-%EB%A0%88%EC%BD%94%EB%93%9C>ESNI 레코드</a> DNS 서버에 보관하기<a hidden class=anchor aria-hidden=true href=#1-서버---esni-레코드esni-레코드-dns-서버에-보관하기>#</a></h4><p>ESNI를 제공할 서버는 ESNI 레코드 생성에 앞서 <a href=#sni-%EC%95%94%ED%98%B8%ED%99%94-%ED%82%A4-%EC%83%9D%EC%84%B1>SNI 암호화 키 생성</a>에 사용될 자신의 키 쌍을 생성한다. 그리고, 앞서 생성한 자신의 키 쌍 중 공개 키와 ESNI 버전, Cipher Suite, 유효기간 등 SNI를 암호화할 때 필요한 정보들이 포함된 ESNI 레코드를 생성한 후 Base 64로 인코딩해서 DNS 서버에 보관한다. 단, ESNI 레코드는 _esni.[호스트 이름]에 TXT 레코드로 보관해야 한다.</p><pre tabindex=0><code>_esni.pol4.dev. IN TXT /wEvzh0pACQAHQAgMU5QtkenanuH/Oq2R5sZGt1O8zzZWhUBqala5sduaUIAAhMBAQQAAAAAXlkO0AAAAABeYPfQAAA=
</code></pre><h4 id=2-클라이언트---dns-서버에서-esni-레코드-가져오기>2. 클라이언트 - DNS 서버에서 ESNI 레코드 가져오기<a hidden class=anchor aria-hidden=true href=#2-클라이언트---dns-서버에서-esni-레코드-가져오기>#</a></h4><p>클라이언트는 SNI 암호화에 앞서 DNS 서버에 보관되어 있는 ESNI 레코드를 가져와야 한다. 서버의 IP를 얻어오는 DNS질의와는 별개로 TXT 레코드로 저장되어 있는 ESNI 레코드를 가져와서 ESNI 버전과 ESNI 레코드가 만료되지는 않았는지 확인하고, SNI 암호화 키 생성에 사용되는 서버의 공개 키를 얻어낸다.</p><h4 id=3-클라이언트---esni를-포함한-client-hello-전송하기>3. 클라이언트 - ESNI를 포함한 Client Hello 전송하기<a hidden class=anchor aria-hidden=true href=#3-클라이언트---esni를-포함한-client-hello-전송하기>#</a></h4><p>클라이언트는 DNS 서버에서 가져온 ESNI 레코드의 서버 공개 키와 공유 비밀을 사용하기 위한 임시 키 쌍을 생성한다. 생성한 임시 키와 서버 공개 키를 이용해 생성한 공유 비밀로 SNI 암호화 키를 생성해서 <a href=#sni-%EC%95%94%ED%98%B8%ED%99%94%ED%95%98%EA%B8%B0>SNI를 암호화</a>한다. 암호화된 SNI는 Client Hello의 <a href=#encrypted_server_name-extension>&ldquo;encrypted_server_name&rdquo; extension</a>에 포함시켜 서버에 전송한다.</p><h4 id=4-서버---암호화된-sni-복호화암호화된-sni를-복호화하기하고-server-hello-전송하기>4. 서버 - <a href=#%EC%95%94%ED%98%B8%ED%99%94%EB%90%9C-sni%EB%A5%BC-%EB%B3%B5%ED%98%B8%ED%99%94%ED%95%98%EA%B8%B0>암호화된 SNI 복호화</a>하고 Server Hello 전송하기<a hidden class=anchor aria-hidden=true href=#4-서버---암호화된-sni-복호화암호화된-sni를-복호화하기하고-server-hello-전송하기>#</a></h4><p>서버는 Client Hello의 &ldquo;encrypted_server_name&rdquo; extension에 있는 클라이언트 임시 공개 키와 ESNI 개인 키(ESNI 레코드의 서버 공개 키와 쌍)를 이용하여 SNI 암호화 키를 생성한다. 생성한 암호화 키를 사용하여 <a href=#%EC%95%94%ED%98%B8%ED%99%94%EB%90%9C-sni%EB%A5%BC-%EB%B3%B5%ED%98%B8%ED%99%94%ED%95%98%EA%B8%B0>암호화된 SNI를 복호화</a>한 뒤 그에 맞는 Server Hello를 클라이언트에게 전송한다.</p><h3 id=encrypted_server_name-extension>&ldquo;encrypted_server_name&rdquo; extension<a hidden class=anchor aria-hidden=true href=#encrypted_server_name-extension>#</a></h3><p>위와 같은 과정을 거치면 Client Hello에 &ldquo;encrypted_server_name&rdquo; extension을 사용할 수 있게 된다. <a href=https://tools.ietf.org/html/draft-ietf-tls-esni-05#section-5>ESNI 초안 5. The &ldquo;encrypted_server_name&rdquo; extension</a>에 따르면 TLS extension Type ff ce인 &ldquo;encrypted_server_name&rdquo; extension의 구조는 다음과 같다.</p><pre tabindex=0><code>struct {
    CipherSuite suite;
    KeyShareEntry key_share;
    opaque record_digest&lt;0..2^16-1&gt;;
    opaque encrypted_sni&lt;0..2^16-1&gt;;
} ClientEncryptedSNI;
</code></pre><ul><li>CipherSuite suite: 암호화에 사용된 Cipher Suite</li><li>KeyShareEntry key_share: SNI 암호화 키 생성에 사용된 Key Share</li><li>opaque record_digest: SNI 키 생성에 사용한 ESNIKeys의 해쉬값<ul><li>해쉬 알고리즘은 Cipher Suite에 포함되어 있다.</li></ul></li><li>opaque encrypted_sni: 암호화된 SNI</li></ul><p>실제 ESNI를 사용했을 때 &ldquo;encrypted_server_name&rdquo; extension은 다음과 같다.</p><p><img loading=lazy src=esni-example.png alt title="ESNI example"></p><h2 id=esni-자세히-알아보기>ESNI 자세히 알아보기<a hidden class=anchor aria-hidden=true href=#esni-자세히-알아보기>#</a></h2><h3 id=esni-레코드>ESNI 레코드<a hidden class=anchor aria-hidden=true href=#esni-레코드>#</a></h3><p><a href=https://tools.ietf.org/html/draft-ietf-tls-esni-04#section-4.1>ESNI 초안 4.1 암호화된 SNI 레코드</a>에 따르면 ESNI 레코드의 구조는 다음과 같다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Copied from TLS 1.3
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>NamedGroup</span> <span class=n>group</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>opaque</span> <span class=n>key_exchange</span><span class=o>&lt;</span><span class=mf>1..2</span><span class=o>^</span><span class=mi>16</span><span class=o>-</span><span class=mi>1</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>KeyShareEntry</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>uint16</span> <span class=n>version</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>opaque</span> <span class=n>public_name</span><span class=o>&lt;</span><span class=mf>1..2</span><span class=o>^</span><span class=mi>16</span><span class=o>-</span><span class=mi>1</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>KeyShareEntry</span> <span class=n>keys</span><span class=o>&lt;</span><span class=mf>4..2</span><span class=o>^</span><span class=mi>16</span><span class=o>-</span><span class=mi>1</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>CipherSuite</span> <span class=n>cipher_suites</span><span class=o>&lt;</span><span class=mf>2..2</span><span class=o>^</span><span class=mi>16</span><span class=o>-</span><span class=mi>2</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>uint16</span> <span class=n>padded_length</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>Extension</span> <span class=n>extensions</span><span class=o>&lt;</span><span class=mf>0..2</span><span class=o>^</span><span class=mi>16</span><span class=o>-</span><span class=mi>1</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>ESNIKeys</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>ESNIKeys</span> <span class=n>esni_keys</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>Extension</span> <span class=n>dns_extensions</span><span class=o>&lt;</span><span class=mf>0..2</span><span class=o>^</span><span class=mi>16</span><span class=o>-</span><span class=mi>1</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>ESNIRecord</span><span class=p>;</span>
</span></span></code></pre></div><h4 id=keyshareentry-구조>KeyShareEntry 구조<a hidden class=anchor aria-hidden=true href=#keyshareentry-구조>#</a></h4><h4 id=esnikeys-구조체>ESNIKeys 구조체<a hidden class=anchor aria-hidden=true href=#esnikeys-구조체>#</a></h4><p>SNI를 암호화하는데 실제 사용되는 키와 일부 메타데이터를 포함한다.</p><ul><li><p>uint16 version: 접속에 사용해야하는 ESNI 버전</p></li><li><p>opaque public_name: 암호화 키를 갱신하기 위해 사용되는 신뢰할 수 있는 개체의 이름</p><ul><li>잘못된 설정을 되돌릴 때 쓰인다.</li></ul></li><li><p>KeyShareEntry keys: ESNI 연결에 사용할 수 있는 서버 공개 키 목록</p><ul><li>각 키들은 다른 <a href=https://tools.ietf.org/html/rfc8446#section-4.2.7>그룹</a>을 가지고 있어야한다.</li></ul></li><li><p>CipherSuite cipher_suites: SNI 암호화에 사용할 수 있는 <a href=https://tools.ietf.org/html/rfc8446#appendix-B.4>Cipher Suite</a> 목록</p></li><li><p>uint16 padded_length: SNI를 암호화하기 전 패딩한 서버 이름 목록의 크기</p><ul><li>서버가 지원할 것으로 예상되는 가장 큰 서버 이름 목록을 16의 배수와 가깝게 반올림한 크기와 같게 설정해야한다.</li><li>만약 서버가 임의의 와일드카드 서버 이름들을 지원한다면 260으로 설정해야한다.</li><li>클라이언트는 padded_length가 260보다 클 경우 ESNIKeys를 무시해야한다.</li><li>패딩을 하여 서버 이름 목록의 길이를 고정시키는 이유는 공격자가 암호화된 서버 이름 목록의 길이로 서버 이름을 예측할 수 없게 만들기 위해서다.</li></ul></li><li><p>Extension extensions: 클라이언트가 Client Hello를 만드는데 사용할 수 있는 <a href=https://tools.ietf.org/html/rfc8446#section-4.2>TLS extension</a>의 목록</p><ul><li>향후 추가적인 기능을 제공하기 위한 공간으로 사용한다.</li><li>extension은 Type의 MSB를 1로 설정함으로써 Client Hello 필수적으로 포함시키게 할 수 있다.</li><li>클라이언트는 필수 extension으로 설정된 extension 중 extension이 있으면 해당 ESNIKeys를 무시해야한다.</li></ul></li></ul><h4 id=esnirecord-구조체>ESNIRecord 구조체<a hidden class=anchor aria-hidden=true href=#esnirecord-구조체>#</a></h4><ul><li>ESNIKeys esni_keys: SNI를 암호화하는데 실제 사용되는 키와 그 키와 관계된 여러 메타데이터들</li><li>Extension extensions: 클라이언트가 서버의 DNS 이름을 질의할때 참고할 수 있는 <a href=https://tools.ietf.org/html/rfc8446#section-4.2>TLS extension</a>의 목록<ul><li>향후 추가적인 기능을 제공하기 위한 공간으로 사용한다.</li><li>extension은 Type의 MSB를 1로 설정함으로써 Client Hello 필수적으로 포함시키게 할 수 있다.</li><li>클라이언트는 필수 extension으로 설정된 extension 중 extension이 있으면 해당 ESNI 레코드를 무시해야한다.</li></ul></li></ul><h4 id=추가-정보>추가 정보<a hidden class=anchor aria-hidden=true href=#추가-정보>#</a></h4><p>서버는 여러개의 ESNI 레코드를 제공함으로써 여러 버전의 ESNI를 제공할 수 있다. ESNI 레코드들 중 클라이언트가 모르는 ESNI 버전을 가진 ESNI 레코드가 있다면 클라이언트는 그 레코드를 무시해야한다. 하지만 대부분의 서버가 하나의 ESNI 레코드만 전송해주는 상태다.</p><p>ESNI 초안 05 버전에서 ESNIKeys는 ESNIConfig로 용어가 변경되었다. 또한, DNS를 이용하는 방법은 <a href=https://tools.ietf.org/html/draft-nygren-dnsop-svcb-httpssvc-00>HTTPSSVC</a>라는 DNS를 이용해서 추가적인 정보를 제공하는 <a href=https://tools.ietf.org/html/draft-ietf-quic-transport>QUIC</a>, ESNI 등 기술들을 위한 기술을 사용하는 것으로 변경되었다. 하지만 아직까진 01 버전 등 이전 버전의 초안으로 구현되어 운용되고 있다. ESNI도 그렇고 HTTPSSVC도 그렇고 아직 초안인 만큼 어떻게 변경될지는 아무도 모른다.</p><h3 id=esni-레코드에서-정보-취득하기>ESNI 레코드에서 정보 취득하기<a hidden class=anchor aria-hidden=true href=#esni-레코드에서-정보-취득하기>#</a></h3><h4 id=esni-레코드-가져오기>ESNI 레코드 가져오기<a hidden class=anchor aria-hidden=true href=#esni-레코드-가져오기>#</a></h4><p>데이터를 파싱할 ENSI 레코드는 다음 명령어로 가져올 수 있다. 아래 명령어로 가져온 ESNI 레코드는 Base 64로 인코딩되어있는 상태다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>nslookup -type<span class=o>=</span>txt _esni.cloudflare.com
</span></span></code></pre></div><h4 id=esni-레코드-디코딩하기>ESNI 레코드 디코딩하기<a hidden class=anchor aria-hidden=true href=#esni-레코드-디코딩하기>#</a></h4><p>ESNI 레코드를 처음 가져오면 Base 64로 인코딩되어있다. 가져온 ESNI 레코드를 디코딩해서 실제 ESNI 레코드 값을 얻어낼 수 있다. <a href=https://portswigger.net/burp>버프 슈트</a>의 Decoder를 사용하면 쉽게 디코딩할 수 있다.</p><p><img loading=lazy src=decode-esni-record.png alt title="Decode ESNI record"></p><h4 id=esni-레코드에서-정보-취득하기-1>ESNI 레코드에서 정보 취득하기<a hidden class=anchor aria-hidden=true href=#esni-레코드에서-정보-취득하기-1>#</a></h4><p><a href=#esni-%EB%A0%88%EC%BD%94%EB%93%9C-%EB%94%94%EC%BD%94%EB%94%A9%ED%95%98%EA%B8%B0>ESNI 레코드 디코딩하기</a>를 통해 얻은 ESNI 레코드는 다음과 같다.</p><pre tabindex=0><code>ff 01 13 0f a6 4a 00 24 00 1d 00 20 3f 3e c9 d5 
c4 62 f9 4e 1b 81 a3 cd f2 ca 4d bb 98 fa 78 2c 
cc 88 8b ce 82 98 1c 33 f6 12 c7 5f 00 02 13 01
01 04 00 00 00 00 5e 5a 1a 00 00 00 00 00 5e 62
03 00 00 00
</code></pre><p>DNS에 올라가있는 ESNI 레코드는 <a href=#esnikeys-%EA%B5%AC%EC%A1%B0%EC%B2%B4>ESNIKeys 구조체</a>와 다르게 체크섬과 길이 필드들이 추가되어있다. ESNI 레코드의 모든 숫자 형식 데이터의 바이트 오더는 빅 엔디언으로 되어있다. ESNI 레코드는 아래 테이블과 같은 구조를 취하고 있다.</p><p>ESNI 레코드에서 정보를 취득할 때 필드 별로 확인할 것은 다음과 같다.</p><ul><li>ESNIKeys의 체크섬을 0으로 채운 뒤 SHA 256으로 해쉬한 해쉬값의 최상위 4바이트와 기존 체크섬이 다르다면 변조된 데이터다.</li><li>Keys는 복수의 KeyShareEntry로 이루어져 있다.</li><li>Not Before, Not After은 <a href=https://en.wikipedia.org/wiki/Unix_time>Unix time</a>으로 되어있다.</li></ul><p>위 구조를 따라 ESNI 레코드에서 취득한 정보는 다음과 같다.</p><h3 id=sni-암호화-키-생성>SNI 암호화 키 생성<a hidden class=anchor aria-hidden=true href=#sni-암호화-키-생성>#</a></h3><p>SNI를 암호화하기에 앞서 암호화 키를 생성해야한다. 서버라면 Client Hello로, 클라이언트라면 DNS에서 받아온 ESNIKeys로 상대방의 공개키를 가지고 있을 것이다. SNI 암호화 키를 생성을 위해 자신의 개인키와 상대방의 공개키로 공유 비밀인 키를 유도해낸다. OpenSSL을 사용할 경우 <a href=https://www.openssl.org/docs/man1.0.2/man3/EVP_PKEY_derive.html>int EVP_PKEY_derive(EVP_PKEY_CTX *ctx, unsigned char *key, size_t *keylen)</a>를 사용하면 되고, 이때 유도된 키인 공유 비밀을 Z라고 한다. 그 후 Z로부터 <a href=https://tools.ietf.org/html/rfc5869>HKDF</a>을 이용하여 SNI 암호화 키를 아래와 같이 생성할 수 있다.</p><pre tabindex=0><code>Zx = HKDF-Extract(0, Z)
key = HKDF-Expand-Label(Zx, KeyLabel, Hash(ESNIContents), key_length)
iv = HKDF-Expand-Label(Zx, IVLabel, Hash(ESNIContents), iv_length)
</code></pre><p>첫 Client Hello에는 KeyLabel을 &ldquo;esni key"로, IVLabel을 &ldquo;esni iv"로 설정한다. 클아이언트의 두 번째 Client Hello 즉, 첫 번째 Client Hello에 문제가 있어서 Hello Retry Request를 보낸/받은 뒤에는 KeyLabel을 &ldquo;hrr esni key"로, IVLabel을 &ldquo;hrr esni iv"로 설정한다.</p><h3 id=sni-암호화하기>SNI 암호화하기<a hidden class=anchor aria-hidden=true href=#sni-암호화하기>#</a></h3><p><a href=#sni-%EC%95%94%ED%98%B8%ED%99%94-%ED%82%A4-%EC%83%9D%EC%84%B1>SNI 암호화 키 생성</a> 후 암호화에 필요한 것은 다음과 같다.</p><ul><li>Record Digest: 암호화할 때 사용한 ESNIKeys의 해쉬값</li><li>ESNI Key Share: SNI 암호화 키를 생성할 때 사용된 자신의 공개키</li><li>TLS Key Share: Client Hello &ldquo;key_share&rdquo; extension에 있는 자신의 공개키<ul><li>cut-and-paste 공격을 방지하기 위해서 AAD로 사용한다.</li></ul></li><li>랜덤: Client Hello의 랜덤</li></ul><p>위 요소가 준비되었다면 클라이언트는 암호화할 서버 이름에 패딩을 적용하고 CientESNIInner 객체를 만들어야 한다. 패딩을 한 후 길이가 ESNIKeys의 padded_length와 같아야 한다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>opaque</span> <span class=n>dns_name</span><span class=o>&lt;</span><span class=mf>1..2</span><span class=o>^</span><span class=mi>16</span><span class=o>-</span><span class=mi>1</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>opaque</span> <span class=n>zeros</span><span class=p>[</span><span class=n>ESNIKeys</span><span class=p>.</span><span class=n>padded_length</span> <span class=o>-</span> <span class=nf>length</span><span class=p>(</span><span class=n>dns_name</span><span class=p>)];</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>PaddedServerNameList</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>uint8</span> <span class=n>nonce</span><span class=p>[</span><span class=mi>16</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>PaddedServerNameList</span> <span class=n>realSNI</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>ClientESNIInner</span><span class=p>;</span>
</span></span></code></pre></div><ul><li>nonce: 서버로부터 되돌려 보내질 랜덤한 16 바이트 값</li><li>dns_name: server_name extension에 들어가는 서버 이름 목록</li><li>zeros: 0으로 된 패딩. 패딩의 크기는 ESNIKeys의 padded_length에 의해 결정된다.</li></ul><p>ClientESNIInner가 준비되었다면 이 값을 AEAD-Encrypt로 암호화하면 된다.</p><p>자세한 내용은 <a href=https://tools.ietf.org/html/draft-ietf-tls-esni-05#section-5.1.1>ESNI 초안 5.1.1 암호화된 SNI 보내기</a> 참고</p><p>GitHub <a href=https://github.com/sftcd/openssl/blob/ESNI-and-ECH/ssl/esni.c>sftcd/openssl</a> 리포지토리에 ESNI 암호화/복호화 함수가 구현되어 있다.</p><h3 id=암호화된-sni를-복호화하기>암호화된 SNI를 복호화하기<a hidden class=anchor aria-hidden=true href=#암호화된-sni를-복호화하기>#</a></h3><p><a href=#sni-%EC%95%94%ED%98%B8%ED%99%94%ED%95%98%EA%B8%B0>SNI 암호화하기</a>에서 암호화에 사용된 모든 데이터는 Client Hello에 들어있다. <a href=#sni-%EC%95%94%ED%98%B8%ED%99%94-%ED%82%A4-%EC%83%9D%EC%84%B1>SNI 암호화 키 생성</a> 이후 Client Hello에 있는 &ldquo;encrypted_server_name&rdquo; extension과 Random, &ldquo;key_share&rdquo; extension을 가져와서 AEAD-Decrypt 하면 복호화가 가능하다.</p><h2 id=esni를-사용하면-유해사이트-차단이-어려운-이유>ESNI를 사용하면 유해사이트 차단이 어려운 이유<a hidden class=anchor aria-hidden=true href=#esni를-사용하면-유해사이트-차단이-어려운-이유>#</a></h2><p>우리나라에서는 유해사이트 차단을 하고 있고, 여러 회사에서도 비업무사이트를 막기 위해 노력하고 있다. 하지만, ESNI가 본격적으로 적용되면 지금까지 적용하고 있던 차단 방법들은 사용하기 어려울 것이다. 일단 우리나라의 경우 차단 방식으로 정공법이 아닌 꼼수를 이용한 차단을 하진 못할 것이다. 꼼수로 차단을 진행한다면 언제든지 패치될 가능성이 있기 때문에 결국 고려할 수 있는 방법은 정공법인 <a href=#esni-mitm>ESNI MITM</a>인데 보면 알겠지만 국가 단위로 특히 우리나라에서 적용하긴 어려운 기술이다.</p><p>회사들의 경우 SSL 가시성을 확보하는 형태로 비업무사이트를 차단하고 있을 것인데, 결국 HTTPS 통신에 문제가 없게 하기 위해서 루트 인증서를 설치해두더라도 SSL 가시성 확보 장비에서 SNI를 확인하는 형태로 따로 접속하는 사이트에 대한 인증서를 배포하고 있을 것이다. 하지만, 인증서를 배포하기위해 참고하고 있던 SNI가 암호화되어버리니 SSL 가시성 장비에서 <a href=#esni-mitm>ESNI MITM</a> 기능을 제공해야할 것이다.</p><h2 id=esni가-사용된-통신을-차단하는-방법>ESNI가 사용된 통신을 차단하는 방법<a hidden class=anchor aria-hidden=true href=#esni가-사용된-통신을-차단하는-방법>#</a></h2><h3 id=doh를-차단하는-방법>DoH를 차단하는 방법<a hidden class=anchor aria-hidden=true href=#doh를-차단하는-방법>#</a></h3><p>현재까지 ESNI를 공식적으로 지원하는 브라우저는 Firefox밖에 없다. Firefox는 DoH를 사용하지 않으면 ESNI를 사용할 수 없게 되어있기 때문에 DoH만 차단해도 쉽게 ESNI를 차단할 수 있다. 물론, 정공법이 아닌 꼼수인데다 다른 브라우저들이 ESNI를 지원하고 그 브라우저들 중 DoH가 필수 옵션이 아닌 브라우저가 있다면 효과가 없을 것이다.</p><h3 id=esni를-mitm하는-방법>ESNI를 MITM하는 방법<a hidden class=anchor aria-hidden=true href=#esni를-mitm하는-방법>#</a></h3><p>일단, 클라이언트가 ESNI 레코드를 DNS 서버에 요청했을 때 내가 만든 ESNI 레코드를 응답해야 한다. 요청 패킷은 내가 무조건 DNS 서버보다 먼저 응답해줄 수 있다면 나둬도 되지만 아니라면 드랍하도록 한다. 나머지는 널리 알려진 TLS MITM과 비슷한 방식으로 동작한다. 클라이언트가 SNI를 암호화했더라도 내가 응답해준 ESNI 레코드(키)를 사용해서 암호화했기 때문에 중간에서 복호화할 수 있다. 하지만, 그렇다고 그 Client Hello 패킷을 그대로 서버에게 보내주면 서버는 SNI를 복호화할 수 없기 때문에 프록시 느낌으로 서버로 별도로 요청하고 응답을 받아와야한다. 그 후 서버로부터 받은 응답을 그대로 클라이언트에게 전달해주면 된다. 별도로 서버로 요청할 때는 굳이 ESNI를 사용하지 않아도 된다. ESNI MITM이 정상적으로 동작하기 위해선 어떤 클라이언트(IP, Port)가 어디로 접속했는지를 모두 분석해서 기억하고 있어야 한다.</p><p>ESNI MITM은 정공법이기 때문에 ESNI를 사용하는한 우회할 수 없다. 하지만, 소규모 네트워크에는 적용하기 쉽지만, 대규모 네트워크에는 컴퓨터 자원 문제, 모든 네트워크 트래픽을 분석해야 된다는 문제 때문에 적용하기 어렵다. 물론 ISP는 마음만 먹으면 모든 네트워크 트래픽을 확인할 수 있지만, 무엇보다 MITM은 엄연히 해킹이기 때문에 법적으로도 유해사이트 차단 방법으로는 사용할 수 없을 것이다. 모든 것을 감수하더라도 QoS 때문에 ISP에서는 절대 문제가 생길 수 있는 In-Path 방식의 솔루션은 적용하지 못할 것이다.</p><h3 id=tls-인증서를-이용하는-방법>TLS 인증서를 이용하는 방법<a hidden class=anchor aria-hidden=true href=#tls-인증서를-이용하는-방법>#</a></h3><p>HTTPS 통신을 차단하는 방법은 SNI를 이용하는 방법 외에도 인증서에 있는 Issued To의 CN 필드를 이용하는 방법도 있다. 하지만, ESNI가 사용가능한 TLS 1.3 부터는 인증서도 암호화해서 전송하기 때문에 일반적인 방법으로는 사용이 불가능하다. 현재는 패치되어 사용할 수 없는 방법이지만 원리는 다음과 같다.</p><p><img loading=lazy src=tls-certificate.png alt title="TLS certificate"></p><p>TLS 인증서를 평문으로 받아보기 위해선 TLS의 버전을 다운그레이드해야 한다. TLS 통신 중 Client Hello 패킷을 보면 supported_versions extension이 포함되어 있는데, 이 데이터로 실제 TLS 통신의 버전이 결정된다. supported_versions extension에 있는 버전 목록에서 TLS 1.3을 제거한 후 Client Hello 패킷을 ESNI 서버에 보낸다면, ESNI 서버는 암호화된 SNI를 복호화해서 SNI를 얻어낸 후 사용할 수 있는 버전 중 가장 높은 TLS 1.2로 통신을 진행한다. TLS 1.2는 인증서를 암호화하지 않기 때문에 앞서 말한 Issued To의 정보를 이용해서 차단이 가능하다.</p><p><img loading=lazy src=supported-version-extension.png alt title="supported_version extension"></p><p>직접 ESNI 패킷을 발생시키지 않고도 가능한데, encrypted_sni extension이 포함된 패킷에서 TLS 1.3을 제거한 후 그대로 전송해도 암호화되지 않은 인증서를 받아볼 수 있다. 편법이기 때문에 패치되었지만, 패치되지 않았다면 HTTPS 차단 방법으로도 이용이 가능했을 것이다.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://pol4.dev/tags/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%B3%B4%EC%95%88/>네트워크 보안</a></li><li><a href=https://pol4.dev/tags/esni/>ESNI</a></li><li><a href=https://pol4.dev/tags/%EC%9C%A0%ED%95%B4%EC%82%AC%EC%9D%B4%ED%8A%B8-%EC%B0%A8%EB%8B%A8/>유해사이트 차단</a></li></ul><nav class=paginav><a class=prev href=https://pol4.dev/posts/about-harmful-website-blocking-in-korea/><span class=title>« 이전 페이지</span><br><span>유해사이트 차단에 대해서</span>
</a><a class=next href=https://pol4.dev/posts/esni-vulnerability-bug-bounty/><span class=title>다음 페이지 »</span><br><span>ESNI 무력화 취약점 버그 바운티 후기</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 알아둬도 쓸데없는 신비한 ESNI on x" href="https://x.com/intent/tweet/?text=%ec%95%8c%ec%95%84%eb%91%ac%eb%8f%84%20%ec%93%b8%eb%8d%b0%ec%97%86%eb%8a%94%20%ec%8b%a0%eb%b9%84%ed%95%9c%20ESNI&amp;url=https%3a%2f%2fpol4.dev%2fposts%2fwhat-is-esni%2f&amp;hashtags=%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac%eb%b3%b4%ec%95%88%2cESNI%2c%ec%9c%a0%ed%95%b4%ec%82%ac%ec%9d%b4%ed%8a%b8%ec%b0%a8%eb%8b%a8"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 알아둬도 쓸데없는 신비한 ESNI on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fpol4.dev%2fposts%2fwhat-is-esni%2f&amp;title=%ec%95%8c%ec%95%84%eb%91%ac%eb%8f%84%20%ec%93%b8%eb%8d%b0%ec%97%86%eb%8a%94%20%ec%8b%a0%eb%b9%84%ed%95%9c%20ESNI&amp;summary=%ec%95%8c%ec%95%84%eb%91%ac%eb%8f%84%20%ec%93%b8%eb%8d%b0%ec%97%86%eb%8a%94%20%ec%8b%a0%eb%b9%84%ed%95%9c%20ESNI&amp;source=https%3a%2f%2fpol4.dev%2fposts%2fwhat-is-esni%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 알아둬도 쓸데없는 신비한 ESNI on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fpol4.dev%2fposts%2fwhat-is-esni%2f&title=%ec%95%8c%ec%95%84%eb%91%ac%eb%8f%84%20%ec%93%b8%eb%8d%b0%ec%97%86%eb%8a%94%20%ec%8b%a0%eb%b9%84%ed%95%9c%20ESNI"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 알아둬도 쓸데없는 신비한 ESNI on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fpol4.dev%2fposts%2fwhat-is-esni%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 알아둬도 쓸데없는 신비한 ESNI on whatsapp" href="https://api.whatsapp.com/send?text=%ec%95%8c%ec%95%84%eb%91%ac%eb%8f%84%20%ec%93%b8%eb%8d%b0%ec%97%86%eb%8a%94%20%ec%8b%a0%eb%b9%84%ed%95%9c%20ESNI%20-%20https%3a%2f%2fpol4.dev%2fposts%2fwhat-is-esni%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 알아둬도 쓸데없는 신비한 ESNI on telegram" href="https://telegram.me/share/url?text=%ec%95%8c%ec%95%84%eb%91%ac%eb%8f%84%20%ec%93%b8%eb%8d%b0%ec%97%86%eb%8a%94%20%ec%8b%a0%eb%b9%84%ed%95%9c%20ESNI&amp;url=https%3a%2f%2fpol4.dev%2fposts%2fwhat-is-esni%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 알아둬도 쓸데없는 신비한 ESNI on ycombinator" href="https://news.ycombinator.com/submitlink?t=%ec%95%8c%ec%95%84%eb%91%ac%eb%8f%84%20%ec%93%b8%eb%8d%b0%ec%97%86%eb%8a%94%20%ec%8b%a0%eb%b9%84%ed%95%9c%20ESNI&u=https%3a%2f%2fpol4.dev%2fposts%2fwhat-is-esni%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://pol4.dev>Pol4bear's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>